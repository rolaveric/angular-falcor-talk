System.registerDynamic("github:angular/bower-angular@1.4.7/angular", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else if (isFunction(source.cloneNode)) {
              destination = source.cloneNode(true);
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.7',
        major: 1,
        minor: 4,
        dot: 7,
        codeName: 'dark-luminescence'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise()['catch'](f1);
            },
            'finally': function(f1) {
              return this.getPromise()['finally'](f1);
            }
          };
          return function(element, options) {
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name, fullExpression) {
        name = name + '';
        if (!isString(name)) {
          throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ',text)');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
            formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
              if (option.value !== element.value)
                element.value = option.selectValue;
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_ || emptyOption_ && emptyOption_.nodeType === NODE_TYPE_COMMENT)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var valueInterpolated = $interpolate(attr.value, true);
            } else {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              function addOption(optionValue) {
                selectCtrl.addOption(optionValue, element);
                selectCtrl.ngModelCtrl.$render();
                chromeHack(element);
              }
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (valueInterpolated) {
                  var oldVal;
                  attr.$observe('value', function valueAttributeObserveAction(newVal) {
                    if (isDefined(oldVal)) {
                      selectCtrl.removeOption(oldVal);
                    }
                    oldVal = newVal;
                    addOption(newVal);
                  });
                } else if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    addOption(newVal);
                  });
                } else {
                  addOption(attr.value);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.4.7", ["github:angular/bower-angular@1.4.7/angular"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular@1.4.7/angular");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.fails", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.support-desc", ["npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !require("npm:core-js@1.2.1/modules/$.fails")(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.property-desc", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.global", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNDEFINED = 'undefined';
  var global = module.exports = typeof window != UNDEFINED && window.Math == Math ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.html", ["npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.1/modules/$.global").document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.is-object", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.dom-create", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      document = require("npm:core-js@1.2.1/modules/$.global").document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.has", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.cof", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.core", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.1'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.hide", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.support-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc");
  module.exports = require("npm:core-js@1.2.1/modules/$.support-desc") ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.uid", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.redef", ["npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      SRC = require("npm:core-js@1.2.1/modules/$.uid")('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  require("npm:core-js@1.2.1/modules/$.core").inspectSource = function(it) {
    return $toString.call(it);
  };
  (module.exports = function(O, key, val, safe) {
    if (typeof val == 'function') {
      hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      if (!('name' in val))
        val.name = key;
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe)
        delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.def", ["npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.core", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      core = require("npm:core-js@1.2.1/modules/$.core"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      $redef = require("npm:core-js@1.2.1/modules/$.redef"),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      out = (own ? target : source)[key];
      if (type & $def.B && own)
        exp = ctx(out, global);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own)
        $redef(target, key, out);
      if (exports[key] != out)
        hide(exports, key, exp);
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  global.core = core;
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.invoke", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.a-function", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.ctx", ["npm:core-js@1.2.1/modules/$.a-function"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = require("npm:core-js@1.2.1/modules/$.a-function");
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iobject", ["npm:core-js@1.2.1/modules/$.cof"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/modules/$.cof");
  module.exports = 0 in Object('z') ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.defined", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.to-object", ["npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.to-integer", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.to-length", ["npm:core-js@1.2.1/modules/$.to-integer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = require("npm:core-js@1.2.1/modules/$.to-integer"),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.is-array", ["npm:core-js@1.2.1/modules/$.cof"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/modules/$.cof");
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.shared", ["npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.wks", ["npm:core-js@1.2.1/modules/$.shared", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.uid"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = require("npm:core-js@1.2.1/modules/$.shared")('wks'),
      Symbol = require("npm:core-js@1.2.1/modules/$.global").Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || require("npm:core-js@1.2.1/modules/$.uid"))('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.array-methods", ["npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.iobject", "npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.is-array", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      IObject = require("npm:core-js@1.2.1/modules/$.iobject"),
      toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      isArray = require("npm:core-js@1.2.1/modules/$.is-array"),
      SPECIES = require("npm:core-js@1.2.1/modules/$.wks")('species');
  var ASC = function(original, length) {
    var C;
    if (isArray(original) && isObject(C = original.constructor)) {
      C = C[SPECIES];
      if (C === null)
        C = undefined;
    }
    return new (C === undefined ? Array : C)(length);
  };
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? ASC($this, length) : IS_FILTER ? ASC($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.an-object", ["npm:core-js@1.2.1/modules/$.is-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.to-iobject", ["npm:core-js@1.2.1/modules/$.iobject", "npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = require("npm:core-js@1.2.1/modules/$.iobject"),
      defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.to-index", ["npm:core-js@1.2.1/modules/$.to-integer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = require("npm:core-js@1.2.1/modules/$.to-integer"),
      max = Math.max,
      min = Math.min;
  module.exports = function(index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.array-includes", ["npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.to-index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      toIndex = require("npm:core-js@1.2.1/modules/$.to-index");
  module.exports = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) {
            if (O[index] === el)
              return IS_INCLUDES || index;
          }
      return !IS_INCLUDES && -1;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es5", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.html", "npm:core-js@1.2.1/modules/$.dom-create", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.cof", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.invoke", "npm:core-js@1.2.1/modules/$.array-methods", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.a-function", "npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.to-integer", "npm:core-js@1.2.1/modules/$.to-index", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.iobject", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.array-includes", "npm:core-js@1.2.1/modules/$.is-array"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      SUPPORT_DESC = require("npm:core-js@1.2.1/modules/$.support-desc"),
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc"),
      html = require("npm:core-js@1.2.1/modules/$.html"),
      cel = require("npm:core-js@1.2.1/modules/$.dom-create"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      cof = require("npm:core-js@1.2.1/modules/$.cof"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      invoke = require("npm:core-js@1.2.1/modules/$.invoke"),
      arrayMethod = require("npm:core-js@1.2.1/modules/$.array-methods"),
      IE_PROTO = require("npm:core-js@1.2.1/modules/$.uid")('__proto__'),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      aFunction = require("npm:core-js@1.2.1/modules/$.a-function"),
      toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      toInteger = require("npm:core-js@1.2.1/modules/$.to-integer"),
      toIndex = require("npm:core-js@1.2.1/modules/$.to-index"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      IObject = require("npm:core-js@1.2.1/modules/$.iobject"),
      fails = require("npm:core-js@1.2.1/modules/$.fails"),
      ObjectProto = Object.prototype,
      A = [],
      _slice = A.slice,
      _join = A.join,
      defineProperty = $.setDesc,
      getOwnDescriptor = $.getDesc,
      defineProperties = $.setDescs,
      $indexOf = require("npm:core-js@1.2.1/modules/$.array-includes")(false),
      factories = {},
      IE8_DOM_DEFINE;
  if (!SUPPORT_DESC) {
    IE8_DOM_DEFINE = !fails(function() {
      return defineProperty(cel('div'), 'a', {get: function() {
          return 7;
        }}).a != 7;
    });
    $.setDesc = function(O, P, Attributes) {
      if (IE8_DOM_DEFINE)
        try {
          return defineProperty(O, P, Attributes);
        } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes)
        throw TypeError('Accessors not supported!');
      if ('value' in Attributes)
        anObject(O)[P] = Attributes.value;
      return O;
    };
    $.getDesc = function(O, P) {
      if (IE8_DOM_DEFINE)
        try {
          return getOwnDescriptor(O, P);
        } catch (e) {}
      if (has(O, P))
        return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
    };
    $.setDescs = defineProperties = function(O, Properties) {
      anObject(O);
      var keys = $.getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i)
        $.setDesc(O, P = keys[i++], Properties[P]);
      return O;
    };
  }
  $def($def.S + $def.F * !SUPPORT_DESC, 'Object', {
    getOwnPropertyDescriptor: $.getDesc,
    defineProperty: $.setDesc,
    defineProperties: defineProperties
  });
  var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
      keys2 = keys1.concat('length', 'prototype'),
      keysLen1 = keys1.length;
  var createDict = function() {
    var iframe = cel('iframe'),
        i = keysLen1,
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--)
      delete createDict.prototype[keys1[i]];
    return createDict();
  };
  var createGetKeys = function(names, length) {
    return function(object) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O)
        if (key != IE_PROTO)
          has(O, key) && result.push(key);
      while (length > i)
        if (has(O, key = names[i++])) {
          ~$indexOf(result, key) || result.push(key);
        }
      return result;
    };
  };
  var Empty = function() {};
  $def($def.S, 'Object', {
    getPrototypeOf: $.getProto = $.getProto || function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    },
    getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
    create: $.create = $.create || function(O, Properties) {
      var result;
      if (O !== null) {
        Empty.prototype = anObject(O);
        result = new Empty();
        Empty.prototype = null;
        result[IE_PROTO] = O;
      } else
        result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    },
    keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
  });
  var construct = function(F, len, args) {
    if (!(len in factories)) {
      for (var n = [],
          i = 0; i < len; i++)
        n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
  };
  $def($def.P, 'Function', {bind: function bind(that) {
      var fn = aFunction(this),
          partArgs = _slice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(_slice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype))
        bound.prototype = fn.prototype;
      return bound;
    }});
  var buggySlice = fails(function() {
    if (html)
      _slice.call(html);
  });
  $def($def.P + $def.F * buggySlice, 'Array', {slice: function(begin, end) {
      var len = toLength(this.length),
          klass = cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array')
        return _slice.call(this, begin, end);
      var start = toIndex(begin, len),
          upTo = toIndex(end, len),
          size = toLength(upTo - start),
          cloned = Array(size),
          i = 0;
      for (; i < size; i++)
        cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      return cloned;
    }});
  $def($def.P + $def.F * (IObject != Object), 'Array', {join: function() {
      return _join.apply(IObject(this), arguments);
    }});
  $def($def.S, 'Array', {isArray: require("npm:core-js@1.2.1/modules/$.is-array")});
  var createArrayReduce = function(isRight) {
    return function(callbackfn, memo) {
      aFunction(callbackfn);
      var O = IObject(this),
          length = toLength(O.length),
          index = isRight ? length - 1 : 0,
          i = isRight ? -1 : 1;
      if (arguments.length < 2)
        for (; ; ) {
          if (index in O) {
            memo = O[index];
            index += i;
            break;
          }
          index += i;
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }
      for (; isRight ? index >= 0 : length > index; index += i)
        if (index in O) {
          memo = callbackfn(memo, O[index], index, this);
        }
      return memo;
    };
  };
  var methodize = function($fn) {
    return function(arg1) {
      return $fn(this, arg1, arguments[1]);
    };
  };
  $def($def.P, 'Array', {
    forEach: $.each = $.each || methodize(arrayMethod(0)),
    map: methodize(arrayMethod(1)),
    filter: methodize(arrayMethod(2)),
    some: methodize(arrayMethod(3)),
    every: methodize(arrayMethod(4)),
    reduce: createArrayReduce(false),
    reduceRight: createArrayReduce(true),
    indexOf: methodize($indexOf),
    lastIndexOf: function(el, fromIndex) {
      var O = toIObject(this),
          length = toLength(O.length),
          index = length - 1;
      if (arguments.length > 1)
        index = Math.min(index, toInteger(fromIndex));
      if (index < 0)
        index = toLength(length + index);
      for (; index >= 0; index--)
        if (index in O)
          if (O[index] === el)
            return index;
      return -1;
    }
  });
  $def($def.S, 'Date', {now: function() {
      return +new Date;
    }});
  var lz = function(num) {
    return num > 9 ? num : '0' + num;
  };
  var date = new Date(-5e13 - 1),
      brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z' && fails(function() {
        new Date(NaN).toISOString();
      }));
  $def($def.P + $def.F * brokenDate, 'Date', {toISOString: function toISOString() {
      if (!isFinite(this))
        throw RangeError('Invalid time value');
      var d = this,
          y = d.getUTCFullYear(),
          m = d.getUTCMilliseconds(),
          s = y < 0 ? '-' : y > 9999 ? '+' : '';
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.tag", ["npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var has = require("npm:core-js@1.2.1/modules/$.has"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      TAG = require("npm:core-js@1.2.1/modules/$.wks")('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      hide(it, TAG, tag);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.keyof", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.to-iobject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject");
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.get-names", ["npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString,
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      getNames = require("npm:core-js@1.2.1/modules/$").getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.enum-keys", ["npm:core-js@1.2.1/modules/$"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$");
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.library", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = false;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.symbol", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.redef", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.shared", "npm:core-js@1.2.1/modules/$.tag", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.keyof", "npm:core-js@1.2.1/modules/$.get-names", "npm:core-js@1.2.1/modules/$.enum-keys", "npm:core-js@1.2.1/modules/$.is-array", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.library"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      global = require("npm:core-js@1.2.1/modules/$.global"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      SUPPORT_DESC = require("npm:core-js@1.2.1/modules/$.support-desc"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      $redef = require("npm:core-js@1.2.1/modules/$.redef"),
      $fails = require("npm:core-js@1.2.1/modules/$.fails"),
      shared = require("npm:core-js@1.2.1/modules/$.shared"),
      setTag = require("npm:core-js@1.2.1/modules/$.tag"),
      uid = require("npm:core-js@1.2.1/modules/$.uid"),
      wks = require("npm:core-js@1.2.1/modules/$.wks"),
      keyOf = require("npm:core-js@1.2.1/modules/$.keyof"),
      $names = require("npm:core-js@1.2.1/modules/$.get-names"),
      enumKeys = require("npm:core-js@1.2.1/modules/$.enum-keys"),
      isArray = require("npm:core-js@1.2.1/modules/$.is-array"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc"),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = SUPPORT_DESC && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    var args = [it],
        i = 1,
        replacer,
        $replacer;
    while (arguments.length > i)
      args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments[0]));
    };
    $redef($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (SUPPORT_DESC && !require("npm:core-js@1.2.1/modules/$.library")) {
      $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $def($def.G + $def.W, {Symbol: $Symbol});
  $def($def.S, 'Symbol', symbolStatics);
  $def($def.S + $def.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setTag($Symbol, 'Symbol');
  setTag(Math, 'Math', true);
  setTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.assign", ["npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.iobject", "npm:core-js@1.2.1/modules/$.enum-keys", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      IObject = require("npm:core-js@1.2.1/modules/$.iobject"),
      enumKeys = require("npm:core-js@1.2.1/modules/$.enum-keys"),
      has = require("npm:core-js@1.2.1/modules/$.has");
  module.exports = require("npm:core-js@1.2.1/modules/$.fails")(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        l = arguments.length,
        i = 1;
    while (l > i) {
      var S = IObject(arguments[i++]),
          keys = enumKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (has(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.assign", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.assign"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S + $def.F, 'Object', {assign: require("npm:core-js@1.2.1/modules/$.assign")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.same", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.is", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.same"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Object', {is: require("npm:core-js@1.2.1/modules/$.same")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.set-proto", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.ctx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = require("npm:core-js@1.2.1/modules/$").getDesc,
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = require("npm:core-js@1.2.1/modules/$.ctx")(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.set-prototype-of", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.set-proto"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Object', {setPrototypeOf: require("npm:core-js@1.2.1/modules/$.set-proto").set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.classof", ["npm:core-js@1.2.1/modules/$.cof", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/modules/$.cof"),
      TAG = require("npm:core-js@1.2.1/modules/$.wks")('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.to-string", ["npm:core-js@1.2.1/modules/$.classof", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var classof = require("npm:core-js@1.2.1/modules/$.classof"),
      test = {};
  test[require("npm:core-js@1.2.1/modules/$.wks")('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    require("npm:core-js@1.2.1/modules/$.redef")(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.object-sap", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.core", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, exec) {
    var $def = require("npm:core-js@1.2.1/modules/$.def"),
        fn = (require("npm:core-js@1.2.1/modules/$.core").Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.freeze", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.seal", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('seal', function($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.prevent-extensions", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('preventExtensions', function($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.is-frozen", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('isFrozen', function($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.is-sealed", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('isSealed', function($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.is-extensible", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('isExtensible', function($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.get-own-property-descriptor", ["npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject");
  require("npm:core-js@1.2.1/modules/$.object-sap")('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.get-prototype-of", ["npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("npm:core-js@1.2.1/modules/$.to-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('getPrototypeOf', function($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.keys", ["npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.object-sap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("npm:core-js@1.2.1/modules/$.to-object");
  require("npm:core-js@1.2.1/modules/$.object-sap")('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.object.get-own-property-names", ["npm:core-js@1.2.1/modules/$.object-sap", "npm:core-js@1.2.1/modules/$.get-names"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.object-sap")('getOwnPropertyNames', function() {
    return require("npm:core-js@1.2.1/modules/$.get-names").get;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.function.name", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.support-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setDesc = require("npm:core-js@1.2.1/modules/$").setDesc,
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      FProto = Function.prototype,
      nameRE = /^\s*function ([^ (]*)/,
      NAME = 'name';
  NAME in FProto || require("npm:core-js@1.2.1/modules/$.support-desc") && setDesc(FProto, NAME, {
    configurable: true,
    get: function() {
      var match = ('' + this).match(nameRE),
          name = match ? match[1] : '';
      has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
      return name;
    }
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.function.has-instance", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      HAS_INSTANCE = require("npm:core-js@1.2.1/modules/$.wks")('hasInstance'),
      FunctionProto = Function.prototype;
  if (!(HAS_INSTANCE in FunctionProto))
    $.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O) {
        if (typeof this != 'function' || !isObject(O))
          return false;
        if (!isObject(this.prototype))
          return O instanceof this;
        while (O = $.getProto(O))
          if (this.prototype === O)
            return true;
        return false;
      }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.constructor", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.cof", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      global = require("npm:core-js@1.2.1/modules/$.global"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      cof = require("npm:core-js@1.2.1/modules/$.cof"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      fails = require("npm:core-js@1.2.1/modules/$.fails"),
      NUMBER = 'Number',
      $Number = global[NUMBER],
      Base = $Number,
      proto = $Number.prototype,
      BROKEN_COF = cof($.create(proto)) == NUMBER;
  var toPrimitive = function(it) {
    var fn,
        val;
    if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    throw TypeError("Can't convert object to number");
  };
  var toNumber = function(it) {
    if (isObject(it))
      it = toPrimitive(it);
    if (typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48) {
      var binary = false;
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          binary = true;
        case 79:
        case 111:
          return parseInt(it.slice(2), binary ? 2 : 8);
      }
    }
    return +it;
  };
  if (!($Number('0o1') && $Number('0b1'))) {
    $Number = function Number(it) {
      var that = this;
      return that instanceof $Number && (BROKEN_COF ? fails(function() {
        proto.valueOf.call(that);
      }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
    };
    $.each.call(require("npm:core-js@1.2.1/modules/$.support-desc") ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function(key) {
      if (has(Base, key) && !has($Number, key)) {
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    });
    $Number.prototype = proto;
    proto.constructor = $Number;
    require("npm:core-js@1.2.1/modules/$.redef")(global, NUMBER, $Number);
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.epsilon", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {EPSILON: Math.pow(2, -52)});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.is-finite", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      _isFinite = require("npm:core-js@1.2.1/modules/$.global").isFinite;
  $def($def.S, 'Number', {isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.is-integer", ["npm:core-js@1.2.1/modules/$.is-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      floor = Math.floor;
  module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.is-integer", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.is-integer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {isInteger: require("npm:core-js@1.2.1/modules/$.is-integer")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.is-nan", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.is-safe-integer", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.is-integer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      isInteger = require("npm:core-js@1.2.1/modules/$.is-integer"),
      abs = Math.abs;
  $def($def.S, 'Number', {isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.max-safe-integer", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.min-safe-integer", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.parse-float", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {parseFloat: parseFloat});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.number.parse-int", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Number', {parseInt: parseInt});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.log1p", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.acosh", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.log1p"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      log1p = require("npm:core-js@1.2.1/modules/$.log1p"),
      sqrt = Math.sqrt,
      $acosh = Math.acosh;
  $def($def.S + $def.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.asinh", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }
  $def($def.S, 'Math', {asinh: asinh});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.atanh", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.sign", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.sign || function sign(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.cbrt", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.sign"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      sign = require("npm:core-js@1.2.1/modules/$.sign");
  $def($def.S, 'Math', {cbrt: function cbrt(x) {
      return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.clz32", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.cosh", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      exp = Math.exp;
  $def($def.S, 'Math', {cosh: function cosh(x) {
      return (exp(x = +x) + exp(-x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.expm1", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.expm1 || function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.expm1", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.expm1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {expm1: require("npm:core-js@1.2.1/modules/$.expm1")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.fround", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.sign"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      sign = require("npm:core-js@1.2.1/modules/$.sign"),
      pow = Math.pow,
      EPSILON = pow(2, -52),
      EPSILON32 = pow(2, -23),
      MAX32 = pow(2, 127) * (2 - EPSILON32),
      MIN32 = pow(2, -126);
  var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };
  $def($def.S, 'Math', {fround: function fround(x) {
      var $abs = Math.abs(x),
          $sign = sign(x),
          a,
          result;
      if ($abs < MIN32)
        return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result)
        return $sign * Infinity;
      return $sign * result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.hypot", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      abs = Math.abs;
  $def($def.S, 'Math', {hypot: function hypot(value1, value2) {
      var sum = 0,
          i = 0,
          len = arguments.length,
          larg = 0,
          arg,
          div;
      while (i < len) {
        arg = abs(arguments[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else
          sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.imul", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
    return Math.imul(0xffffffff, 5) != -5;
  }), 'Math', {imul: function imul(x, y) {
      var UINT16 = 0xffff,
          xn = +x,
          yn = +y,
          xl = UINT16 & xn,
          yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.log10", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {log10: function log10(x) {
      return Math.log(x) / Math.LN10;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.log1p", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.log1p"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {log1p: require("npm:core-js@1.2.1/modules/$.log1p")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.log2", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.sign", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.sign"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {sign: require("npm:core-js@1.2.1/modules/$.sign")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.sinh", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.expm1", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      expm1 = require("npm:core-js@1.2.1/modules/$.expm1"),
      exp = Math.exp;
  $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {sinh: function sinh(x) {
      return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.tanh", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.expm1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      expm1 = require("npm:core-js@1.2.1/modules/$.expm1"),
      exp = Math.exp;
  $def($def.S, 'Math', {tanh: function tanh(x) {
      var a = expm1(x = +x),
          b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.math.trunc", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Math', {trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.from-code-point", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.to-index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      toIndex = require("npm:core-js@1.2.1/modules/$.to-index"),
      fromCharCode = String.fromCharCode,
      $fromCodePoint = String.fromCodePoint;
  $def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {fromCodePoint: function fromCodePoint(x) {
      var res = [],
          len = arguments.length,
          i = 0,
          code;
      while (len > i) {
        code = +arguments[i++];
        if (toIndex(code, 0x10ffff) !== code)
          throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.raw", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.to-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length");
  $def($def.S, 'String', {raw: function raw(callSite) {
      var tpl = toIObject(callSite.raw),
          len = toLength(tpl.length),
          sln = arguments.length,
          res = [],
          i = 0;
      while (len > i) {
        res.push(String(tpl[i++]));
        if (i < sln)
          res.push(String(arguments[i]));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.string-trim", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.defined", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var trim = function(string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1)
      string = string.replace(ltrim, '');
    if (TYPE & 2)
      string = string.replace(rtrim, '');
    return string;
  };
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      defined = require("npm:core-js@1.2.1/modules/$.defined"),
      spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
      space = '[' + spaces + ']',
      non = '\u200b\u0085',
      ltrim = RegExp('^' + space + space + '*'),
      rtrim = RegExp(space + space + '*$');
  module.exports = function(KEY, exec) {
    var exp = {};
    exp[KEY] = exec(trim);
    $def($def.P + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
      return !!spaces[KEY]() || non[KEY]() != non;
    }), 'String', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.trim", ["npm:core-js@1.2.1/modules/$.string-trim"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  require("npm:core-js@1.2.1/modules/$.string-trim")('trim', function($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.string-at", ["npm:core-js@1.2.1/modules/$.to-integer", "npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = require("npm:core-js@1.2.1/modules/$.to-integer"),
      defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iterators", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iter-create", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.tag"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      IteratorPrototype = {};
  require("npm:core-js@1.2.1/modules/$.hide")(IteratorPrototype, require("npm:core-js@1.2.1/modules/$.wks")('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: require("npm:core-js@1.2.1/modules/$.property-desc")(1, next)});
    require("npm:core-js@1.2.1/modules/$.tag")(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iter-define", ["npm:core-js@1.2.1/modules/$.library", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.redef", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.iterators", "npm:core-js@1.2.1/modules/$.iter-create", "npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.tag"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var LIBRARY = require("npm:core-js@1.2.1/modules/$.library"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      $redef = require("npm:core-js@1.2.1/modules/$.redef"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      SYMBOL_ITERATOR = require("npm:core-js@1.2.1/modules/$.wks")('iterator'),
      Iterators = require("npm:core-js@1.2.1/modules/$.iterators"),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    require("npm:core-js@1.2.1/modules/$.iter-create")(Constructor, NAME, next);
    var createMethod = function(kind) {
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = require("npm:core-js@1.2.1/modules/$").getProto(_default.call(new Base));
      require("npm:core-js@1.2.1/modules/$.tag")(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
    }
    if (!LIBRARY || FORCE)
      hide(proto, SYMBOL_ITERATOR, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        keys: IS_SET ? _default : createMethod(KEYS),
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.iterator", ["npm:core-js@1.2.1/modules/$.string-at", "npm:core-js@1.2.1/modules/$.iter-define"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $at = require("npm:core-js@1.2.1/modules/$.string-at")(true);
  require("npm:core-js@1.2.1/modules/$.iter-define")(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.code-point-at", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-at"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $at = require("npm:core-js@1.2.1/modules/$.string-at")(false);
  $def($def.P, 'String', {codePointAt: function codePointAt(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.is-regexp", ["npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.cof", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      cof = require("npm:core-js@1.2.1/modules/$.cof"),
      MATCH = require("npm:core-js@1.2.1/modules/$.wks")('match');
  module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.string-context", ["npm:core-js@1.2.1/modules/$.is-regexp", "npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isRegExp = require("npm:core-js@1.2.1/modules/$.is-regexp"),
      defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString))
      throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.fails-is-regexp", ["npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[require("npm:core-js@1.2.1/modules/$.wks")('match')] = false;
        return !'/./'[KEY](re);
      } catch (e) {}
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.ends-with", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.string-context", "npm:core-js@1.2.1/modules/$.fails-is-regexp"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      context = require("npm:core-js@1.2.1/modules/$.string-context"),
      ENDS_WITH = 'endsWith',
      $endsWith = ''[ENDS_WITH];
  $def($def.P + $def.F * require("npm:core-js@1.2.1/modules/$.fails-is-regexp")(ENDS_WITH), 'String', {endsWith: function endsWith(searchString) {
      var that = context(this, searchString, ENDS_WITH),
          endPosition = arguments[1],
          len = toLength(that.length),
          end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
          search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.includes", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-context", "npm:core-js@1.2.1/modules/$.fails-is-regexp"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      context = require("npm:core-js@1.2.1/modules/$.string-context"),
      INCLUDES = 'includes';
  $def($def.P + $def.F * require("npm:core-js@1.2.1/modules/$.fails-is-regexp")(INCLUDES), 'String', {includes: function includes(searchString) {
      return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments[1]);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.string-repeat", ["npm:core-js@1.2.1/modules/$.to-integer", "npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var toInteger = require("npm:core-js@1.2.1/modules/$.to-integer"),
      defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function repeat(count) {
    var str = String(defined(this)),
        res = '',
        n = toInteger(count);
    if (n < 0 || n == Infinity)
      throw RangeError("Count can't be negative");
    for (; n > 0; (n >>>= 1) && (str += str))
      if (n & 1)
        res += str;
    return res;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.repeat", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-repeat"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.P, 'String', {repeat: require("npm:core-js@1.2.1/modules/$.string-repeat")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.string.starts-with", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.string-context", "npm:core-js@1.2.1/modules/$.fails-is-regexp"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      context = require("npm:core-js@1.2.1/modules/$.string-context"),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];
  $def($def.P + $def.F * require("npm:core-js@1.2.1/modules/$.fails-is-regexp")(STARTS_WITH), 'String', {startsWith: function startsWith(searchString) {
      var that = context(this, searchString, STARTS_WITH),
          index = toLength(Math.min(arguments[1], that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iter-call", ["npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.is-array-iter", ["npm:core-js@1.2.1/modules/$.iterators", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = require("npm:core-js@1.2.1/modules/$.iterators"),
      ITERATOR = require("npm:core-js@1.2.1/modules/$.wks")('iterator');
  module.exports = function(it) {
    return (Iterators.Array || Array.prototype[ITERATOR]) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/core.get-iterator-method", ["npm:core-js@1.2.1/modules/$.classof", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.iterators", "npm:core-js@1.2.1/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = require("npm:core-js@1.2.1/modules/$.classof"),
      ITERATOR = require("npm:core-js@1.2.1/modules/$.wks")('iterator'),
      Iterators = require("npm:core-js@1.2.1/modules/$.iterators");
  module.exports = require("npm:core-js@1.2.1/modules/$.core").getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iter-detect", ["npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = require("npm:core-js@1.2.1/modules/$.wks")('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec) {
    if (!SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.from", ["npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.iter-call", "npm:core-js@1.2.1/modules/$.is-array-iter", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/core.get-iterator-method", "npm:core-js@1.2.1/modules/$.iter-detect"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      call = require("npm:core-js@1.2.1/modules/$.iter-call"),
      isArrayIter = require("npm:core-js@1.2.1/modules/$.is-array-iter"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      getIterFn = require("npm:core-js@1.2.1/modules/core.get-iterator-method");
  $def($def.S + $def.F * !require("npm:core-js@1.2.1/modules/$.iter-detect")(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          mapfn = arguments[1],
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, arguments[2], 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.of", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
    function F() {}
    return !(Array.of.call(F) instanceof F);
  }), 'Array', {of: function of() {
      var index = 0,
          length = arguments.length,
          result = new (typeof this == 'function' ? this : Array)(length);
      while (length > index)
        result[index] = arguments[index++];
      result.length = length;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.unscope", ["npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.hide"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNSCOPABLES = require("npm:core-js@1.2.1/modules/$.wks")('unscopables');
  if ([][UNSCOPABLES] == undefined)
    require("npm:core-js@1.2.1/modules/$.hide")(Array.prototype, UNSCOPABLES, {});
  module.exports = function(key) {
    [][UNSCOPABLES][key] = true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.iter-step", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.iterator", ["npm:core-js@1.2.1/modules/$.unscope", "npm:core-js@1.2.1/modules/$.iter-step", "npm:core-js@1.2.1/modules/$.iterators", "npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.iter-define"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var setUnscope = require("npm:core-js@1.2.1/modules/$.unscope"),
      step = require("npm:core-js@1.2.1/modules/$.iter-step"),
      Iterators = require("npm:core-js@1.2.1/modules/$.iterators"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject");
  require("npm:core-js@1.2.1/modules/$.iter-define")(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.species", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.support-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      SPECIES = require("npm:core-js@1.2.1/modules/$.wks")('species');
  module.exports = function(C) {
    if (require("npm:core-js@1.2.1/modules/$.support-desc") && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.species", ["npm:core-js@1.2.1/modules/$.species"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.species")(Array);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.array-copy-within", ["npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.to-index", "npm:core-js@1.2.1/modules/$.to-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      toIndex = require("npm:core-js@1.2.1/modules/$.to-index"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length");
  module.exports = [].copyWithin || function copyWithin(target, start) {
    var O = toObject(this),
        len = toLength(O.length),
        to = toIndex(target, len),
        from = toIndex(start, len),
        end = arguments[2],
        count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
        inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O)
        O[to] = O[from];
      else
        delete O[to];
      to += inc;
      from += inc;
    }
    return O;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.copy-within", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.array-copy-within", "npm:core-js@1.2.1/modules/$.unscope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.P, 'Array', {copyWithin: require("npm:core-js@1.2.1/modules/$.array-copy-within")});
  require("npm:core-js@1.2.1/modules/$.unscope")('copyWithin');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.array-fill", ["npm:core-js@1.2.1/modules/$.to-object", "npm:core-js@1.2.1/modules/$.to-index", "npm:core-js@1.2.1/modules/$.to-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var toObject = require("npm:core-js@1.2.1/modules/$.to-object"),
      toIndex = require("npm:core-js@1.2.1/modules/$.to-index"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length");
  module.exports = [].fill || function fill(value) {
    var O = toObject(this, true),
        length = toLength(O.length),
        index = toIndex(arguments[1], length),
        end = arguments[2],
        endPos = end === undefined ? length : toIndex(end, length);
    while (endPos > index)
      O[index++] = value;
    return O;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.fill", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.array-fill", "npm:core-js@1.2.1/modules/$.unscope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.P, 'Array', {fill: require("npm:core-js@1.2.1/modules/$.array-fill")});
  require("npm:core-js@1.2.1/modules/$.unscope")('fill');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.find", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.array-methods", "npm:core-js@1.2.1/modules/$.unscope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var KEY = 'find',
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      forced = true,
      $find = require("npm:core-js@1.2.1/modules/$.array-methods")(5);
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $def($def.P + $def.F * forced, 'Array', {find: function find(callbackfn) {
      return $find(this, callbackfn, arguments[1]);
    }});
  require("npm:core-js@1.2.1/modules/$.unscope")(KEY);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.array.find-index", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.array-methods", "npm:core-js@1.2.1/modules/$.unscope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var KEY = 'findIndex',
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      forced = true,
      $find = require("npm:core-js@1.2.1/modules/$.array-methods")(6);
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $def($def.P + $def.F * forced, 'Array', {findIndex: function findIndex(callbackfn) {
      return $find(this, callbackfn, arguments[1]);
    }});
  require("npm:core-js@1.2.1/modules/$.unscope")(KEY);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.flags", ["npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  module.exports = function() {
    var that = anObject(this),
        result = '';
    if (that.global)
      result += 'g';
    if (that.ignoreCase)
      result += 'i';
    if (that.multiline)
      result += 'm';
    if (that.unicode)
      result += 'u';
    if (that.sticky)
      result += 'y';
    return result;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.constructor", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.is-regexp", "npm:core-js@1.2.1/modules/$.flags", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.redef", "npm:core-js@1.2.1/modules/$.species"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      global = require("npm:core-js@1.2.1/modules/$.global"),
      isRegExp = require("npm:core-js@1.2.1/modules/$.is-regexp"),
      $flags = require("npm:core-js@1.2.1/modules/$.flags"),
      $RegExp = global.RegExp,
      Base = $RegExp,
      proto = $RegExp.prototype,
      re1 = /a/g,
      re2 = /a/g,
      CORRECT_NEW = new $RegExp(re1) !== re1;
  if (require("npm:core-js@1.2.1/modules/$.support-desc") && (!CORRECT_NEW || require("npm:core-js@1.2.1/modules/$.fails")(function() {
    re2[require("npm:core-js@1.2.1/modules/$.wks")('match')] = false;
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var piRE = isRegExp(p),
          fiU = f === undefined;
      return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p : CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
    };
    $.each.call($.getNames(Base), function(key) {
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function() {
          return Base[key];
        },
        set: function(it) {
          Base[key] = it;
        }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require("npm:core-js@1.2.1/modules/$.redef")(global, 'RegExp', $RegExp);
  }
  require("npm:core-js@1.2.1/modules/$.species")($RegExp);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.flags", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.flags"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$");
  if (require("npm:core-js@1.2.1/modules/$.support-desc") && /./g.flags != 'g')
    $.setDesc(RegExp.prototype, 'flags', {
      configurable: true,
      get: require("npm:core-js@1.2.1/modules/$.flags")
    });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.fix-re-wks", ["npm:core-js@1.2.1/modules/$.defined", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.redef", "npm:core-js@1.2.1/modules/$.hide"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function(KEY, length, exec) {
    var defined = require("npm:core-js@1.2.1/modules/$.defined"),
        SYMBOL = require("npm:core-js@1.2.1/modules/$.wks")(KEY),
        original = ''[KEY];
    if (require("npm:core-js@1.2.1/modules/$.fails")(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ''[KEY](O) != 7;
    })) {
      require("npm:core-js@1.2.1/modules/$.redef")(String.prototype, KEY, exec(defined, SYMBOL, original));
      require("npm:core-js@1.2.1/modules/$.hide")(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
        return original.call(string, this, arg);
      } : function(string) {
        return original.call(string, this);
      });
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.match", ["npm:core-js@1.2.1/modules/$.fix-re-wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.fix-re-wks")('match', 1, function(defined, MATCH) {
    return function match(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.replace", ["npm:core-js@1.2.1/modules/$.fix-re-wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.fix-re-wks")('replace', 2, function(defined, REPLACE, $replace) {
    return function replace(searchValue, replaceValue) {
      'use strict';
      var O = defined(this),
          fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.search", ["npm:core-js@1.2.1/modules/$.fix-re-wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.fix-re-wks")('search', 1, function(defined, SEARCH) {
    return function search(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.regexp.split", ["npm:core-js@1.2.1/modules/$.fix-re-wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/$.fix-re-wks")('split', 2, function(defined, SPLIT, $split) {
    return function split(separator, limit) {
      'use strict';
      var O = defined(this),
          fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.strict-new", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.for-of", ["npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.iter-call", "npm:core-js@1.2.1/modules/$.is-array-iter", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/core.get-iterator-method"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
      call = require("npm:core-js@1.2.1/modules/$.iter-call"),
      isArrayIter = require("npm:core-js@1.2.1/modules/$.is-array-iter"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      getIterFn = require("npm:core-js@1.2.1/modules/core.get-iterator-method");
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.task", ["npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.invoke", "npm:core-js@1.2.1/modules/$.html", "npm:core-js@1.2.1/modules/$.dom-create", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.cof", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
        invoke = require("npm:core-js@1.2.1/modules/$.invoke"),
        html = require("npm:core-js@1.2.1/modules/$.html"),
        cel = require("npm:core-js@1.2.1/modules/$.dom-create"),
        global = require("npm:core-js@1.2.1/modules/$.global"),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if (require("npm:core-js@1.2.1/modules/$.cof")(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.microtask", ["npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.task", "npm:core-js@1.2.1/modules/$.cof", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = require("npm:core-js@1.2.1/modules/$.global"),
        macrotask = require("npm:core-js@1.2.1/modules/$.task").set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        isNode = require("npm:core-js@1.2.1/modules/$.cof")(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        if (domain)
          domain.enter();
        head.fn.call();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.mix", ["npm:core-js@1.2.1/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $redef = require("npm:core-js@1.2.1/modules/$.redef");
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.promise", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.library", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.classof", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.a-function", "npm:core-js@1.2.1/modules/$.strict-new", "npm:core-js@1.2.1/modules/$.for-of", "npm:core-js@1.2.1/modules/$.set-proto", "npm:core-js@1.2.1/modules/$.same", "npm:core-js@1.2.1/modules/$.species", "npm:core-js@1.2.1/modules/$.wks", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.microtask", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.mix", "npm:core-js@1.2.1/modules/$.tag", "npm:core-js@1.2.1/modules/$.core", "npm:core-js@1.2.1/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = require("npm:core-js@1.2.1/modules/$"),
        LIBRARY = require("npm:core-js@1.2.1/modules/$.library"),
        global = require("npm:core-js@1.2.1/modules/$.global"),
        ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
        classof = require("npm:core-js@1.2.1/modules/$.classof"),
        $def = require("npm:core-js@1.2.1/modules/$.def"),
        isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
        anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
        aFunction = require("npm:core-js@1.2.1/modules/$.a-function"),
        strictNew = require("npm:core-js@1.2.1/modules/$.strict-new"),
        forOf = require("npm:core-js@1.2.1/modules/$.for-of"),
        setProto = require("npm:core-js@1.2.1/modules/$.set-proto").set,
        same = require("npm:core-js@1.2.1/modules/$.same"),
        species = require("npm:core-js@1.2.1/modules/$.species"),
        SPECIES = require("npm:core-js@1.2.1/modules/$.wks")('species'),
        RECORD = require("npm:core-js@1.2.1/modules/$.uid")('record'),
        asap = require("npm:core-js@1.2.1/modules/$.microtask"),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && require("npm:core-js@1.2.1/modules/$.support-desc")) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var isPromise = function(it) {
      return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
    };
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(react) {
          var cb = ok ? react.ok : react.fail,
              ret,
              then;
          try {
            if (cb) {
              if (!ok)
                record.h = true;
              ret = cb === true ? value : cb(value);
              if (ret === react.P) {
                react.rej(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(ret)) {
                then.call(ret, react.res, react.rej);
              } else
                react.res(ret);
            } else
              react.rej(value);
          } catch (err) {
            react.rej(err);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!useNative) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        this[RECORD] = record;
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      require("npm:core-js@1.2.1/modules/$.mix")(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var S = anObject(anObject(this).constructor)[SPECIES];
          var react = {
            ok: typeof onFulfilled == 'function' ? onFulfilled : true,
            fail: typeof onRejected == 'function' ? onRejected : false
          };
          var promise = react.P = new (S != undefined ? S : P)(function(res, rej) {
            react.res = res;
            react.rej = rej;
          });
          aFunction(react.res);
          aFunction(react.rej);
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    require("npm:core-js@1.2.1/modules/$.tag")(P, PROMISE);
    species(P);
    species(Wrapper = require("npm:core-js@1.2.1/modules/$.core")[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new this(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && require("npm:core-js@1.2.1/modules/$.iter-detect")(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.collection-strong", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.ctx", "npm:core-js@1.2.1/modules/$.species", "npm:core-js@1.2.1/modules/$.strict-new", "npm:core-js@1.2.1/modules/$.defined", "npm:core-js@1.2.1/modules/$.for-of", "npm:core-js@1.2.1/modules/$.iter-step", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.support-desc", "npm:core-js@1.2.1/modules/$.mix", "npm:core-js@1.2.1/modules/$.iter-define", "npm:core-js@1.2.1/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      ctx = require("npm:core-js@1.2.1/modules/$.ctx"),
      species = require("npm:core-js@1.2.1/modules/$.species"),
      strictNew = require("npm:core-js@1.2.1/modules/$.strict-new"),
      defined = require("npm:core-js@1.2.1/modules/$.defined"),
      forOf = require("npm:core-js@1.2.1/modules/$.for-of"),
      step = require("npm:core-js@1.2.1/modules/$.iter-step"),
      ID = require("npm:core-js@1.2.1/modules/$.uid")('id'),
      $has = require("npm:core-js@1.2.1/modules/$.has"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      isExtensible = Object.isExtensible || isObject,
      SUPPORT_DESC = require("npm:core-js@1.2.1/modules/$.support-desc"),
      SIZE = SUPPORT_DESC ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      require("npm:core-js@1.2.1/modules/$.mix")(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments[1], 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (SUPPORT_DESC)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      require("npm:core-js@1.2.1/modules/$.iter-define")(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      species(C);
      species(require("npm:core-js@1.2.1/modules/$.core")[NAME]);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.collection", ["npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.for-of", "npm:core-js@1.2.1/modules/$.strict-new", "npm:core-js@1.2.1/modules/$.redef", "npm:core-js@1.2.1/modules/$.fails", "npm:core-js@1.2.1/modules/$.mix", "npm:core-js@1.2.1/modules/$.iter-detect", "npm:core-js@1.2.1/modules/$.tag"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      forOf = require("npm:core-js@1.2.1/modules/$.for-of"),
      strictNew = require("npm:core-js@1.2.1/modules/$.strict-new");
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    var fixMethod = function(KEY) {
      var fn = proto[KEY];
      require("npm:core-js@1.2.1/modules/$.redef")(proto, KEY, KEY == 'delete' ? function(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !require("npm:core-js@1.2.1/modules/$.fails")(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      require("npm:core-js@1.2.1/modules/$.mix")(C.prototype, methods);
    } else {
      var inst = new C,
          chain = inst[ADDER](IS_WEAK ? {} : -0, 1),
          buggyZero;
      if (!require("npm:core-js@1.2.1/modules/$.iter-detect")(function(iter) {
        new C(iter);
      })) {
        C = wrapper(function(target, iterable) {
          strictNew(target, C, NAME);
          var that = new Base;
          if (iterable != undefined)
            forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      IS_WEAK || inst.forEach(function(val, key) {
        buggyZero = 1 / key === -Infinity;
      });
      if (buggyZero) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (buggyZero || chain !== inst)
        fixMethod(ADDER);
      if (IS_WEAK && proto.clear)
        delete proto.clear;
    }
    require("npm:core-js@1.2.1/modules/$.tag")(C, NAME);
    O[NAME] = C;
    $def($def.G + $def.W + $def.F * (C != Base), O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.map", ["npm:core-js@1.2.1/modules/$.collection-strong", "npm:core-js@1.2.1/modules/$.collection"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var strong = require("npm:core-js@1.2.1/modules/$.collection-strong");
  require("npm:core-js@1.2.1/modules/$.collection")('Map', function(get) {
    return function Map() {
      return get(this, arguments[0]);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.set", ["npm:core-js@1.2.1/modules/$.collection-strong", "npm:core-js@1.2.1/modules/$.collection"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var strong = require("npm:core-js@1.2.1/modules/$.collection-strong");
  require("npm:core-js@1.2.1/modules/$.collection")('Set', function(get) {
    return function Set() {
      return get(this, arguments[0]);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.collection-weak", ["npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.strict-new", "npm:core-js@1.2.1/modules/$.for-of", "npm:core-js@1.2.1/modules/$.array-methods", "npm:core-js@1.2.1/modules/$.uid", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.mix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hide = require("npm:core-js@1.2.1/modules/$.hide"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      strictNew = require("npm:core-js@1.2.1/modules/$.strict-new"),
      forOf = require("npm:core-js@1.2.1/modules/$.for-of"),
      method = require("npm:core-js@1.2.1/modules/$.array-methods"),
      WEAK = require("npm:core-js@1.2.1/modules/$.uid")('weak'),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      $has = require("npm:core-js@1.2.1/modules/$.has"),
      isExtensible = Object.isExtensible || isObject,
      find = method(5),
      findIndex = method(6),
      id = 0;
  var frozenStore = function(that) {
    return that._l || (that._l = new FrozenStore);
  };
  var FrozenStore = function() {
    this.a = [];
  };
  var findFrozen = function(store, key) {
    return find(store.a, function(it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function(key) {
      var entry = findFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function(key) {
      return !!findFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([key, value]);
    },
    'delete': function(key) {
      var index = findIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      require("npm:core-js@1.2.1/modules/$.mix")(C.prototype, {
        'delete': function(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.weak-map", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.collection-weak", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.collection", "npm:core-js@1.2.1/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/modules/$"),
      weak = require("npm:core-js@1.2.1/modules/$.collection-weak"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = require("npm:core-js@1.2.1/modules/$.collection")('WeakMap', function(get) {
    return function WeakMap() {
      return get(this, arguments[0]);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key))
          return frozenStore(this).get(key);
        if (has(key, WEAK))
          return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function(key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      require("npm:core-js@1.2.1/modules/$.redef")(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.weak-set", ["npm:core-js@1.2.1/modules/$.collection-weak", "npm:core-js@1.2.1/modules/$.collection"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var weak = require("npm:core-js@1.2.1/modules/$.collection-weak");
  require("npm:core-js@1.2.1/modules/$.collection")('WeakSet', function(get) {
    return function WeakSet() {
      return get(this, arguments[0]);
    };
  }, {add: function add(value) {
      return weak.def(this, value, true);
    }}, weak, false, true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.apply", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      _apply = Function.apply;
  $def($def.S, 'Reflect', {apply: function apply(target, thisArgument, argumentsList) {
      return _apply.call(target, thisArgument, argumentsList);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.construct", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.a-function", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.core", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      aFunction = require("npm:core-js@1.2.1/modules/$.a-function"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      bind = Function.bind || require("npm:core-js@1.2.1/modules/$.core").Function.prototype.bind;
  $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
    function F() {}
    return !(Reflect.construct(function() {}, [], F) instanceof F);
  }), 'Reflect', {construct: function construct(Target, args) {
      aFunction(Target);
      var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
      if (Target == newTarget) {
        if (args != undefined)
          switch (anObject(args).length) {
            case 0:
              return new Target;
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        var $args = [null];
        $args.push.apply($args, args);
        return new (bind.apply(Target, $args));
      }
      var proto = newTarget.prototype,
          instance = $.create(isObject(proto) ? proto : Object.prototype),
          result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.define-property", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  $def($def.S + $def.F * require("npm:core-js@1.2.1/modules/$.fails")(function() {
    Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
  }), 'Reflect', {defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      try {
        $.setDesc(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.delete-property", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      getDesc = require("npm:core-js@1.2.1/modules/$").getDesc,
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  $def($def.S, 'Reflect', {deleteProperty: function deleteProperty(target, propertyKey) {
      var desc = getDesc(anObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.enumerate", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.iter-create"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  var Enumerate = function(iterated) {
    this._t = anObject(iterated);
    this._i = 0;
    var keys = this._k = [],
        key;
    for (key in iterated)
      keys.push(key);
  };
  require("npm:core-js@1.2.1/modules/$.iter-create")(Enumerate, 'Object', function() {
    var that = this,
        keys = that._k,
        key;
    do {
      if (that._i >= keys.length)
        return {
          value: undefined,
          done: true
        };
    } while (!((key = keys[that._i++]) in that._t));
    return {
      value: key,
      done: false
    };
  });
  $def($def.S, 'Reflect', {enumerate: function enumerate(target) {
      return new Enumerate(target);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.get", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.is-object", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  function get(target, propertyKey) {
    var receiver = arguments.length < 3 ? target : arguments[2],
        desc,
        proto;
    if (anObject(target) === receiver)
      return target[propertyKey];
    if (desc = $.getDesc(target, propertyKey))
      return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = $.getProto(target)))
      return get(proto, propertyKey, receiver);
  }
  $def($def.S, 'Reflect', {get: get});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.get-own-property-descriptor", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  $def($def.S, 'Reflect', {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return $.getDesc(anObject(target), propertyKey);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.get-prototype-of", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      getProto = require("npm:core-js@1.2.1/modules/$").getProto,
      anObject = require("npm:core-js@1.2.1/modules/$.an-object");
  $def($def.S, 'Reflect', {getPrototypeOf: function getPrototypeOf(target) {
      return getProto(anObject(target));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.has", ["npm:core-js@1.2.1/modules/$.def"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Reflect', {has: function has(target, propertyKey) {
      return propertyKey in target;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.is-extensible", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      $isExtensible = Object.isExtensible;
  $def($def.S, 'Reflect', {isExtensible: function isExtensible(target) {
      anObject(target);
      return $isExtensible ? $isExtensible(target) : true;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.own-keys", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      Reflect = require("npm:core-js@1.2.1/modules/$.global").Reflect;
  module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
    var keys = $.getNames(anObject(it)),
        getSymbols = $.getSymbols;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.own-keys", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.own-keys"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.S, 'Reflect', {ownKeys: require("npm:core-js@1.2.1/modules/$.own-keys")});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.prevent-extensions", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      $preventExtensions = Object.preventExtensions;
  $def($def.S, 'Reflect', {preventExtensions: function preventExtensions(target) {
      anObject(target);
      try {
        if ($preventExtensions)
          $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.set", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.property-desc", "npm:core-js@1.2.1/modules/$.an-object", "npm:core-js@1.2.1/modules/$.is-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc"),
      anObject = require("npm:core-js@1.2.1/modules/$.an-object"),
      isObject = require("npm:core-js@1.2.1/modules/$.is-object");
  function set(target, propertyKey, V) {
    var receiver = arguments.length < 4 ? target : arguments[3],
        ownDesc = $.getDesc(anObject(target), propertyKey),
        existingDescriptor,
        proto;
    if (!ownDesc) {
      if (isObject(proto = $.getProto(target))) {
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !isObject(receiver))
        return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
  $def($def.S, 'Reflect', {set: set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es6.reflect.set-prototype-of", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.set-proto"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      setProto = require("npm:core-js@1.2.1/modules/$.set-proto");
  if (setProto)
    $def($def.S, 'Reflect', {setPrototypeOf: function setPrototypeOf(target, proto) {
        setProto.check(target, proto);
        try {
          setProto.set(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.array.includes", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.array-includes", "npm:core-js@1.2.1/modules/$.unscope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $includes = require("npm:core-js@1.2.1/modules/$.array-includes")(true);
  $def($def.P, 'Array', {includes: function includes(el) {
      return $includes(this, el, arguments[1]);
    }});
  require("npm:core-js@1.2.1/modules/$.unscope")('includes');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.string.at", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-at"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $at = require("npm:core-js@1.2.1/modules/$.string-at")(true);
  $def($def.P, 'String', {at: function at(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.string-pad", ["npm:core-js@1.2.1/modules/$.to-length", "npm:core-js@1.2.1/modules/$.string-repeat", "npm:core-js@1.2.1/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toLength = require("npm:core-js@1.2.1/modules/$.to-length"),
      repeat = require("npm:core-js@1.2.1/modules/$.string-repeat"),
      defined = require("npm:core-js@1.2.1/modules/$.defined");
  module.exports = function(that, maxLength, fillString, left) {
    var S = String(defined(that)),
        stringLength = S.length,
        fillStr = fillString === undefined ? ' ' : String(fillString),
        intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength)
      return S;
    if (fillStr == '')
      fillStr = ' ';
    var fillLen = intMaxLength - stringLength,
        stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen)
      stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.string.pad-left", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-pad"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $pad = require("npm:core-js@1.2.1/modules/$.string-pad");
  $def($def.P, 'String', {padLeft: function padLeft(maxLength) {
      return $pad(this, maxLength, arguments[1], true);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.string.pad-right", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.string-pad"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $pad = require("npm:core-js@1.2.1/modules/$.string-pad");
  $def($def.P, 'String', {padRight: function padRight(maxLength) {
      return $pad(this, maxLength, arguments[1], false);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.string.trim-left", ["npm:core-js@1.2.1/modules/$.string-trim"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  require("npm:core-js@1.2.1/modules/$.string-trim")('trimLeft', function($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.string.trim-right", ["npm:core-js@1.2.1/modules/$.string-trim"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  require("npm:core-js@1.2.1/modules/$.string-trim")('trimRight', function($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.replacer", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(regExp, replace) {
    var replacer = replace === Object(replace) ? function(part) {
      return replace[part];
    } : replace;
    return function(it) {
      return String(it).replace(regExp, replacer);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.regexp.escape", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.replacer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $re = require("npm:core-js@1.2.1/modules/$.replacer")(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  $def($def.S, 'RegExp', {escape: function escape(it) {
      return $re(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.object.get-own-property-descriptors", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.own-keys", "npm:core-js@1.2.1/modules/$.to-iobject", "npm:core-js@1.2.1/modules/$.property-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      ownKeys = require("npm:core-js@1.2.1/modules/$.own-keys"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject"),
      createDesc = require("npm:core-js@1.2.1/modules/$.property-desc");
  $def($def.S, 'Object', {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIObject(object),
          setDesc = $.setDesc,
          getDesc = $.getDesc,
          keys = ownKeys(O),
          result = {},
          i = 0,
          key,
          D;
      while (keys.length > i) {
        D = getDesc(O, key = keys[i++]);
        if (key in result)
          setDesc(result, key, createDesc(0, D));
        else
          result[key] = D;
      }
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.object-to-array", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.has", "npm:core-js@1.2.1/modules/$.to-iobject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      has = require("npm:core-js@1.2.1/modules/$.has"),
      toIObject = require("npm:core-js@1.2.1/modules/$.to-iobject");
  module.exports = function(isEntries) {
    return function(it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i)
        has(O, key = keys[i++]) && result.push(isEntries ? [key, O[key]] : O[key]);
      return result;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.object.values", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.object-to-array"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $values = require("npm:core-js@1.2.1/modules/$.object-to-array")(false);
  $def($def.S, 'Object', {values: function values(it) {
      return $values(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.object.entries", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.object-to-array"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $entries = require("npm:core-js@1.2.1/modules/$.object-to-array")(true);
  $def($def.S, 'Object', {entries: function entries(it) {
      return $entries(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.collection-to-json", ["npm:core-js@1.2.1/modules/$.for-of", "npm:core-js@1.2.1/modules/$.classof"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = require("npm:core-js@1.2.1/modules/$.for-of"),
      classof = require("npm:core-js@1.2.1/modules/$.classof");
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.map.to-json", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.collection-to-json"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.P, 'Map', {toJSON: require("npm:core-js@1.2.1/modules/$.collection-to-json")('Map')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/es7.set.to-json", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.collection-to-json"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def");
  $def($def.P, 'Set', {toJSON: require("npm:core-js@1.2.1/modules/$.collection-to-json")('Set')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/js.array.statics", ["npm:core-js@1.2.1/modules/$", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.core", "npm:core-js@1.2.1/modules/$.ctx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/modules/$"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      $Array = require("npm:core-js@1.2.1/modules/$.core").Array || Array,
      statics = {};
  var setStatics = function(keys, length) {
    $.each.call(keys.split(','), function(key) {
      if (length == undefined && key in $Array)
        statics[key] = $Array[key];
      else if (key in [])
        statics[key] = require("npm:core-js@1.2.1/modules/$.ctx")(Function.call, [][key], length);
    });
  };
  setStatics('pop,reverse,shift,keys,values,entries', 1);
  setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
  $def($def.S, 'Array', statics);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.path", ["npm:core-js@1.2.1/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.1/modules/$.global");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/$.partial", ["npm:core-js@1.2.1/modules/$.path", "npm:core-js@1.2.1/modules/$.invoke", "npm:core-js@1.2.1/modules/$.a-function"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var path = require("npm:core-js@1.2.1/modules/$.path"),
      invoke = require("npm:core-js@1.2.1/modules/$.invoke"),
      aFunction = require("npm:core-js@1.2.1/modules/$.a-function");
  module.exports = function() {
    var fn = aFunction(this),
        length = arguments.length,
        pargs = Array(length),
        i = 0,
        _ = path._,
        holder = false;
    while (length > i)
      if ((pargs[i] = arguments[i++]) === _)
        holder = true;
    return function() {
      var that = this,
          _length = arguments.length,
          j = 0,
          k = 0,
          args;
      if (!holder && !_length)
        return invoke(fn, pargs, that);
      args = pargs.slice();
      if (holder)
        for (; length > j; j++)
          if (args[j] === _)
            args[j] = arguments[k++];
      while (_length > k)
        args.push(arguments[k++]);
      return invoke(fn, args, that);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/web.timers", ["npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.invoke", "npm:core-js@1.2.1/modules/$.partial"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      $def = require("npm:core-js@1.2.1/modules/$.def"),
      invoke = require("npm:core-js@1.2.1/modules/$.invoke"),
      partial = require("npm:core-js@1.2.1/modules/$.partial"),
      navigator = global.navigator,
      MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
  var wrap = function(set) {
    return MSIE ? function(fn, time) {
      return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
    } : set;
  };
  $def($def.G + $def.B + $def.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/web.immediate", ["npm:core-js@1.2.1/modules/$.def", "npm:core-js@1.2.1/modules/$.task"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@1.2.1/modules/$.def"),
      $task = require("npm:core-js@1.2.1/modules/$.task");
  $def($def.G + $def.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/modules/web.dom.iterable", ["npm:core-js@1.2.1/modules/es6.array.iterator", "npm:core-js@1.2.1/modules/$.global", "npm:core-js@1.2.1/modules/$.hide", "npm:core-js@1.2.1/modules/$.iterators", "npm:core-js@1.2.1/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/es6.array.iterator");
  var global = require("npm:core-js@1.2.1/modules/$.global"),
      hide = require("npm:core-js@1.2.1/modules/$.hide"),
      Iterators = require("npm:core-js@1.2.1/modules/$.iterators"),
      ITERATOR = require("npm:core-js@1.2.1/modules/$.wks")('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NL && !(ITERATOR in NLProto))
    hide(NLProto, ITERATOR, ArrayValues);
  if (HTC && !(ITERATOR in HTCProto))
    hide(HTCProto, ITERATOR, ArrayValues);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/shim", ["npm:core-js@1.2.1/modules/es5", "npm:core-js@1.2.1/modules/es6.symbol", "npm:core-js@1.2.1/modules/es6.object.assign", "npm:core-js@1.2.1/modules/es6.object.is", "npm:core-js@1.2.1/modules/es6.object.set-prototype-of", "npm:core-js@1.2.1/modules/es6.object.to-string", "npm:core-js@1.2.1/modules/es6.object.freeze", "npm:core-js@1.2.1/modules/es6.object.seal", "npm:core-js@1.2.1/modules/es6.object.prevent-extensions", "npm:core-js@1.2.1/modules/es6.object.is-frozen", "npm:core-js@1.2.1/modules/es6.object.is-sealed", "npm:core-js@1.2.1/modules/es6.object.is-extensible", "npm:core-js@1.2.1/modules/es6.object.get-own-property-descriptor", "npm:core-js@1.2.1/modules/es6.object.get-prototype-of", "npm:core-js@1.2.1/modules/es6.object.keys", "npm:core-js@1.2.1/modules/es6.object.get-own-property-names", "npm:core-js@1.2.1/modules/es6.function.name", "npm:core-js@1.2.1/modules/es6.function.has-instance", "npm:core-js@1.2.1/modules/es6.number.constructor", "npm:core-js@1.2.1/modules/es6.number.epsilon", "npm:core-js@1.2.1/modules/es6.number.is-finite", "npm:core-js@1.2.1/modules/es6.number.is-integer", "npm:core-js@1.2.1/modules/es6.number.is-nan", "npm:core-js@1.2.1/modules/es6.number.is-safe-integer", "npm:core-js@1.2.1/modules/es6.number.max-safe-integer", "npm:core-js@1.2.1/modules/es6.number.min-safe-integer", "npm:core-js@1.2.1/modules/es6.number.parse-float", "npm:core-js@1.2.1/modules/es6.number.parse-int", "npm:core-js@1.2.1/modules/es6.math.acosh", "npm:core-js@1.2.1/modules/es6.math.asinh", "npm:core-js@1.2.1/modules/es6.math.atanh", "npm:core-js@1.2.1/modules/es6.math.cbrt", "npm:core-js@1.2.1/modules/es6.math.clz32", "npm:core-js@1.2.1/modules/es6.math.cosh", "npm:core-js@1.2.1/modules/es6.math.expm1", "npm:core-js@1.2.1/modules/es6.math.fround", "npm:core-js@1.2.1/modules/es6.math.hypot", "npm:core-js@1.2.1/modules/es6.math.imul", "npm:core-js@1.2.1/modules/es6.math.log10", "npm:core-js@1.2.1/modules/es6.math.log1p", "npm:core-js@1.2.1/modules/es6.math.log2", "npm:core-js@1.2.1/modules/es6.math.sign", "npm:core-js@1.2.1/modules/es6.math.sinh", "npm:core-js@1.2.1/modules/es6.math.tanh", "npm:core-js@1.2.1/modules/es6.math.trunc", "npm:core-js@1.2.1/modules/es6.string.from-code-point", "npm:core-js@1.2.1/modules/es6.string.raw", "npm:core-js@1.2.1/modules/es6.string.trim", "npm:core-js@1.2.1/modules/es6.string.iterator", "npm:core-js@1.2.1/modules/es6.string.code-point-at", "npm:core-js@1.2.1/modules/es6.string.ends-with", "npm:core-js@1.2.1/modules/es6.string.includes", "npm:core-js@1.2.1/modules/es6.string.repeat", "npm:core-js@1.2.1/modules/es6.string.starts-with", "npm:core-js@1.2.1/modules/es6.array.from", "npm:core-js@1.2.1/modules/es6.array.of", "npm:core-js@1.2.1/modules/es6.array.iterator", "npm:core-js@1.2.1/modules/es6.array.species", "npm:core-js@1.2.1/modules/es6.array.copy-within", "npm:core-js@1.2.1/modules/es6.array.fill", "npm:core-js@1.2.1/modules/es6.array.find", "npm:core-js@1.2.1/modules/es6.array.find-index", "npm:core-js@1.2.1/modules/es6.regexp.constructor", "npm:core-js@1.2.1/modules/es6.regexp.flags", "npm:core-js@1.2.1/modules/es6.regexp.match", "npm:core-js@1.2.1/modules/es6.regexp.replace", "npm:core-js@1.2.1/modules/es6.regexp.search", "npm:core-js@1.2.1/modules/es6.regexp.split", "npm:core-js@1.2.1/modules/es6.promise", "npm:core-js@1.2.1/modules/es6.map", "npm:core-js@1.2.1/modules/es6.set", "npm:core-js@1.2.1/modules/es6.weak-map", "npm:core-js@1.2.1/modules/es6.weak-set", "npm:core-js@1.2.1/modules/es6.reflect.apply", "npm:core-js@1.2.1/modules/es6.reflect.construct", "npm:core-js@1.2.1/modules/es6.reflect.define-property", "npm:core-js@1.2.1/modules/es6.reflect.delete-property", "npm:core-js@1.2.1/modules/es6.reflect.enumerate", "npm:core-js@1.2.1/modules/es6.reflect.get", "npm:core-js@1.2.1/modules/es6.reflect.get-own-property-descriptor", "npm:core-js@1.2.1/modules/es6.reflect.get-prototype-of", "npm:core-js@1.2.1/modules/es6.reflect.has", "npm:core-js@1.2.1/modules/es6.reflect.is-extensible", "npm:core-js@1.2.1/modules/es6.reflect.own-keys", "npm:core-js@1.2.1/modules/es6.reflect.prevent-extensions", "npm:core-js@1.2.1/modules/es6.reflect.set", "npm:core-js@1.2.1/modules/es6.reflect.set-prototype-of", "npm:core-js@1.2.1/modules/es7.array.includes", "npm:core-js@1.2.1/modules/es7.string.at", "npm:core-js@1.2.1/modules/es7.string.pad-left", "npm:core-js@1.2.1/modules/es7.string.pad-right", "npm:core-js@1.2.1/modules/es7.string.trim-left", "npm:core-js@1.2.1/modules/es7.string.trim-right", "npm:core-js@1.2.1/modules/es7.regexp.escape", "npm:core-js@1.2.1/modules/es7.object.get-own-property-descriptors", "npm:core-js@1.2.1/modules/es7.object.values", "npm:core-js@1.2.1/modules/es7.object.entries", "npm:core-js@1.2.1/modules/es7.map.to-json", "npm:core-js@1.2.1/modules/es7.set.to-json", "npm:core-js@1.2.1/modules/js.array.statics", "npm:core-js@1.2.1/modules/web.timers", "npm:core-js@1.2.1/modules/web.immediate", "npm:core-js@1.2.1/modules/web.dom.iterable", "npm:core-js@1.2.1/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/modules/es5");
  require("npm:core-js@1.2.1/modules/es6.symbol");
  require("npm:core-js@1.2.1/modules/es6.object.assign");
  require("npm:core-js@1.2.1/modules/es6.object.is");
  require("npm:core-js@1.2.1/modules/es6.object.set-prototype-of");
  require("npm:core-js@1.2.1/modules/es6.object.to-string");
  require("npm:core-js@1.2.1/modules/es6.object.freeze");
  require("npm:core-js@1.2.1/modules/es6.object.seal");
  require("npm:core-js@1.2.1/modules/es6.object.prevent-extensions");
  require("npm:core-js@1.2.1/modules/es6.object.is-frozen");
  require("npm:core-js@1.2.1/modules/es6.object.is-sealed");
  require("npm:core-js@1.2.1/modules/es6.object.is-extensible");
  require("npm:core-js@1.2.1/modules/es6.object.get-own-property-descriptor");
  require("npm:core-js@1.2.1/modules/es6.object.get-prototype-of");
  require("npm:core-js@1.2.1/modules/es6.object.keys");
  require("npm:core-js@1.2.1/modules/es6.object.get-own-property-names");
  require("npm:core-js@1.2.1/modules/es6.function.name");
  require("npm:core-js@1.2.1/modules/es6.function.has-instance");
  require("npm:core-js@1.2.1/modules/es6.number.constructor");
  require("npm:core-js@1.2.1/modules/es6.number.epsilon");
  require("npm:core-js@1.2.1/modules/es6.number.is-finite");
  require("npm:core-js@1.2.1/modules/es6.number.is-integer");
  require("npm:core-js@1.2.1/modules/es6.number.is-nan");
  require("npm:core-js@1.2.1/modules/es6.number.is-safe-integer");
  require("npm:core-js@1.2.1/modules/es6.number.max-safe-integer");
  require("npm:core-js@1.2.1/modules/es6.number.min-safe-integer");
  require("npm:core-js@1.2.1/modules/es6.number.parse-float");
  require("npm:core-js@1.2.1/modules/es6.number.parse-int");
  require("npm:core-js@1.2.1/modules/es6.math.acosh");
  require("npm:core-js@1.2.1/modules/es6.math.asinh");
  require("npm:core-js@1.2.1/modules/es6.math.atanh");
  require("npm:core-js@1.2.1/modules/es6.math.cbrt");
  require("npm:core-js@1.2.1/modules/es6.math.clz32");
  require("npm:core-js@1.2.1/modules/es6.math.cosh");
  require("npm:core-js@1.2.1/modules/es6.math.expm1");
  require("npm:core-js@1.2.1/modules/es6.math.fround");
  require("npm:core-js@1.2.1/modules/es6.math.hypot");
  require("npm:core-js@1.2.1/modules/es6.math.imul");
  require("npm:core-js@1.2.1/modules/es6.math.log10");
  require("npm:core-js@1.2.1/modules/es6.math.log1p");
  require("npm:core-js@1.2.1/modules/es6.math.log2");
  require("npm:core-js@1.2.1/modules/es6.math.sign");
  require("npm:core-js@1.2.1/modules/es6.math.sinh");
  require("npm:core-js@1.2.1/modules/es6.math.tanh");
  require("npm:core-js@1.2.1/modules/es6.math.trunc");
  require("npm:core-js@1.2.1/modules/es6.string.from-code-point");
  require("npm:core-js@1.2.1/modules/es6.string.raw");
  require("npm:core-js@1.2.1/modules/es6.string.trim");
  require("npm:core-js@1.2.1/modules/es6.string.iterator");
  require("npm:core-js@1.2.1/modules/es6.string.code-point-at");
  require("npm:core-js@1.2.1/modules/es6.string.ends-with");
  require("npm:core-js@1.2.1/modules/es6.string.includes");
  require("npm:core-js@1.2.1/modules/es6.string.repeat");
  require("npm:core-js@1.2.1/modules/es6.string.starts-with");
  require("npm:core-js@1.2.1/modules/es6.array.from");
  require("npm:core-js@1.2.1/modules/es6.array.of");
  require("npm:core-js@1.2.1/modules/es6.array.iterator");
  require("npm:core-js@1.2.1/modules/es6.array.species");
  require("npm:core-js@1.2.1/modules/es6.array.copy-within");
  require("npm:core-js@1.2.1/modules/es6.array.fill");
  require("npm:core-js@1.2.1/modules/es6.array.find");
  require("npm:core-js@1.2.1/modules/es6.array.find-index");
  require("npm:core-js@1.2.1/modules/es6.regexp.constructor");
  require("npm:core-js@1.2.1/modules/es6.regexp.flags");
  require("npm:core-js@1.2.1/modules/es6.regexp.match");
  require("npm:core-js@1.2.1/modules/es6.regexp.replace");
  require("npm:core-js@1.2.1/modules/es6.regexp.search");
  require("npm:core-js@1.2.1/modules/es6.regexp.split");
  require("npm:core-js@1.2.1/modules/es6.promise");
  require("npm:core-js@1.2.1/modules/es6.map");
  require("npm:core-js@1.2.1/modules/es6.set");
  require("npm:core-js@1.2.1/modules/es6.weak-map");
  require("npm:core-js@1.2.1/modules/es6.weak-set");
  require("npm:core-js@1.2.1/modules/es6.reflect.apply");
  require("npm:core-js@1.2.1/modules/es6.reflect.construct");
  require("npm:core-js@1.2.1/modules/es6.reflect.define-property");
  require("npm:core-js@1.2.1/modules/es6.reflect.delete-property");
  require("npm:core-js@1.2.1/modules/es6.reflect.enumerate");
  require("npm:core-js@1.2.1/modules/es6.reflect.get");
  require("npm:core-js@1.2.1/modules/es6.reflect.get-own-property-descriptor");
  require("npm:core-js@1.2.1/modules/es6.reflect.get-prototype-of");
  require("npm:core-js@1.2.1/modules/es6.reflect.has");
  require("npm:core-js@1.2.1/modules/es6.reflect.is-extensible");
  require("npm:core-js@1.2.1/modules/es6.reflect.own-keys");
  require("npm:core-js@1.2.1/modules/es6.reflect.prevent-extensions");
  require("npm:core-js@1.2.1/modules/es6.reflect.set");
  require("npm:core-js@1.2.1/modules/es6.reflect.set-prototype-of");
  require("npm:core-js@1.2.1/modules/es7.array.includes");
  require("npm:core-js@1.2.1/modules/es7.string.at");
  require("npm:core-js@1.2.1/modules/es7.string.pad-left");
  require("npm:core-js@1.2.1/modules/es7.string.pad-right");
  require("npm:core-js@1.2.1/modules/es7.string.trim-left");
  require("npm:core-js@1.2.1/modules/es7.string.trim-right");
  require("npm:core-js@1.2.1/modules/es7.regexp.escape");
  require("npm:core-js@1.2.1/modules/es7.object.get-own-property-descriptors");
  require("npm:core-js@1.2.1/modules/es7.object.values");
  require("npm:core-js@1.2.1/modules/es7.object.entries");
  require("npm:core-js@1.2.1/modules/es7.map.to-json");
  require("npm:core-js@1.2.1/modules/es7.set.to-json");
  require("npm:core-js@1.2.1/modules/js.array.statics");
  require("npm:core-js@1.2.1/modules/web.timers");
  require("npm:core-js@1.2.1/modules/web.immediate");
  require("npm:core-js@1.2.1/modules/web.dom.iterable");
  module.exports = require("npm:core-js@1.2.1/modules/$.core");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.global", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNDEFINED = 'undefined';
  var global = module.exports = typeof window != UNDEFINED && window.Math == Math ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.has", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.fails", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.support-desc", ["npm:core-js@1.2.1/library/modules/$.fails"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !require("npm:core-js@1.2.1/library/modules/$.fails")(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.core", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.1'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.def", ["npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/library/modules/$.global"),
      core = require("npm:core-js@1.2.1/library/modules/$.core"),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && typeof target[key] != 'function')
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp[PROTOTYPE] = C[PROTOTYPE];
        }(out);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.property-desc", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.hide", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.property-desc", "npm:core-js@1.2.1/library/modules/$.support-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/library/modules/$"),
      createDesc = require("npm:core-js@1.2.1/library/modules/$.property-desc");
  module.exports = require("npm:core-js@1.2.1/library/modules/$.support-desc") ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.redef", ["npm:core-js@1.2.1/library/modules/$.hide"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.1/library/modules/$.hide");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.shared", ["npm:core-js@1.2.1/library/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@1.2.1/library/modules/$.global"),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.uid", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.wks", ["npm:core-js@1.2.1/library/modules/$.shared", "npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.uid"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = require("npm:core-js@1.2.1/library/modules/$.shared")('wks'),
      Symbol = require("npm:core-js@1.2.1/library/modules/$.global").Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || require("npm:core-js@1.2.1/library/modules/$.uid"))('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.tag", ["npm:core-js@1.2.1/library/modules/$.has", "npm:core-js@1.2.1/library/modules/$.hide", "npm:core-js@1.2.1/library/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var has = require("npm:core-js@1.2.1/library/modules/$.has"),
      hide = require("npm:core-js@1.2.1/library/modules/$.hide"),
      TAG = require("npm:core-js@1.2.1/library/modules/$.wks")('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      hide(it, TAG, tag);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.cof", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iobject", ["npm:core-js@1.2.1/library/modules/$.cof"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/library/modules/$.cof");
  module.exports = 0 in Object('z') ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.defined", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.to-iobject", ["npm:core-js@1.2.1/library/modules/$.iobject", "npm:core-js@1.2.1/library/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = require("npm:core-js@1.2.1/library/modules/$.iobject"),
      defined = require("npm:core-js@1.2.1/library/modules/$.defined");
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.keyof", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.to-iobject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/library/modules/$"),
      toIObject = require("npm:core-js@1.2.1/library/modules/$.to-iobject");
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.get-names", ["npm:core-js@1.2.1/library/modules/$.to-iobject", "npm:core-js@1.2.1/library/modules/$"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString,
      toIObject = require("npm:core-js@1.2.1/library/modules/$.to-iobject"),
      getNames = require("npm:core-js@1.2.1/library/modules/$").getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.enum-keys", ["npm:core-js@1.2.1/library/modules/$"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/library/modules/$");
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.is-array", ["npm:core-js@1.2.1/library/modules/$.cof"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/library/modules/$.cof");
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.is-object", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.an-object", ["npm:core-js@1.2.1/library/modules/$.is-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/library/modules/$.is-object");
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.library", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/es6.symbol", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.has", "npm:core-js@1.2.1/library/modules/$.support-desc", "npm:core-js@1.2.1/library/modules/$.def", "npm:core-js@1.2.1/library/modules/$.redef", "npm:core-js@1.2.1/library/modules/$.fails", "npm:core-js@1.2.1/library/modules/$.shared", "npm:core-js@1.2.1/library/modules/$.tag", "npm:core-js@1.2.1/library/modules/$.uid", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.keyof", "npm:core-js@1.2.1/library/modules/$.get-names", "npm:core-js@1.2.1/library/modules/$.enum-keys", "npm:core-js@1.2.1/library/modules/$.is-array", "npm:core-js@1.2.1/library/modules/$.is-object", "npm:core-js@1.2.1/library/modules/$.an-object", "npm:core-js@1.2.1/library/modules/$.to-iobject", "npm:core-js@1.2.1/library/modules/$.property-desc", "npm:core-js@1.2.1/library/modules/$.library"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/library/modules/$"),
      global = require("npm:core-js@1.2.1/library/modules/$.global"),
      has = require("npm:core-js@1.2.1/library/modules/$.has"),
      SUPPORT_DESC = require("npm:core-js@1.2.1/library/modules/$.support-desc"),
      $def = require("npm:core-js@1.2.1/library/modules/$.def"),
      $redef = require("npm:core-js@1.2.1/library/modules/$.redef"),
      $fails = require("npm:core-js@1.2.1/library/modules/$.fails"),
      shared = require("npm:core-js@1.2.1/library/modules/$.shared"),
      setTag = require("npm:core-js@1.2.1/library/modules/$.tag"),
      uid = require("npm:core-js@1.2.1/library/modules/$.uid"),
      wks = require("npm:core-js@1.2.1/library/modules/$.wks"),
      keyOf = require("npm:core-js@1.2.1/library/modules/$.keyof"),
      $names = require("npm:core-js@1.2.1/library/modules/$.get-names"),
      enumKeys = require("npm:core-js@1.2.1/library/modules/$.enum-keys"),
      isArray = require("npm:core-js@1.2.1/library/modules/$.is-array"),
      isObject = require("npm:core-js@1.2.1/library/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/library/modules/$.an-object"),
      toIObject = require("npm:core-js@1.2.1/library/modules/$.to-iobject"),
      createDesc = require("npm:core-js@1.2.1/library/modules/$.property-desc"),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = SUPPORT_DESC && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    var args = [it],
        i = 1,
        replacer,
        $replacer;
    while (arguments.length > i)
      args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments[0]));
    };
    $redef($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (SUPPORT_DESC && !require("npm:core-js@1.2.1/library/modules/$.library")) {
      $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $def($def.G + $def.W, {Symbol: $Symbol});
  $def($def.S, 'Symbol', symbolStatics);
  $def($def.S + $def.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setTag($Symbol, 'Symbol');
  setTag(Math, 'Math', true);
  setTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/fn/symbol/index", ["npm:core-js@1.2.1/library/modules/es6.symbol", "npm:core-js@1.2.1/library/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/library/modules/es6.symbol");
  module.exports = require("npm:core-js@1.2.1/library/modules/$.core").Symbol;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/fn/symbol", ["npm:core-js@1.2.1/library/fn/symbol/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.1/library/fn/symbol/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/symbol", ["npm:core-js@1.2.1/library/fn/symbol"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@1.2.1/library/fn/symbol"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.to-integer", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.string-at", ["npm:core-js@1.2.1/library/modules/$.to-integer", "npm:core-js@1.2.1/library/modules/$.defined"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = require("npm:core-js@1.2.1/library/modules/$.to-integer"),
      defined = require("npm:core-js@1.2.1/library/modules/$.defined");
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iterators", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iter-create", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.hide", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.property-desc", "npm:core-js@1.2.1/library/modules/$.tag"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/library/modules/$"),
      IteratorPrototype = {};
  require("npm:core-js@1.2.1/library/modules/$.hide")(IteratorPrototype, require("npm:core-js@1.2.1/library/modules/$.wks")('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: require("npm:core-js@1.2.1/library/modules/$.property-desc")(1, next)});
    require("npm:core-js@1.2.1/library/modules/$.tag")(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iter-define", ["npm:core-js@1.2.1/library/modules/$.library", "npm:core-js@1.2.1/library/modules/$.def", "npm:core-js@1.2.1/library/modules/$.redef", "npm:core-js@1.2.1/library/modules/$.hide", "npm:core-js@1.2.1/library/modules/$.has", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.iterators", "npm:core-js@1.2.1/library/modules/$.iter-create", "npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.tag"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var LIBRARY = require("npm:core-js@1.2.1/library/modules/$.library"),
      $def = require("npm:core-js@1.2.1/library/modules/$.def"),
      $redef = require("npm:core-js@1.2.1/library/modules/$.redef"),
      hide = require("npm:core-js@1.2.1/library/modules/$.hide"),
      has = require("npm:core-js@1.2.1/library/modules/$.has"),
      SYMBOL_ITERATOR = require("npm:core-js@1.2.1/library/modules/$.wks")('iterator'),
      Iterators = require("npm:core-js@1.2.1/library/modules/$.iterators"),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    require("npm:core-js@1.2.1/library/modules/$.iter-create")(Constructor, NAME, next);
    var createMethod = function(kind) {
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = require("npm:core-js@1.2.1/library/modules/$").getProto(_default.call(new Base));
      require("npm:core-js@1.2.1/library/modules/$.tag")(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
    }
    if (!LIBRARY || FORCE)
      hide(proto, SYMBOL_ITERATOR, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        keys: IS_SET ? _default : createMethod(KEYS),
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/es6.string.iterator", ["npm:core-js@1.2.1/library/modules/$.string-at", "npm:core-js@1.2.1/library/modules/$.iter-define"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $at = require("npm:core-js@1.2.1/library/modules/$.string-at")(true);
  require("npm:core-js@1.2.1/library/modules/$.iter-define")(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.unscope", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iter-step", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/es6.array.iterator", ["npm:core-js@1.2.1/library/modules/$.unscope", "npm:core-js@1.2.1/library/modules/$.iter-step", "npm:core-js@1.2.1/library/modules/$.iterators", "npm:core-js@1.2.1/library/modules/$.to-iobject", "npm:core-js@1.2.1/library/modules/$.iter-define"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var setUnscope = require("npm:core-js@1.2.1/library/modules/$.unscope"),
      step = require("npm:core-js@1.2.1/library/modules/$.iter-step"),
      Iterators = require("npm:core-js@1.2.1/library/modules/$.iterators"),
      toIObject = require("npm:core-js@1.2.1/library/modules/$.to-iobject");
  require("npm:core-js@1.2.1/library/modules/$.iter-define")(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/web.dom.iterable", ["npm:core-js@1.2.1/library/modules/es6.array.iterator", "npm:core-js@1.2.1/library/modules/$.iterators"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/library/modules/es6.array.iterator");
  var Iterators = require("npm:core-js@1.2.1/library/modules/$.iterators");
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/fn/symbol/iterator", ["npm:core-js@1.2.1/library/modules/es6.string.iterator", "npm:core-js@1.2.1/library/modules/web.dom.iterable", "npm:core-js@1.2.1/library/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/library/modules/es6.string.iterator");
  require("npm:core-js@1.2.1/library/modules/web.dom.iterable");
  module.exports = require("npm:core-js@1.2.1/library/modules/$.wks")('iterator');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/symbol/iterator", ["npm:core-js@1.2.1/library/fn/symbol/iterator"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@1.2.1/library/fn/symbol/iterator"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/fn/object/create", ["npm:core-js@1.2.1/library/modules/$"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@1.2.1/library/modules/$");
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/create", ["npm:core-js@1.2.1/library/fn/object/create"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@1.2.1/library/fn/object/create"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/es6.object.to-string", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.a-function", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.ctx", ["npm:core-js@1.2.1/library/modules/$.a-function"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = require("npm:core-js@1.2.1/library/modules/$.a-function");
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.classof", ["npm:core-js@1.2.1/library/modules/$.cof", "npm:core-js@1.2.1/library/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = require("npm:core-js@1.2.1/library/modules/$.cof"),
      TAG = require("npm:core-js@1.2.1/library/modules/$.wks")('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.strict-new", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iter-call", ["npm:core-js@1.2.1/library/modules/$.an-object"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = require("npm:core-js@1.2.1/library/modules/$.an-object");
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.is-array-iter", ["npm:core-js@1.2.1/library/modules/$.iterators", "npm:core-js@1.2.1/library/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = require("npm:core-js@1.2.1/library/modules/$.iterators"),
      ITERATOR = require("npm:core-js@1.2.1/library/modules/$.wks")('iterator');
  module.exports = function(it) {
    return (Iterators.Array || Array.prototype[ITERATOR]) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.to-length", ["npm:core-js@1.2.1/library/modules/$.to-integer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = require("npm:core-js@1.2.1/library/modules/$.to-integer"),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/core.get-iterator-method", ["npm:core-js@1.2.1/library/modules/$.classof", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.iterators", "npm:core-js@1.2.1/library/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = require("npm:core-js@1.2.1/library/modules/$.classof"),
      ITERATOR = require("npm:core-js@1.2.1/library/modules/$.wks")('iterator'),
      Iterators = require("npm:core-js@1.2.1/library/modules/$.iterators");
  module.exports = require("npm:core-js@1.2.1/library/modules/$.core").getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.for-of", ["npm:core-js@1.2.1/library/modules/$.ctx", "npm:core-js@1.2.1/library/modules/$.iter-call", "npm:core-js@1.2.1/library/modules/$.is-array-iter", "npm:core-js@1.2.1/library/modules/$.an-object", "npm:core-js@1.2.1/library/modules/$.to-length", "npm:core-js@1.2.1/library/modules/core.get-iterator-method"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = require("npm:core-js@1.2.1/library/modules/$.ctx"),
      call = require("npm:core-js@1.2.1/library/modules/$.iter-call"),
      isArrayIter = require("npm:core-js@1.2.1/library/modules/$.is-array-iter"),
      anObject = require("npm:core-js@1.2.1/library/modules/$.an-object"),
      toLength = require("npm:core-js@1.2.1/library/modules/$.to-length"),
      getIterFn = require("npm:core-js@1.2.1/library/modules/core.get-iterator-method");
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.set-proto", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.is-object", "npm:core-js@1.2.1/library/modules/$.an-object", "npm:core-js@1.2.1/library/modules/$.ctx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = require("npm:core-js@1.2.1/library/modules/$").getDesc,
      isObject = require("npm:core-js@1.2.1/library/modules/$.is-object"),
      anObject = require("npm:core-js@1.2.1/library/modules/$.an-object");
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = require("npm:core-js@1.2.1/library/modules/$.ctx")(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.same", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.species", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.support-desc"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@1.2.1/library/modules/$"),
      SPECIES = require("npm:core-js@1.2.1/library/modules/$.wks")('species');
  module.exports = function(C) {
    if (require("npm:core-js@1.2.1/library/modules/$.support-desc") && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.invoke", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.html", ["npm:core-js@1.2.1/library/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.1/library/modules/$.global").document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.dom-create", ["npm:core-js@1.2.1/library/modules/$.is-object", "npm:core-js@1.2.1/library/modules/$.global"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:core-js@1.2.1/library/modules/$.is-object"),
      document = require("npm:core-js@1.2.1/library/modules/$.global").document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.task", ["npm:core-js@1.2.1/library/modules/$.ctx", "npm:core-js@1.2.1/library/modules/$.invoke", "npm:core-js@1.2.1/library/modules/$.html", "npm:core-js@1.2.1/library/modules/$.dom-create", "npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ctx = require("npm:core-js@1.2.1/library/modules/$.ctx"),
        invoke = require("npm:core-js@1.2.1/library/modules/$.invoke"),
        html = require("npm:core-js@1.2.1/library/modules/$.html"),
        cel = require("npm:core-js@1.2.1/library/modules/$.dom-create"),
        global = require("npm:core-js@1.2.1/library/modules/$.global"),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if (require("npm:core-js@1.2.1/library/modules/$.cof")(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.microtask", ["npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.task", "npm:core-js@1.2.1/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = require("npm:core-js@1.2.1/library/modules/$.global"),
        macrotask = require("npm:core-js@1.2.1/library/modules/$.task").set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        isNode = require("npm:core-js@1.2.1/library/modules/$.cof")(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        if (domain)
          domain.enter();
        head.fn.call();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.mix", ["npm:core-js@1.2.1/library/modules/$.redef"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $redef = require("npm:core-js@1.2.1/library/modules/$.redef");
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/$.iter-detect", ["npm:core-js@1.2.1/library/modules/$.wks"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = require("npm:core-js@1.2.1/library/modules/$.wks")('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec) {
    if (!SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/modules/es6.promise", ["npm:core-js@1.2.1/library/modules/$", "npm:core-js@1.2.1/library/modules/$.library", "npm:core-js@1.2.1/library/modules/$.global", "npm:core-js@1.2.1/library/modules/$.ctx", "npm:core-js@1.2.1/library/modules/$.classof", "npm:core-js@1.2.1/library/modules/$.def", "npm:core-js@1.2.1/library/modules/$.is-object", "npm:core-js@1.2.1/library/modules/$.an-object", "npm:core-js@1.2.1/library/modules/$.a-function", "npm:core-js@1.2.1/library/modules/$.strict-new", "npm:core-js@1.2.1/library/modules/$.for-of", "npm:core-js@1.2.1/library/modules/$.set-proto", "npm:core-js@1.2.1/library/modules/$.same", "npm:core-js@1.2.1/library/modules/$.species", "npm:core-js@1.2.1/library/modules/$.wks", "npm:core-js@1.2.1/library/modules/$.uid", "npm:core-js@1.2.1/library/modules/$.microtask", "npm:core-js@1.2.1/library/modules/$.support-desc", "npm:core-js@1.2.1/library/modules/$.mix", "npm:core-js@1.2.1/library/modules/$.tag", "npm:core-js@1.2.1/library/modules/$.core", "npm:core-js@1.2.1/library/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = require("npm:core-js@1.2.1/library/modules/$"),
        LIBRARY = require("npm:core-js@1.2.1/library/modules/$.library"),
        global = require("npm:core-js@1.2.1/library/modules/$.global"),
        ctx = require("npm:core-js@1.2.1/library/modules/$.ctx"),
        classof = require("npm:core-js@1.2.1/library/modules/$.classof"),
        $def = require("npm:core-js@1.2.1/library/modules/$.def"),
        isObject = require("npm:core-js@1.2.1/library/modules/$.is-object"),
        anObject = require("npm:core-js@1.2.1/library/modules/$.an-object"),
        aFunction = require("npm:core-js@1.2.1/library/modules/$.a-function"),
        strictNew = require("npm:core-js@1.2.1/library/modules/$.strict-new"),
        forOf = require("npm:core-js@1.2.1/library/modules/$.for-of"),
        setProto = require("npm:core-js@1.2.1/library/modules/$.set-proto").set,
        same = require("npm:core-js@1.2.1/library/modules/$.same"),
        species = require("npm:core-js@1.2.1/library/modules/$.species"),
        SPECIES = require("npm:core-js@1.2.1/library/modules/$.wks")('species'),
        RECORD = require("npm:core-js@1.2.1/library/modules/$.uid")('record'),
        asap = require("npm:core-js@1.2.1/library/modules/$.microtask"),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && require("npm:core-js@1.2.1/library/modules/$.support-desc")) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var isPromise = function(it) {
      return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
    };
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(react) {
          var cb = ok ? react.ok : react.fail,
              ret,
              then;
          try {
            if (cb) {
              if (!ok)
                record.h = true;
              ret = cb === true ? value : cb(value);
              if (ret === react.P) {
                react.rej(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(ret)) {
                then.call(ret, react.res, react.rej);
              } else
                react.res(ret);
            } else
              react.rej(value);
          } catch (err) {
            react.rej(err);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!useNative) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        this[RECORD] = record;
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      require("npm:core-js@1.2.1/library/modules/$.mix")(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var S = anObject(anObject(this).constructor)[SPECIES];
          var react = {
            ok: typeof onFulfilled == 'function' ? onFulfilled : true,
            fail: typeof onRejected == 'function' ? onRejected : false
          };
          var promise = react.P = new (S != undefined ? S : P)(function(res, rej) {
            react.res = res;
            react.rej = rej;
          });
          aFunction(react.res);
          aFunction(react.rej);
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    require("npm:core-js@1.2.1/library/modules/$.tag")(P, PROMISE);
    species(P);
    species(Wrapper = require("npm:core-js@1.2.1/library/modules/$.core")[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new this(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && require("npm:core-js@1.2.1/library/modules/$.iter-detect")(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.1/library/fn/promise", ["npm:core-js@1.2.1/library/modules/es6.object.to-string", "npm:core-js@1.2.1/library/modules/es6.string.iterator", "npm:core-js@1.2.1/library/modules/web.dom.iterable", "npm:core-js@1.2.1/library/modules/es6.promise", "npm:core-js@1.2.1/library/modules/$.core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@1.2.1/library/modules/es6.object.to-string");
  require("npm:core-js@1.2.1/library/modules/es6.string.iterator");
  require("npm:core-js@1.2.1/library/modules/web.dom.iterable");
  require("npm:core-js@1.2.1/library/modules/es6.promise");
  module.exports = require("npm:core-js@1.2.1/library/modules/$.core").Promise;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/promise", ["npm:core-js@1.2.1/library/fn/promise"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@1.2.1/library/fn/promise"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/regenerator/runtime", ["npm:babel-runtime@5.8.25/core-js/symbol", "npm:babel-runtime@5.8.25/core-js/symbol/iterator", "npm:babel-runtime@5.8.25/core-js/object/create", "npm:babel-runtime@5.8.25/core-js/promise", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var _Symbol = require("npm:babel-runtime@5.8.25/core-js/symbol")["default"];
    var _Symbol$iterator = require("npm:babel-runtime@5.8.25/core-js/symbol/iterator")["default"];
    var _Object$create = require("npm:babel-runtime@5.8.25/core-js/object/create")["default"];
    var _Promise = require("npm:babel-runtime@5.8.25/core-js/promise")["default"];
    !(function(global) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined;
      var iteratorSymbol = typeof _Symbol === "function" && _Symbol$iterator || "@@iterator";
      var inModule = typeof module === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          module.exports = runtime;
        }
        return;
      }
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var generator = _Object$create((outerFn || Generator).prototype);
        generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));
        return generator;
      }
      runtime.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = "GeneratorFunction";
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          prototype[method] = function(arg) {
            return this._invoke(method, arg);
          };
        });
      }
      runtime.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      runtime.mark = function(genFun) {
        genFun.__proto__ = GeneratorFunctionPrototype;
        genFun.prototype = _Object$create(Gp);
        return genFun;
      };
      runtime.awrap = function(arg) {
        return new AwaitArgument(arg);
      };
      function AwaitArgument(arg) {
        this.arg = arg;
      }
      function AsyncIterator(generator) {
        function invoke(method, arg) {
          var result = generator[method](arg);
          var value = result.value;
          return value instanceof AwaitArgument ? _Promise.resolve(value.arg).then(invokeNext, invokeThrow) : _Promise.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            return result;
          });
        }
        if (typeof process === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }
        var invokeNext = invoke.bind(generator, "next");
        var invokeThrow = invoke.bind(generator, "throw");
        var invokeReturn = invoke.bind(generator, "return");
        var previousPromise;
        function enqueue(method, arg) {
          var enqueueResult = previousPromise ? previousPromise.then(function() {
            return invoke(method, arg);
          }) : new _Promise(function(resolve) {
            resolve(invoke(method, arg));
          });
          previousPromise = enqueueResult["catch"](function(ignored) {});
          return enqueueResult;
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                context.delegate = null;
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }
                if (method === "return") {
                  continue;
                }
              }
              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
              if (record.type === "throw") {
                context.delegate = null;
                method = "throw";
                arg = record.arg;
                continue;
              }
              method = "next";
              arg = undefined;
              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }
              context.delegate = null;
            }
            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }
              if (context.dispatchException(arg)) {
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              var info = {
                value: record.arg,
                done: context.done
              };
              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }
      defineIteratorMethods(Gp);
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {tryLoc: locs[0]};
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{tryLoc: "root"}];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      runtime.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }
                  next.value = undefined;
                  next.done = true;
                  return next;
                };
            return next.next = next;
          }
        }
        return {next: doneResult};
      }
      runtime.values = values;
      function doneResult() {
        return {
          value: undefined,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }
          return ContinueSentinel;
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };
          return ContinueSentinel;
        }
      };
    })(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-core@5.8.25/lib/polyfill", ["npm:core-js@1.2.1/shim", "npm:babel-runtime@5.8.25/regenerator/runtime"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  "use strict";
  require("npm:core-js@1.2.1/shim");
  require("npm:babel-runtime@5.8.25/regenerator/runtime");
  if (global._babelPolyfill) {
    throw new Error("only one instance of babel/polyfill is allowed");
  }
  global._babelPolyfill = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-core@5.8.25/polyfill", ["npm:babel-core@5.8.25/lib/polyfill"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  module.exports = require("npm:babel-core@5.8.25/lib/polyfill");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2/src/getXMLHttpRequest.browser", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function getXMLHttpRequest() {
    var progId,
        progIds,
        i;
    if (global.XMLHttpRequest) {
      return new global.XMLHttpRequest();
    } else {
      try {
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
        for (i = 0; i < 3; i++) {
          try {
            progId = progIds[i];
            if (new global.ActiveXObject(progId)) {
              break;
            }
          } catch (e) {}
        }
        return new global.ActiveXObject(progId);
      } catch (e) {
        throw new Error('XMLHttpRequest is not supported by your browser');
      }
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2/src/getCORSRequest", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function getCORSRequest() {
    var xhr = new global.XMLHttpRequest();
    if ('withCredentials' in xhr) {
      return xhr;
    } else if (!!global.XDomainRequest) {
      return new XDomainRequest();
    } else {
      throw new Error('CORS is not supported by your browser');
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2/src/request", ["npm:falcor-http-datasource@0.1.2/src/getXMLHttpRequest.browser", "npm:falcor-http-datasource@0.1.2/src/getCORSRequest"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var getXMLHttpRequest = require("npm:falcor-http-datasource@0.1.2/src/getXMLHttpRequest.browser");
  var getCORSRequest = require("npm:falcor-http-datasource@0.1.2/src/getCORSRequest");
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var noop = function() {};
  function Observable() {}
  Observable.create = function(subscribe) {
    var o = new Observable();
    o.subscribe = function(onNext, onError, onCompleted) {
      var observer;
      var disposable;
      if (typeof onNext === 'function') {
        observer = {
          onNext: onNext,
          onError: (onError || noop),
          onCompleted: (onCompleted || noop)
        };
      } else {
        observer = onNext;
      }
      disposable = subscribe(observer);
      if (typeof disposable === 'function') {
        return {dispose: disposable};
      } else {
        return disposable;
      }
    };
    return o;
  };
  function request(method, options, context) {
    return Observable.create(function requestObserver(observer) {
      var config = {
        method: method || 'GET',
        crossDomain: false,
        async: true,
        headers: {},
        responseType: 'json'
      };
      var xhr,
          isDone,
          headers,
          header,
          prop;
      for (prop in options) {
        if (hasOwnProp.call(options, prop)) {
          config[prop] = options[prop];
        }
      }
      if (!config.crossDomain && !config.headers['X-Requested-With']) {
        config.headers['X-Requested-With'] = 'XMLHttpRequest';
      }
      if (context.onBeforeRequest != null) {
        context.onBeforeRequest(config);
      }
      try {
        xhr = config.crossDomain ? getCORSRequest() : getXMLHttpRequest();
      } catch (err) {
        observer.onError(err);
      }
      try {
        if (config.user) {
          xhr.open(config.method, config.url, config.async, config.user, config.password);
        } else {
          xhr.open(config.method, config.url, config.async);
        }
        xhr.timeout = config.timeout;
        xhr.withCredentials = config.withCredentials !== false;
        headers = config.headers;
        for (header in headers) {
          if (hasOwnProp.call(headers, header)) {
            xhr.setRequestHeader(header, headers[header]);
          }
        }
        if (config.responseType) {
          try {
            xhr.responseType = config.responseType;
          } catch (e) {
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }
        xhr.onreadystatechange = function onreadystatechange(e) {
          if (xhr.readyState === 4) {
            if (!isDone) {
              isDone = true;
              onXhrLoad(observer, xhr, e);
            }
          }
        };
        xhr.ontimeout = function ontimeout(e) {
          if (!isDone) {
            isDone = true;
            onXhrError(observer, xhr, 'timeout error', e);
          }
        };
        xhr.send(config.data);
      } catch (e) {
        observer.onError(e);
      }
      return function dispose() {
        if (!isDone && xhr.readyState !== 4) {
          isDone = true;
          xhr.abort();
        }
      };
    });
  }
  function _handleXhrError(observer, textStatus, errorThrown) {
    if (!errorThrown) {
      errorThrown = new Error(textStatus);
    }
    observer.onError(errorThrown);
  }
  function onXhrLoad(observer, xhr, e) {
    var responseData,
        responseObject,
        responseType;
    if (xhr && observer) {
      responseType = xhr.responseType;
      responseData = ('response' in xhr) ? xhr.response : xhr.responseText;
      var status = (xhr.status === 1223) ? 204 : xhr.status;
      if (status >= 200 && status <= 399) {
        try {
          if (responseType !== 'json') {
            responseData = JSON.parse(responseData || '');
          }
          if (typeof responseData === 'string') {
            responseData = JSON.parse(responseData || '');
          }
        } catch (e) {
          _handleXhrError(observer, 'invalid json', e);
        }
        observer.onNext(responseData);
        observer.onCompleted();
        return;
      } else if (status === 401 || status === 403 || status === 407) {
        return _handleXhrError(observer, responseData);
      } else if (status === 410) {
        return _handleXhrError(observer, responseData);
      } else if (status === 408 || status === 504) {
        return _handleXhrError(observer, responseData);
      } else {
        return _handleXhrError(observer, responseData || ('Response code ' + status));
      }
    }
  }
  function onXhrError(observer, xhr, status, e) {
    _handleXhrError(observer, status || xhr.statusText || 'request error', e);
  }
  module.exports = request;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2/src/buildQueryObject", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = function buildQueryObject(url, method, queryData) {
    var qData = [];
    var keys;
    var data = {url: url};
    var isQueryParamUrl = url.indexOf('?') !== -1;
    var startUrl = (isQueryParamUrl) ? '&' : '?';
    if (typeof queryData === 'string') {
      qData.push(queryData);
    } else {
      keys = Object.keys(queryData);
      keys.forEach(function(k) {
        var value = (typeof queryData[k] === 'object') ? JSON.stringify(queryData[k]) : queryData[k];
        qData.push(k + '=' + value);
      });
    }
    if (method === 'GET') {
      data.url += startUrl + qData.join('&');
    } else {
      data.data = qData.join('&');
    }
    return data;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2/src/XMLHttpSource", ["npm:falcor-http-datasource@0.1.2/src/request", "npm:falcor-http-datasource@0.1.2/src/buildQueryObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var request = require("npm:falcor-http-datasource@0.1.2/src/request");
  var buildQueryObject = require("npm:falcor-http-datasource@0.1.2/src/buildQueryObject");
  var isArray = Array.isArray;
  function simpleExtend(obj, obj2) {
    var prop;
    for (prop in obj2) {
      obj[prop] = obj2[prop];
    }
    return obj;
  }
  function XMLHttpSource(jsongUrl, config) {
    this._jsongUrl = jsongUrl;
    if (typeof config === 'number') {
      var newConfig = {timeout: config};
      config = newConfig;
    }
    this._config = simpleExtend({
      timeout: 15000,
      headers: {}
    }, config || {});
  }
  XMLHttpSource.prototype = {
    constructor: XMLHttpSource,
    buildQueryObject: buildQueryObject,
    get: function httpSourceGet(pathSet) {
      var method = 'GET';
      var queryObject = this.buildQueryObject(this._jsongUrl, method, {
        paths: pathSet,
        method: 'get'
      });
      var config = simpleExtend(queryObject, this._config);
      var context = this;
      return request(method, config, context);
    },
    set: function httpSourceSet(jsongEnv) {
      var method = 'POST';
      var queryObject = this.buildQueryObject(this._jsongUrl, method, {
        jsonGraph: jsongEnv,
        method: 'set'
      });
      var config = simpleExtend(queryObject, this._config);
      config.headers["Content-Type"] = "application/x-www-form-urlencoded";
      var context = this;
      return request(method, config, context);
    },
    call: function httpSourceCall(callPath, args, pathSuffix, paths) {
      args = args || [];
      pathSuffix = pathSuffix || [];
      paths = paths || [];
      var method = 'POST';
      var queryData = [];
      queryData.push('method=call');
      queryData.push('callPath=' + encodeURIComponent(JSON.stringify(callPath)));
      queryData.push('arguments=' + encodeURIComponent(JSON.stringify(args)));
      queryData.push('pathSuffixes=' + encodeURIComponent(JSON.stringify(pathSuffix)));
      queryData.push('paths=' + encodeURIComponent(JSON.stringify(paths)));
      var queryObject = this.buildQueryObject(this._jsongUrl, method, queryData.join('&'));
      var config = simpleExtend(queryObject, this._config);
      config.headers["Content-Type"] = "application/x-www-form-urlencoded";
      var context = this;
      return request(method, config, context);
    }
  };
  XMLHttpSource.XMLHttpSource = XMLHttpSource;
  XMLHttpSource['default'] = XMLHttpSource;
  module.exports = XMLHttpSource;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-http-datasource@0.1.2", ["npm:falcor-http-datasource@0.1.2/src/XMLHttpSource"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor-http-datasource@0.1.2/src/XMLHttpSource");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:events@1.0.2/events", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function(type) {
    var er,
        handler,
        len,
        args,
        i,
        listeners;
    if (!this._events)
      this._events = {};
    if (type === 'error') {
      if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (isUndefined(handler))
      return false;
    if (isFunction(handler)) {
      switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    var m;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events)
      this._events = {};
    if (this._events.newListener)
      this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      this._events[type].push(listener);
    else
      this._events[type] = [this._events[type], listener];
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          console.trace();
        }
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list,
        position,
        length,
        i;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
      return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0; ) {
        if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function(type) {
    var key,
        listeners;
    if (!this._events)
      return this;
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener')
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:events@1.0.2", ["npm:events@1.0.2/events"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:events@1.0.2/events");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1/index", ["npm:events@1.0.2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('events') : require("npm:events@1.0.2");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1", ["github:jspm/nodelibs-events@0.1.1/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-events@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:domain-browser@1.1.4/index", ["github:jspm/nodelibs-events@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = (function() {
    var events = require("github:jspm/nodelibs-events@0.1.1");
    var domain = {};
    domain.createDomain = domain.create = function() {
      var d = new events.EventEmitter();
      function emitError(e) {
        d.emit('error', e);
      }
      d.add = function(emitter) {
        emitter.on('error', emitError);
      };
      d.remove = function(emitter) {
        emitter.removeListener('error', emitError);
      };
      d.bind = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          try {
            fn.apply(null, args);
          } catch (err) {
            emitError(err);
          }
        };
      };
      d.intercept = function(fn) {
        return function(err) {
          if (err) {
            emitError(err);
          } else {
            var args = Array.prototype.slice.call(arguments, 1);
            try {
              fn.apply(null, args);
            } catch (err) {
              emitError(err);
            }
          }
        };
      };
      d.run = function(fn) {
        try {
          fn();
        } catch (err) {
          emitError(err);
        }
        return this;
      };
      d.dispose = function() {
        this.removeAllListeners();
        return this;
      };
      d.enter = d.exit = function() {
        return this;
      };
      return d;
    };
    return domain;
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:domain-browser@1.1.4", ["npm:domain-browser@1.1.4/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:domain-browser@1.1.4/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-domain@0.1.0/index", ["npm:domain-browser@1.1.4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('domain') : require("npm:domain-browser@1.1.4");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-domain@0.1.0", ["github:jspm/nodelibs-domain@0.1.0/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-domain@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:asap@2.0.3/raw", ["github:jspm/nodelibs-domain@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var domain;
    var hasSetImmediate = typeof setImmediate === "function";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0,
              newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    rawAsap.requestFlush = requestFlush;
    function requestFlush() {
      var parentDomain = process.domain;
      if (parentDomain) {
        if (!domain) {
          domain = require("github:jspm/nodelibs-domain@0.1.0");
        }
        domain.active = process.domain = null;
      }
      if (flushing && hasSetImmediate) {
        setImmediate(flush);
      } else {
        process.nextTick(flush);
      }
      if (parentDomain) {
        domain.active = process.domain = parentDomain;
      }
    }
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/core", ["npm:asap@2.0.3/raw"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var asap = require("npm:asap@2.0.3/raw");
  function noop() {}
  var LAST_ERROR = null;
  var IS_ERROR = {};
  function getThen(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  function tryCallOne(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  function tryCallTwo(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }
  module.exports = Promise;
  function Promise(fn) {
    if (typeof this !== 'object') {
      throw new TypeError('Promises must be constructed via new');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('not a function');
    }
    this._37 = 0;
    this._12 = null;
    this._59 = [];
    if (fn === noop)
      return;
    doResolve(fn, this);
  }
  Promise._99 = noop;
  Promise.prototype.then = function(onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
      return safeThen(this, onFulfilled, onRejected);
    }
    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };
  function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      var res = new Promise(noop);
      res.then(resolve, reject);
      handle(self, new Handler(onFulfilled, onRejected, res));
    });
  }
  ;
  function handle(self, deferred) {
    while (self._37 === 3) {
      self = self._12;
    }
    if (self._37 === 0) {
      self._59.push(deferred);
      return;
    }
    asap(function() {
      var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        if (self._37 === 1) {
          resolve(deferred.promise, self._12);
        } else {
          reject(deferred.promise, self._12);
        }
        return;
      }
      var ret = tryCallOne(cb, self._12);
      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  }
  function resolve(self, newValue) {
    if (newValue === self) {
      return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = getThen(newValue);
      if (then === IS_ERROR) {
        return reject(self, LAST_ERROR);
      }
      if (then === self.then && newValue instanceof Promise) {
        self._37 = 3;
        self._12 = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(then.bind(newValue), self);
        return;
      }
    }
    self._37 = 1;
    self._12 = newValue;
    finale(self);
  }
  function reject(self, newValue) {
    self._37 = 2;
    self._12 = newValue;
    finale(self);
  }
  function finale(self) {
    for (var i = 0; i < self._59.length; i++) {
      handle(self, self._59[i]);
    }
    self._59 = null;
  }
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }
  function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function(value) {
      if (done)
        return;
      done = true;
      resolve(promise, value);
    }, function(reason) {
      if (done)
        return;
      done = true;
      reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/done", ["npm:promise@7.0.4/lib/core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var Promise = require("npm:promise@7.0.4/lib/core");
  module.exports = Promise;
  Promise.prototype.done = function(onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function(err) {
      setTimeout(function() {
        throw err;
      }, 0);
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/finally", ["npm:promise@7.0.4/lib/core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var Promise = require("npm:promise@7.0.4/lib/core");
  module.exports = Promise;
  Promise.prototype['finally'] = function(f) {
    return this.then(function(value) {
      return Promise.resolve(f()).then(function() {
        return value;
      });
    }, function(err) {
      return Promise.resolve(f()).then(function() {
        throw err;
      });
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/es6-extensions", ["npm:promise@7.0.4/lib/core"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var Promise = require("npm:promise@7.0.4/lib/core");
  module.exports = Promise;
  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise('');
  function valuePromise(value) {
    var p = new Promise(Promise._99);
    p._37 = 1;
    p._12 = value;
    return p;
  }
  Promise.resolve = function(value) {
    if (value instanceof Promise)
      return value;
    if (value === null)
      return NULL;
    if (value === undefined)
      return UNDEFINED;
    if (value === true)
      return TRUE;
    if (value === false)
      return FALSE;
    if (value === 0)
      return ZERO;
    if (value === '')
      return EMPTYSTRING;
    if (typeof value === 'object' || typeof value === 'function') {
      try {
        var then = value.then;
        if (typeof then === 'function') {
          return new Promise(then.bind(value));
        }
      } catch (ex) {
        return new Promise(function(resolve, reject) {
          reject(ex);
        });
      }
    }
    return valuePromise(value);
  };
  Promise.all = function(arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise(function(resolve, reject) {
      if (args.length === 0)
        return resolve([]);
      var remaining = args.length;
      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          if (val instanceof Promise && val.then === Promise.prototype.then) {
            while (val._37 === 3) {
              val = val._12;
            }
            if (val._37 === 1)
              return res(i, val._12);
            if (val._37 === 2)
              reject(val._12);
            val.then(function(val) {
              res(i, val);
            }, reject);
            return;
          } else {
            var then = val.then;
            if (typeof then === 'function') {
              var p = new Promise(then.bind(val));
              p.then(function(val) {
                res(i, val);
              }, reject);
              return;
            }
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      }
      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };
  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };
  Promise.race = function(values) {
    return new Promise(function(resolve, reject) {
      values.forEach(function(value) {
        Promise.resolve(value).then(resolve, reject);
      });
    });
  };
  Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:asap@2.0.3/browser-raw", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0,
              newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, {characterData: true});
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:asap@2.0.3/asap", ["npm:asap@2.0.3/browser-raw", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var rawAsap = require("npm:asap@2.0.3/browser-raw");
    var freeTasks = [];
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawTask.domain = process.domain;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
      this.domain = null;
    }
    RawTask.prototype.call = function() {
      if (this.domain) {
        this.domain.enter();
      }
      var threw = true;
      try {
        this.task.call();
        threw = false;
        if (this.domain) {
          this.domain.exit();
        }
      } finally {
        if (threw) {
          rawAsap.requestFlush();
        }
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
      }
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:asap@2.0.3", ["npm:asap@2.0.3/asap"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:asap@2.0.3/asap");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/node-extensions", ["npm:promise@7.0.4/lib/core", "npm:asap@2.0.3"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var Promise = require("npm:promise@7.0.4/lib/core");
  var asap = require("npm:asap@2.0.3");
  module.exports = Promise;
  Promise.denodeify = function(fn, argumentCount) {
    argumentCount = argumentCount || Infinity;
    return function() {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0, argumentCount > 0 ? argumentCount : 0);
      return new Promise(function(resolve, reject) {
        args.push(function(err, res) {
          if (err)
            reject(err);
          else
            resolve(res);
        });
        var res = fn.apply(self, args);
        if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
          resolve(res);
        }
      });
    };
  };
  Promise.nodeify = function(fn) {
    return function() {
      var args = Array.prototype.slice.call(arguments);
      var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
      var ctx = this;
      try {
        return fn.apply(this, arguments).nodeify(callback, ctx);
      } catch (ex) {
        if (callback === null || typeof callback == 'undefined') {
          return new Promise(function(resolve, reject) {
            reject(ex);
          });
        } else {
          asap(function() {
            callback.call(ctx, ex);
          });
        }
      }
    };
  };
  Promise.prototype.nodeify = function(callback, ctx) {
    if (typeof callback != 'function')
      return this;
    this.then(function(value) {
      asap(function() {
        callback.call(ctx, null, value);
      });
    }, function(err) {
      asap(function() {
        callback.call(ctx, err);
      });
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/lib/index", ["npm:promise@7.0.4/lib/core", "npm:promise@7.0.4/lib/done", "npm:promise@7.0.4/lib/finally", "npm:promise@7.0.4/lib/es6-extensions", "npm:promise@7.0.4/lib/node-extensions"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = require("npm:promise@7.0.4/lib/core");
  require("npm:promise@7.0.4/lib/done");
  require("npm:promise@7.0.4/lib/finally");
  require("npm:promise@7.0.4/lib/es6-extensions");
  require("npm:promise@7.0.4/lib/node-extensions");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4/index", ["npm:promise@7.0.4/lib/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = require("npm:promise@7.0.4/lib/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:promise@7.0.4", ["npm:promise@7.0.4/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:promise@7.0.4/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isFunction", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var functionTypeof = "function";
  module.exports = function isFunction(func) {
    return Boolean(func) && typeof func === functionTypeof;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isObject", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var objTypeof = "object";
  module.exports = function isObject(value) {
    return value !== null && typeof value === objTypeof;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/hasOwn", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var hasOwn = Object.prototype.hasOwnProperty;
  module.exports = function(obj, prop) {
    return isObject(obj) && hasOwn.call(obj, prop);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@2.5.3/dist/rx", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(undefined) {
      var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
      };
      var root = (objectTypes[typeof window] && window) || this,
          freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      var Rx = {
        internals: {},
        config: {Promise: root.Promise},
        helpers: {}
      };
      var noop = Rx.helpers.noop = function() {},
          notDefined = Rx.helpers.notDefined = function(x) {
            return typeof x === 'undefined';
          },
          identity = Rx.helpers.identity = function(x) {
            return x;
          },
          pluck = Rx.helpers.pluck = function(property) {
            return function(x) {
              return x[property];
            };
          },
          just = Rx.helpers.just = function(value) {
            return function() {
              return value;
            };
          },
          defaultNow = Rx.helpers.defaultNow = Date.now,
          defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y);
          },
          defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : (x < y ? -1 : 0);
          },
          defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString();
          },
          defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
          },
          isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
          },
          asArray = Rx.helpers.asArray = function() {
            return Array.prototype.slice.call(arguments);
          },
          not = Rx.helpers.not = function(a) {
            return !a;
          },
          isFunction = Rx.helpers.isFunction = (function() {
            var isFn = function(value) {
              return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
              isFn = function(value) {
                return typeof value == 'function' && toString.call(value) == '[object Function]';
              };
            }
            return isFn;
          }());
      function cloneArray(arr) {
        for (var a = [],
            i = 0,
            len = arr.length; i < len; i++) {
          a.push(arr[i]);
        }
        return a;
      }
      Rx.config.longStackSupport = false;
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var rStartingLine = captureLine(),
          rFileName;
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var o = observable; !!o; o = o.source) {
            if (o.stack) {
              stacks.unshift(o.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n"),
            desiredLines = [];
        for (var i = 0,
            len = lines.length; i < len; i++) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          rFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      var EmptyError = Rx.EmptyError = function() {
        this.message = 'Sequence contains no elements.';
        Error.call(this);
      };
      EmptyError.prototype = Error.prototype;
      var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = 'Object has been disposed';
        Error.call(this);
      };
      ObjectDisposedError.prototype = Error.prototype;
      var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = 'Argument out of range';
        Error.call(this);
      };
      ArgumentOutOfRangeError.prototype = Error.prototype;
      var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || 'This operation is not supported';
        Error.call(this);
      };
      NotSupportedError.prototype = Error.prototype;
      var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || 'This operation is not implemented';
        Error.call(this);
      };
      NotImplementedError.prototype = Error.prototype;
      var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError();
      };
      var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError();
      };
      var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
      if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
      }
      var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
      };
      var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined;
      };
      var isArrayLike = Rx.helpers.isArrayLike = function(o) {
        return o && o.length !== undefined;
      };
      Rx.helpers.iterator = $iterator$;
      var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
          return func;
        }
        switch (argCount) {
          case 0:
            return function() {
              return func.call(thisArg);
            };
          case 1:
            return function(arg) {
              return func.call(thisArg, arg);
            };
          case 2:
            return function(value, index) {
              return func.call(thisArg, value, index);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      };
      var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          errorClass = '[object Error]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var toString = Object.prototype.toString,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          supportsArgsClass = toString.call(arguments) == argsClass,
          supportNodeClass,
          errorProto = Error.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype,
          propertyIsEnumerable = objectProto.propertyIsEnumerable;
      try {
        supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
      } catch (e) {
        supportNodeClass = true;
      }
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
      };
      nonEnumProps[objectClass] = {'constructor': true};
      var support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        },
            props = [];
        ctor.prototype = {
          'valueOf': 1,
          'y': 1
        };
        for (var key in new ctor) {
          props.push(key);
        }
        for (key in arguments) {}
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
      }(1));
      var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
      };
      function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
          return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
          object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function',
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
          if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
            result.push(key);
          }
        }
        if (support.nonEnumShadows && object !== objectProto) {
          var ctor = object.constructor,
              index = -1,
              length = dontEnumsLength;
          if (object === (ctor && ctor.prototype)) {
            var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
          }
          while (++index < length) {
            key = dontEnums[index];
            if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
        }
        return result;
      }
      function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
          var key = props[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
        return object;
      }
      function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
      }
      function isNode(value) {
        return typeof value.toString != 'function' && typeof(value + '') == 'string';
      }
      var isArguments = function(value) {
        return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
      };
      if (!supportsArgsClass) {
        isArguments = function(value) {
          return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
        };
      }
      var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], []);
      };
      function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
          return a !== 0 || (1 / a == 1 / b);
        }
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
          return false;
        }
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) {
          className = objectClass;
        }
        if (otherClass == argsClass) {
          otherClass = objectClass;
        }
        if (className != otherClass) {
          return false;
        }
        switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
          case regexpClass:
          case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
          if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
            return false;
          }
          var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
              ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
          if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == a) {
            return stackB[length] == b;
          }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
          length = a.length;
          size = b.length;
          result = size == length;
          if (result) {
            while (size--) {
              var index = length,
                  value = b[size];
              if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                break;
              }
            }
          }
        } else {
          internalForIn(b, function(value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
            }
          });
          if (result) {
            internalForIn(a, function(value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return (result = --size > -1);
              }
            });
          }
        }
        stackA.pop();
        stackB.pop();
        return result;
      }
      var hasProp = {}.hasOwnProperty,
          slice = Array.prototype.slice;
      var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
          this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
      };
      var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [],
            i = 1,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
        for (var idx = 0,
            ln = sources.length; idx < ln; idx++) {
          var source = sources[idx];
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      };
      var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
          return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
      };
      function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
          a[i] = factory();
        }
        return a;
      }
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      function IndexedItem(id, value) {
        this.id = id;
        this.value = value;
      }
      IndexedItem.prototype.compareTo = function(other) {
        var c = this.value.compareTo(other.value);
        c === 0 && (c = this.id - other.id);
        return c;
      };
      var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
        this.items = new Array(capacity);
        this.length = 0;
      };
      var priorityProto = PriorityQueue.prototype;
      priorityProto.isHigherPriority = function(left, right) {
        return this.items[left].compareTo(this.items[right]) < 0;
      };
      priorityProto.percolate = function(index) {
        if (index >= this.length || index < 0) {
          return;
        }
        var parent = index - 1 >> 1;
        if (parent < 0 || parent === index) {
          return;
        }
        if (this.isHigherPriority(index, parent)) {
          var temp = this.items[index];
          this.items[index] = this.items[parent];
          this.items[parent] = temp;
          this.percolate(parent);
        }
      };
      priorityProto.heapify = function(index) {
        +index || (index = 0);
        if (index >= this.length || index < 0) {
          return;
        }
        var left = 2 * index + 1,
            right = 2 * index + 2,
            first = index;
        if (left < this.length && this.isHigherPriority(left, first)) {
          first = left;
        }
        if (right < this.length && this.isHigherPriority(right, first)) {
          first = right;
        }
        if (first !== index) {
          var temp = this.items[index];
          this.items[index] = this.items[first];
          this.items[first] = temp;
          this.heapify(first);
        }
      };
      priorityProto.peek = function() {
        return this.items[0].value;
      };
      priorityProto.removeAt = function(index) {
        this.items[index] = this.items[--this.length];
        this.items[this.length] = undefined;
        this.heapify();
      };
      priorityProto.dequeue = function() {
        var result = this.peek();
        this.removeAt(0);
        return result;
      };
      priorityProto.enqueue = function(item) {
        var index = this.length++;
        this.items[index] = new IndexedItem(PriorityQueue.count++, item);
        this.percolate(index);
      };
      priorityProto.remove = function(item) {
        for (var i = 0; i < this.length; i++) {
          if (this.items[i].value === item) {
            this.removeAt(i);
            return true;
          }
        }
        return false;
      };
      PriorityQueue.count = 0;
      var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i,
            len;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
          len = args.length;
        } else {
          len = arguments.length;
          args = new Array(len);
          for (i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        for (i = 0; i < len; i++) {
          if (!isDisposable(args[i])) {
            throw new TypeError('Not a disposable');
          }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
      };
      var CompositeDisposablePrototype = CompositeDisposable.prototype;
      CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) {
          item.dispose();
        } else {
          this.disposables.push(item);
          this.length++;
        }
      };
      CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
          var idx = this.disposables.indexOf(item);
          if (idx !== -1) {
            shouldDispose = true;
            this.disposables.splice(idx, 1);
            this.length--;
            item.dispose();
          }
        }
        return shouldDispose;
      };
      CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var len = this.disposables.length,
              currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }
          this.disposables = [];
          this.length = 0;
          for (i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        }
      };
      var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop;
      };
      Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.action();
          this.isDisposed = true;
        }
      };
      var disposableCreate = Disposable.create = function(action) {
        return new Disposable(action);
      };
      var disposableEmpty = Disposable.empty = {dispose: noop};
      var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose);
      };
      var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) {
          throw new ObjectDisposedError();
        }
      };
      var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) {
          throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
      };
      SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SerialDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var RefCountDisposable = Rx.RefCountDisposable = (function() {
        function InnerDisposable(disposable) {
          this.disposable = disposable;
          this.disposable.count++;
          this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function() {
          if (!this.disposable.isDisposed && !this.isInnerDisposed) {
            this.isInnerDisposed = true;
            this.disposable.count--;
            if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
              this.disposable.isDisposed = true;
              this.disposable.underlyingDisposable.dispose();
            }
          }
        };
        function RefCountDisposable(disposable) {
          this.underlyingDisposable = disposable;
          this.isDisposed = false;
          this.isPrimaryDisposed = false;
          this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function() {
          if (!this.isDisposed && !this.isPrimaryDisposed) {
            this.isPrimaryDisposed = true;
            if (this.count === 0) {
              this.isDisposed = true;
              this.underlyingDisposable.dispose();
            }
          }
        };
        RefCountDisposable.prototype.getDisposable = function() {
          return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
      })();
      function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
      }
      function scheduleItem(s, self) {
        if (!self.isDisposed) {
          self.isDisposed = true;
          self.disposable.dispose();
        }
      }
      ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem);
      };
      var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
      };
      ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore());
      };
      ScheduledItem.prototype.compareTo = function(other) {
        return this.comparer(this.dueTime, other.dueTime);
      };
      ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed;
      };
      ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state);
      };
      var Scheduler = Rx.Scheduler = (function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
          this.now = now;
          this._schedule = schedule;
          this._scheduleRelative = scheduleRelative;
          this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function(s) {
          return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
          action();
          return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
          return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function(state, action) {
          return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
          return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
          return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
          timeSpan < 0 && (timeSpan = 0);
          return timeSpan;
        };
        return Scheduler;
      }());
      var normalizeTime = Scheduler.normalize,
          isScheduler = Scheduler.isScheduler;
      (function(schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          recursiveAction(state);
          return group;
        }
        function invokeRecDate(scheduler, pair, method) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2, dueTime1) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          ;
          recursiveAction(state);
          return group;
        }
        function scheduleInnerRecursive(action, self) {
          action(function(dt) {
            self(action, dt);
          });
        }
        schedulerProto.scheduleRecursive = function(action) {
          return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
          return this.scheduleWithState([state, action], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
          return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
          });
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
          return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period, action) {
          return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          if (typeof root.setInterval === 'undefined') {
            throw new NotSupportedError();
          }
          period = normalizeTime(period);
          var s = state,
              id = root.setInterval(function() {
                s = action(s);
              }, period);
          return disposableCreate(function() {
            root.clearInterval(id);
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
          return new CatchScheduler(this, handler);
        };
      }(Scheduler.prototype));
      var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
        function tick(command, recurse) {
          recurse(0, this._period);
          try {
            this._state = this._action(this._state);
          } catch (e) {
            this._cancel.dispose();
            throw e;
          }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
          this._scheduler = scheduler;
          this._state = state;
          this._period = period;
          this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function() {
          var d = new SingleAssignmentDisposable();
          this._cancel = d;
          d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
          return d;
        };
        return SchedulePeriodicRecursive;
      }());
      var immediateScheduler = Scheduler.immediate = (function() {
        function scheduleNow(state, action) {
          return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      }());
      var currentThreadScheduler = Scheduler.currentThread = (function() {
        var queue;
        function runTrampoline() {
          while (queue.length > 0) {
            var item = queue.dequeue();
            !item.isCancelled() && item.invoke();
          }
        }
        function scheduleNow(state, action) {
          var si = new ScheduledItem(this, state, action, this.now());
          if (!queue) {
            queue = new PriorityQueue(4);
            queue.enqueue(si);
            var result = tryCatch(runTrampoline)();
            queue = null;
            if (result === errorObj) {
              return thrower(result.e);
            }
          } else {
            queue.enqueue(si);
          }
          return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
          return !queue;
        };
        return currentScheduler;
      }());
      var scheduleMethod,
          clearMethod;
      var localTimer = (function() {
        var localSetTimeout,
            localClearTimeout = noop;
        if (!!root.setTimeout) {
          localSetTimeout = root.setTimeout;
          localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
          localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn();
          };
        } else {
          throw new NotSupportedError();
        }
        return {
          setTimeout: localSetTimeout,
          clearTimeout: localClearTimeout
        };
      }());
      var localSetTimeout = localTimer.setTimeout,
          localClearTimeout = localTimer.clearTimeout;
      (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
          delete tasksByHandle[handle];
        };
        function runTask(handle) {
          if (currentlyRunning) {
            localSetTimeout(function() {
              runTask(handle);
            }, 0);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunning = true;
              var result = tryCatch(task)();
              clearMethod(handle);
              currentlyRunning = false;
              if (result === errorObj) {
                return thrower(result.e);
              }
            }
          }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
          if (!root.postMessage || root.importScripts) {
            return false;
          }
          var isAsync = false,
              oldHandler = root.onmessage;
          root.onmessage = function() {
            isAsync = true;
          };
          root.postMessage('', '*');
          root.onmessage = oldHandler;
          return isAsync;
        }
        if (isFunction(setImmediate)) {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
              runTask(id);
            });
            return id;
          };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
              runTask(id);
            });
            return id;
          };
        } else if (postMessageSupported()) {
          var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
          function onGlobalPostMessage(event) {
            if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
              runTask(event.data.substring(MSG_PREFIX.length));
            }
          }
          if (root.addEventListener) {
            root.addEventListener('message', onGlobalPostMessage, false);
          } else if (root.attachEvent) {
            root.attachEvent('onmessage', onGlobalPostMessage);
          } else {
            root.onmessage = onGlobalPostMessage;
          }
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.postMessage(MSG_PREFIX + currentId, '*');
            return id;
          };
        } else if (!!root.MessageChannel) {
          var channel = new root.MessageChannel();
          channel.port1.onmessage = function(e) {
            runTask(e.data);
          };
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            channel.port2.postMessage(id);
            return id;
          };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
          scheduleMethod = function(action) {
            var scriptElement = root.document.createElement('script');
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
              runTask(id);
              scriptElement.onreadystatechange = null;
              scriptElement.parentNode.removeChild(scriptElement);
              scriptElement = null;
            };
            root.document.documentElement.appendChild(scriptElement);
            return id;
          };
        } else {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            localSetTimeout(function() {
              runTask(id);
            }, 0);
            return id;
          };
        }
      }());
      var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = (function() {
        function scheduleNow(state, action) {
          var scheduler = this,
              disposable = new SingleAssignmentDisposable();
          var id = scheduleMethod(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          });
          return new CompositeDisposable(disposable, disposableCreate(function() {
            clearMethod(id);
          }));
        }
        function scheduleRelative(state, dueTime, action) {
          var scheduler = this,
              dt = Scheduler.normalize(dueTime),
              disposable = new SingleAssignmentDisposable();
          if (dt === 0) {
            return scheduler.scheduleWithState(state, action);
          }
          var id = localSetTimeout(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          }, dt);
          return new CompositeDisposable(disposable, disposableCreate(function() {
            localClearTimeout(id);
          }));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      })();
      var CatchScheduler = (function(__super__) {
        function scheduleNow(state, action) {
          return this._scheduler.scheduleWithState(state, this._wrap(action));
        }
        function scheduleRelative(state, dueTime, action) {
          return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
        }
        inherits(CatchScheduler, __super__);
        function CatchScheduler(scheduler, handler) {
          this._scheduler = scheduler;
          this._handler = handler;
          this._recursiveOriginal = null;
          this._recursiveWrapper = null;
          __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
        }
        CatchScheduler.prototype._clone = function(scheduler) {
          return new CatchScheduler(scheduler, this._handler);
        };
        CatchScheduler.prototype._wrap = function(action) {
          var parent = this;
          return function(self, state) {
            try {
              return action(parent._getRecursiveWrapper(self), state);
            } catch (e) {
              if (!parent._handler(e)) {
                throw e;
              }
              return disposableEmpty;
            }
          };
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
          if (this._recursiveOriginal !== scheduler) {
            this._recursiveOriginal = scheduler;
            var wrapper = this._clone(scheduler);
            wrapper._recursiveOriginal = scheduler;
            wrapper._recursiveWrapper = wrapper;
            this._recursiveWrapper = wrapper;
          }
          return this._recursiveWrapper;
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          var self = this,
              failed = false,
              d = new SingleAssignmentDisposable();
          d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
            if (failed) {
              return null;
            }
            try {
              return action(state1);
            } catch (e) {
              failed = true;
              if (!self._handler(e)) {
                throw e;
              }
              d.dispose();
              return null;
            }
          }));
          return d;
        };
        return CatchScheduler;
      }(Scheduler));
      var Notification = Rx.Notification = (function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
          this.kind = kind;
          this.value = value;
          this.exception = exception;
          this._accept = accept;
          this._acceptObservable = acceptObservable;
          this.toString = toString;
        }
        Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
          return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function(scheduler) {
          var self = this;
          isScheduler(scheduler) || (scheduler = immediateScheduler);
          return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithState(self, function(_, notification) {
              notification._acceptObservable(observer);
              notification.kind === 'N' && observer.onCompleted();
            });
          });
        };
        return Notification;
      })();
      var notificationCreateOnNext = Notification.createOnNext = (function() {
        function _accept(onNext) {
          return onNext(this.value);
        }
        function _acceptObservable(observer) {
          return observer.onNext(this.value);
        }
        function toString() {
          return 'OnNext(' + this.value + ')';
        }
        return function(value) {
          return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnError = Notification.createOnError = (function() {
        function _accept(onNext, onError) {
          return onError(this.exception);
        }
        function _acceptObservable(observer) {
          return observer.onError(this.exception);
        }
        function toString() {
          return 'OnError(' + this.exception + ')';
        }
        return function(e) {
          return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
        function _accept(onNext, onError, onCompleted) {
          return onCompleted();
        }
        function _acceptObservable(observer) {
          return observer.onCompleted();
        }
        function toString() {
          return 'OnCompleted()';
        }
        return function() {
          return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
      }());
      var Observer = Rx.Observer = function() {};
      Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
          return n.accept(observer);
        };
      };
      Observer.prototype.asObserver = function() {
        return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
      };
      Observer.prototype.checked = function() {
        return new CheckedObserver(this);
      };
      var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
      };
      Observer.fromNotifier = function(handler, thisArg) {
        return new AnonymousObserver(function(x) {
          return handler.call(thisArg, notificationCreateOnNext(x));
        }, function(e) {
          return handler.call(thisArg, notificationCreateOnError(e));
        }, function() {
          return handler.call(thisArg, notificationCreateOnCompleted());
        });
      };
      Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this);
      };
      Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
      };
      var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
          this.isStopped = false;
          __super__.call(this);
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
          if (!this.isStopped) {
            this.next(value);
          }
        };
        AbstractObserver.prototype.onError = function(error) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(error);
          }
        };
        AbstractObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.completed();
          }
        };
        AbstractObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(e);
            return true;
          }
          return false;
        };
        return AbstractObserver;
      }(Observer));
      var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
          __super__.call(this);
          this._onNext = onNext;
          this._onError = onError;
          this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function(value) {
          this._onNext(value);
        };
        AnonymousObserver.prototype.error = function(error) {
          this._onError(error);
        };
        AnonymousObserver.prototype.completed = function() {
          this._onCompleted();
        };
        return AnonymousObserver;
      }(AbstractObserver));
      var CheckedObserver = (function(__super__) {
        inherits(CheckedObserver, __super__);
        function CheckedObserver(observer) {
          __super__.call(this);
          this._observer = observer;
          this._state = 0;
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
          this.checkAccess();
          var res = tryCatch(this._observer.onNext).call(this._observer, value);
          this._state = 0;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onError = function(err) {
          this.checkAccess();
          var res = tryCatch(this._observer.onError).call(this._observer, err);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onCompleted = function() {
          this.checkAccess();
          var res = tryCatch(this._observer.onCompleted).call(this._observer);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.checkAccess = function() {
          if (this._state === 1) {
            throw new Error('Re-entrancy detected');
          }
          if (this._state === 2) {
            throw new Error('Observer completed');
          }
          if (this._state === 0) {
            this._state = 1;
          }
        };
        return CheckedObserver;
      }(Observer));
      var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
          __super__.call(this);
          this.scheduler = scheduler;
          this.observer = observer;
          this.isAcquired = false;
          this.hasFaulted = false;
          this.queue = [];
          this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function(value) {
          var self = this;
          this.queue.push(function() {
            self.observer.onNext(value);
          });
        };
        ScheduledObserver.prototype.error = function(e) {
          var self = this;
          this.queue.push(function() {
            self.observer.onError(e);
          });
        };
        ScheduledObserver.prototype.completed = function() {
          var self = this;
          this.queue.push(function() {
            self.observer.onCompleted();
          });
        };
        ScheduledObserver.prototype.ensureActive = function() {
          var isOwner = false,
              parent = this;
          if (!this.hasFaulted && this.queue.length > 0) {
            isOwner = !this.isAcquired;
            this.isAcquired = true;
          }
          if (isOwner) {
            this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
              var work;
              if (parent.queue.length > 0) {
                work = parent.queue.shift();
              } else {
                parent.isAcquired = false;
                return;
              }
              try {
                work();
              } catch (ex) {
                parent.queue = [];
                parent.hasFaulted = true;
                throw ex;
              }
              self();
            }));
          }
        };
        ScheduledObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.disposable.dispose();
        };
        return ScheduledObserver;
      }(AbstractObserver));
      var ObserveOnObserver = (function(__super__) {
        inherits(ObserveOnObserver, __super__);
        function ObserveOnObserver(scheduler, observer, cancel) {
          __super__.call(this, scheduler, observer);
          this._cancel = cancel;
        }
        ObserveOnObserver.prototype.next = function(value) {
          __super__.prototype.next.call(this, value);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.error = function(e) {
          __super__.prototype.error.call(this, e);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.completed = function() {
          __super__.prototype.completed.call(this);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this._cancel && this._cancel.dispose();
          this._cancel = null;
        };
        return ObserveOnObserver;
      })(ScheduledObserver);
      var observableProto;
      var Observable = Rx.Observable = (function() {
        function Observable(subscribe) {
          if (Rx.config.longStackSupport && hasStacks) {
            try {
              throw new Error();
            } catch (e) {
              this.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
            var self = this;
            this._subscribe = function(observer) {
              var oldOnError = observer.onError.bind(observer);
              observer.onError = function(err) {
                makeStackTraceLong(err, self);
                oldOnError(err);
              };
              return subscribe.call(self, observer);
            };
          } else {
            this._subscribe = subscribe;
          }
        }
        observableProto = Observable.prototype;
        observableProto.subscribe = observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
          return this._subscribe(typeof observerOrOnNext === 'object' ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
          return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
            onNext.call(thisArg, x);
          } : onNext));
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
          return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
            onError.call(thisArg, e);
          } : onError));
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
          return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
            onCompleted.call(thisArg);
          } : onCompleted));
        };
        return Observable;
      })();
      var ObservableBase = Rx.ObservableBase = (function(__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.subscribeCore).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function ObservableBase() {
          __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
      }(Observable));
      var Enumerable = Rx.internals.Enumerable = function() {};
      var ConcatEnumerableObservable = (function(__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function(e, self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        function InnerObserver(o, s, e) {
          this.o = o;
          this.s = s;
          this.e = e;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.s(this.e);
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
            return true;
          }
          return false;
        };
        return ConcatEnumerableObservable;
      }(ObservableBase));
      Enumerable.prototype.concat = function() {
        return new ConcatEnumerableObservable(this);
      };
      var CatchErrorObservable = (function(__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function(o) {
          var e = this.sources[$iterator$]();
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return lastException !== null ? o.onError(lastException) : o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, self, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return CatchErrorObservable;
      }(ObservableBase));
      Enumerable.prototype.catchError = function() {
        return new CatchErrorObservable(this);
      };
      Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
          var exceptions = new Subject(),
              notifier = new Subject(),
              handled = notificationHandler(exceptions),
              notificationDisposable = handled.subscribe(notifier);
          var e = sources[$iterator$]();
          var isDisposed,
              lastException,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursive(function(self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              if (lastException) {
                o.onError(lastException);
              } else {
                o.onCompleted();
              }
              return;
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var outer = new SingleAssignmentDisposable();
            var inner = new SingleAssignmentDisposable();
            subscription.setDisposable(new CompositeDisposable(inner, outer));
            outer.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(exn) {
              inner.setDisposable(notifier.subscribe(self, function(ex) {
                o.onError(ex);
              }, function() {
                o.onCompleted();
              }));
              exceptions.onNext(exn);
            }, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        });
      };
      var RepeatEnumerable = (function(__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
          this.v = v;
          this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function() {
          return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
          this.v = p.v;
          this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function() {
          if (this.l === 0) {
            return doneEnumerator;
          }
          if (this.l > 0) {
            this.l--;
          }
          return {
            done: false,
            value: this.v
          };
        };
        return RepeatEnumerable;
      }(Enumerable));
      var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
      };
      var OfEnumerable = (function(__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
          this.s = s;
          this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function() {
          return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
          this.i = -1;
          this.s = p.s;
          this.l = this.s.length;
          this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function() {
          return ++this.i < this.l ? {
            done: false,
            value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
          } : doneEnumerator;
        };
        return OfEnumerable;
      }(Enumerable));
      var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
      };
      observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(new ObserveOnObserver(scheduler, observer));
        }, source);
      };
      observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              d = new SerialDisposable();
          d.setDisposable(m);
          m.setDisposable(scheduler.schedule(function() {
            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
          }));
          return d;
        }, source);
      };
      var FromPromiseObservable = (function(__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
          this.p = p;
          __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function(o) {
          this.p.then(function(data) {
            o.onNext(data);
            o.onCompleted();
          }, function(err) {
            o.onError(err);
          });
          return disposableEmpty;
        };
        return FromPromiseObservable;
      }(ObservableBase));
      var observableFromPromise = Observable.fromPromise = function(promise) {
        return new FromPromiseObservable(promise);
      };
      observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
          throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function(resolve, reject) {
          var value,
              hasValue = false;
          source.subscribe(function(v) {
            value = v;
            hasValue = true;
          }, reject, function() {
            hasValue && resolve(value);
          });
        });
      };
      var ToArrayObservable = (function(__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.a = [];
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.a.push(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onNext(this.a);
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return ToArrayObservable;
      }(ObservableBase));
      observableProto.toArray = function() {
        return new ToArrayObservable(this);
      };
      Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
      };
      var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
          var result;
          try {
            result = observableFactory();
          } catch (e) {
            return observableThrow(e).subscribe(observer);
          }
          isPromise(result) && (result = observableFromPromise(result));
          return result.subscribe(observer);
        });
      };
      var EmptyObservable = (function(__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
          this.scheduler = scheduler;
          __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
          var sink = new EmptySink(observer, this);
          return sink.run();
        };
        function EmptySink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          state.onCompleted();
        }
        EmptySink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
      }(ObservableBase));
      var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new EmptyObservable(scheduler);
      };
      var FromObservable = (function(__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
          this.iterable = iterable;
          this.mapper = mapper;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromSink(observer, this);
          return sink.run();
        };
        return FromObservable;
      }(ObservableBase));
      var FromSink = (function() {
        function FromSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        FromSink.prototype.run = function() {
          var list = Object(this.parent.iterable),
              it = getIterable(list),
              observer = this.observer,
              mapper = this.parent.mapper;
          function loopRecursive(i, recurse) {
            try {
              var next = it.next();
            } catch (e) {
              return observer.onError(e);
            }
            if (next.done) {
              return observer.onCompleted();
            }
            var result = next.value;
            if (mapper) {
              try {
                result = mapper(result, i);
              } catch (e) {
                return observer.onError(e);
              }
            }
            observer.onNext(result);
            recurse(i + 1);
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
      }());
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function StringIterable(str) {
        this._s = s;
      }
      StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s);
      };
      function StringIterator(str) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
      }
      StringIterator.prototype[$iterator$] = function() {
        return this;
      };
      StringIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._s.charAt(this._i++)
        } : doneEnumerator;
      };
      function ArrayIterable(a) {
        this._a = a;
      }
      ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a);
      };
      function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
      }
      ArrayIterator.prototype[$iterator$] = function() {
        return this;
      };
      ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._a[this._i++]
        } : doneEnumerator;
      };
      function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
      }
      function isNan(n) {
        return n !== n;
      }
      function getIterable(o) {
        var i = o[$iterator$],
            it;
        if (!i && typeof o === 'string') {
          it = new StringIterable(o);
          return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
          it = new ArrayIterable(o);
          return it[$iterator$]();
        }
        if (!i) {
          throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
      }
      function sign(value) {
        var number = +value;
        if (number === 0) {
          return number;
        }
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      }
      function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
          return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
          return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
          return 0;
        }
        if (len > maxSafeInteger) {
          return maxSafeInteger;
        }
        return len;
      }
      var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
          throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
          throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
          var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
      };
      var FromArrayObservable = (function(__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
          this.args = args;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromArraySink(observer, this);
          return sink.run();
        };
        return FromArrayObservable;
      }(ObservableBase));
      function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            observer.onNext(args[i]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      };
      Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
          var first = true;
          return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
            var hasResult,
                result;
            try {
              if (first) {
                first = false;
              } else {
                state = iterate(state);
              }
              hasResult = condition(state);
              hasResult && (result = resultSelector(state));
            } catch (e) {
              return o.onError(e);
            }
            if (hasResult) {
              o.onNext(result);
              self(state);
            } else {
              o.onCompleted();
            }
          });
        });
      };
      var NeverObservable = (function(__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
          __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
          return disposableEmpty;
        };
        return NeverObservable;
      }(ObservableBase));
      var observableNever = Observable.never = function() {
        return new NeverObservable();
      };
      function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      }
      Observable.of = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
      };
      Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
      };
      var PairsObservable = (function(__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
          this.obj = obj;
          this.keys = Object.keys(obj);
          this.scheduler = scheduler;
          __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
          var sink = new PairsSink(observer, this);
          return sink.run();
        };
        return PairsObservable;
      }(ObservableBase));
      function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            var key = keys[i];
            observer.onNext([key, obj[key]]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
      };
      var RangeObservable = (function(__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
          this.start = start;
          this.rangeCount = count;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
          var sink = new RangeSink(observer, this);
          return sink.run();
        };
        return RangeObservable;
      }(ObservableBase));
      var RangeSink = (function() {
        function RangeSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        RangeSink.prototype.run = function() {
          var start = this.parent.start,
              count = this.parent.rangeCount,
              observer = this.observer;
          function loopRecursive(i, recurse) {
            if (i < count) {
              observer.onNext(start + i);
              recurse(i + 1);
            } else {
              observer.onCompleted();
            }
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
      }());
      Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
      };
      var RepeatObservable = (function(__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
          this.value = value;
          this.repeatCount = repeatCount == null ? -1 : repeatCount;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
          var sink = new RepeatSink(observer, this);
          return sink.run();
        };
        return RepeatObservable;
      }(ObservableBase));
      function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;
        function loopRecursive(i, recurse) {
          if (i === -1 || i > 0) {
            observer.onNext(value);
            i > 0 && i--;
          }
          if (i === 0) {
            return observer.onCompleted();
          }
          recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
      };
      Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
      };
      var JustObservable = (function(__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
          this.value = value;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function(observer) {
          var sink = new JustSink(observer, this);
          return sink.run();
        };
        function JustSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          var value = state[0],
              observer = state[1];
          observer.onNext(value);
          observer.onCompleted();
        }
        JustSink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState([this.parent.value, this.observer], scheduleItem);
        };
        return JustObservable;
      }(ObservableBase));
      var observableReturn = Observable['return'] = Observable.just = Observable.returnValue = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
      };
      var ThrowObservable = (function(__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
          this.error = error;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function(o) {
          var sink = new ThrowSink(o, this);
          return sink.run();
        };
        function ThrowSink(o, p) {
          this.o = o;
          this.p = p;
        }
        function scheduleItem(s, state) {
          var e = state[0],
              o = state[1];
          o.onError(e);
        }
        ThrowSink.prototype.run = function() {
          return this.p.scheduler.scheduleWithState([this.p.error, this.o], scheduleItem);
        };
        return ThrowObservable;
      }(ObservableBase));
      var observableThrow = Observable['throw'] = Observable.throwError = Observable.throwException = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
      };
      Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(observer) {
          var disposable = disposableEmpty,
              resource,
              source;
          try {
            resource = resourceFactory();
            resource && (disposable = resource);
            source = observableFactory(resource);
          } catch (exception) {
            return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
          }
          return new CompositeDisposable(source.subscribe(observer), disposable);
        });
      };
      observableProto.amb = function(rightSource) {
        var leftSource = this;
        return new AnonymousObservable(function(observer) {
          var choice,
              leftChoice = 'L',
              rightChoice = 'R',
              leftSubscription = new SingleAssignmentDisposable(),
              rightSubscription = new SingleAssignmentDisposable();
          isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
          function choiceL() {
            if (!choice) {
              choice = leftChoice;
              rightSubscription.dispose();
            }
          }
          function choiceR() {
            if (!choice) {
              choice = rightChoice;
              leftSubscription.dispose();
            }
          }
          leftSubscription.setDisposable(leftSource.subscribe(function(left) {
            choiceL();
            choice === leftChoice && observer.onNext(left);
          }, function(err) {
            choiceL();
            choice === leftChoice && observer.onError(err);
          }, function() {
            choiceL();
            choice === leftChoice && observer.onCompleted();
          }));
          rightSubscription.setDisposable(rightSource.subscribe(function(right) {
            choiceR();
            choice === rightChoice && observer.onNext(right);
          }, function(err) {
            choiceR();
            choice === rightChoice && observer.onError(err);
          }, function() {
            choiceR();
            choice === rightChoice && observer.onCompleted();
          }));
          return new CompositeDisposable(leftSubscription, rightSubscription);
        });
      };
      Observable.amb = function() {
        var acc = observableNever(),
            items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        function func(previous, current) {
          return previous.amb(current);
        }
        for (var i = 0,
            len = items.length; i < len; i++) {
          acc = func(acc, items[i]);
        }
        return acc;
      };
      function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
          var d1 = new SingleAssignmentDisposable(),
              subscription = new SerialDisposable();
          subscription.setDisposable(d1);
          d1.setDisposable(source.subscribe(function(x) {
            o.onNext(x);
          }, function(e) {
            try {
              var result = handler(e);
            } catch (ex) {
              return o.onError(ex);
            }
            isPromise(result) && (result = observableFromPromise(result));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(result.subscribe(o));
          }, function(x) {
            o.onCompleted(x);
          }));
          return subscription;
        }, source);
      }
      observableProto['catch'] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
        return typeof handlerOrSecond === 'function' ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
      };
      var observableCatch = Observable.catchError = Observable['catch'] = Observable.catchException = function() {
        var items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        return enumerableOf(items).catchError();
      };
      observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          args[0].unshift(this);
        } else {
          args.unshift(this);
        }
        return combineLatest.apply(this, args);
      };
      var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              falseFactory = function() {
                return false;
              },
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              isDone = arrayInitialize(n, falseFactory),
              values = new Array(n);
          function next(i) {
            hasValue[i] = true;
            if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
              try {
                var res = resultSelector.apply(null, values);
              } catch (e) {
                return o.onError(e);
              }
              o.onNext(res);
            } else if (isDone.filter(function(x, j) {
              return j !== i;
            }).every(identity)) {
              o.onCompleted();
            }
          }
          function done(i) {
            isDone[i] = true;
            isDone.every(identity) && o.onCompleted();
          }
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                values[i] = x;
                next(i);
              }, function(e) {
                o.onError(e);
              }, function() {
                done(i);
              }));
              subscriptions[i] = sad;
            }(idx));
          }
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      observableProto.concat = function() {
        for (var args = [],
            i = 0,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
      };
      var ConcatObservable = (function(__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function(o) {
          var sink = new ConcatSink(this.sources, o);
          return sink.run();
        };
        function ConcatSink(sources, o) {
          this.sources = sources;
          this.o = o;
        }
        ConcatSink.prototype.run = function() {
          var isDisposed,
              subscription = new SerialDisposable(),
              sources = this.sources,
              length = sources.length,
              o = this.o;
          var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function(i, self) {
            if (isDisposed) {
              return;
            }
            if (i === length) {
              return o.onCompleted();
            }
            var currentValue = sources[i];
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              self(i + 1);
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return ConcatObservable;
      }(ObservableBase));
      var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(arguments.length);
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ConcatObservable(args);
      };
      observableProto.concatAll = observableProto.concatObservable = function() {
        return this.merge(1);
      };
      var MergeObservable = (function(__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
          this.source = source;
          this.maxConcurrent = maxConcurrent;
          __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable();
          g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
          return g;
        };
        return MergeObservable;
      }(ObservableBase));
      var MergeObserver = (function() {
        function MergeObserver(o, max, g) {
          this.o = o;
          this.max = max;
          this.g = g;
          this.done = false;
          this.q = [];
          this.activeCount = 0;
          this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(xs) && (xs = observableFromPromise(xs));
          sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          if (this.activeCount < this.max) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
          } else {
            this.q.push(innerSource);
          }
        };
        MergeObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.activeCount === 0 && this.o.onCompleted();
          }
        };
        MergeObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var parent = this.parent;
            parent.g.remove(this.sad);
            if (parent.q.length > 0) {
              parent.handleSubscribe(parent.q.shift());
            } else {
              parent.activeCount--;
              parent.done && parent.activeCount === 0 && parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeObserver;
      }());
      observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
      };
      var observableMerge = Observable.merge = function() {
        var scheduler,
            sources = [],
            i,
            len = arguments.length;
        if (!arguments[0]) {
          scheduler = immediateScheduler;
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else if (isScheduler(arguments[0])) {
          scheduler = arguments[0];
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else {
          scheduler = immediateScheduler;
          for (i = 0; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        if (Array.isArray(sources[0])) {
          sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
      };
      var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
      };
      CompositeError.prototype = Error.prototype;
      Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          var len = arguments.length;
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function(o) {
          var group = new CompositeDisposable(),
              m = new SingleAssignmentDisposable(),
              isStopped = false,
              errors = [];
          function setCompletion() {
            if (errors.length === 0) {
              o.onCompleted();
            } else if (errors.length === 1) {
              o.onError(errors[0]);
            } else {
              o.onError(new CompositeError(errors));
            }
          }
          group.add(m);
          m.setDisposable(source.subscribe(function(innerSource) {
            var innerSubscription = new SingleAssignmentDisposable();
            group.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              errors.push(e);
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }, function() {
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }));
          }, function(e) {
            errors.push(e);
            isStopped = true;
            group.length === 1 && setCompletion();
          }, function() {
            isStopped = true;
            group.length === 1 && setCompletion();
          }));
          return group;
        });
      };
      var MergeAllObservable = (function(__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable(),
              m = new SingleAssignmentDisposable();
          g.add(m);
          m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
          return g;
        };
        function MergeAllObserver(o, g) {
          this.o = o;
          this.g = g;
          this.isStopped = false;
          this.done = false;
        }
        MergeAllObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)));
        };
        MergeAllObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeAllObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.g.length === 1 && this.o.onCompleted();
          }
        };
        MergeAllObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, g, sad) {
          this.parent = parent;
          this.g = g;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            var parent = this.parent;
            this.isStopped = true;
            parent.g.remove(this.sad);
            parent.done && parent.g.length === 1 && parent.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeAllObservable;
      }(ObservableBase));
      observableProto.mergeAll = observableProto.mergeObservable = function() {
        return new MergeAllObservable(this);
      };
      observableProto.onErrorResumeNext = function(second) {
        if (!second) {
          throw new Error('Second observable is required');
        }
        return onErrorResumeNext([this, second]);
      };
      var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        return new AnonymousObservable(function(observer) {
          var pos = 0,
              subscription = new SerialDisposable(),
              cancelable = immediateScheduler.scheduleRecursive(function(self) {
                var current,
                    d;
                if (pos < sources.length) {
                  current = sources[pos++];
                  isPromise(current) && (current = observableFromPromise(current));
                  d = new SingleAssignmentDisposable();
                  subscription.setDisposable(d);
                  d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
                } else {
                  observer.onCompleted();
                }
              });
          return new CompositeDisposable(subscription, cancelable);
        });
      };
      observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var isOpen = false;
          var disposables = new CompositeDisposable(source.subscribe(function(left) {
            isOpen && o.onNext(left);
          }, function(e) {
            o.onError(e);
          }, function() {
            isOpen && o.onCompleted();
          }));
          isPromise(other) && (other = observableFromPromise(other));
          var rightSubscription = new SingleAssignmentDisposable();
          disposables.add(rightSubscription);
          rightSubscription.setDisposable(other.subscribe(function() {
            isOpen = true;
            rightSubscription.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            rightSubscription.dispose();
          }));
          return disposables;
        }, source);
      };
      var SwitchObservable = (function(__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function(o) {
          var inner = new SerialDisposable(),
              s = this.source.subscribe(new SwitchObserver(o, inner));
          return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
          this.o = o;
          this.inner = inner;
          this.stopped = false;
          this.latest = 0;
          this.hasLatest = false;
          this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          var d = new SingleAssignmentDisposable(),
              id = ++this.latest;
          this.hasLatest = true;
          this.inner.setDisposable(d);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        SwitchObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.stopped = true;
            !this.hasLatest && this.o.onCompleted();
          }
        };
        SwitchObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, id) {
          this.parent = parent;
          this.id = id;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.latest === this.id && this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            if (this.parent.latest === this.id) {
              this.parent.hasLatest = false;
              this.parent.isStopped && this.parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return SwitchObservable;
      }(ObservableBase));
      observableProto['switch'] = observableProto.switchLatest = function() {
        return new SwitchObservable(this);
      };
      var TakeUntilObservable = (function(__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
          this.source = source;
          this.other = isPromise(other) ? observableFromPromise(other) : other;
          __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function(o) {
          return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TakeUntilObservable;
      }(ObservableBase));
      observableProto.takeUntil = function(other) {
        return new TakeUntilObservable(this, other);
      };
      function falseFactory() {
        return false;
      }
      observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop(),
            source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(observer) {
          var n = args.length,
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              values = new Array(n);
          var subscriptions = new Array(n + 1);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var other = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(other) && (other = observableFromPromise(other));
              sad.setDisposable(other.subscribe(function(x) {
                values[i] = x;
                hasValue[i] = true;
                hasValueAll = hasValue.every(identity);
              }, function(e) {
                observer.onError(e);
              }, noop));
              subscriptions[i] = sad;
            }(idx));
          }
          var sad = new SingleAssignmentDisposable();
          sad.setDisposable(source.subscribe(function(x) {
            var allValues = [x].concat(values);
            if (!hasValueAll) {
              return;
            }
            var res = tryCatch(resultSelector).apply(null, allValues);
            if (res === errorObj) {
              return observer.onError(res.e);
            }
            observer.onNext(res);
          }, function(e) {
            observer.onError(e);
          }, function() {
            observer.onCompleted();
          }));
          subscriptions[n] = sad;
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(o) {
          var index = 0,
              len = second.length;
          return first.subscribe(function(left) {
            if (index < len) {
              var right = second[index++],
                  res = tryCatch(resultSelector)(left, right);
              if (res === errorObj) {
                return o.onError(res.e);
              }
              o.onNext(res);
            } else {
              o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, first);
      }
      function falseFactory() {
        return false;
      }
      function emptyArrayFactory() {
        return [];
      }
      observableProto.zip = function() {
        if (Array.isArray(arguments[0])) {
          return zipArray.apply(this, arguments);
        }
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var parent = this,
            resultSelector = args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              queues = arrayInitialize(n, emptyArrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var queuedValues = queues.map(function(x) {
                    return x.shift();
                  }),
                      res = tryCatch(resultSelector).apply(parent, queuedValues);
                  if (res === errorObj) {
                    return o.onError(res.e);
                  }
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
              subscriptions[i] = sad;
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        }, parent);
      };
      Observable.zip = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
      };
      function falseFactory() {
        return false;
      }
      function arrayFactory() {
        return [];
      }
      Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          var len = arguments.length;
          sources = new Array(len);
          for (var i = 0; i < len; i++) {
            sources[i] = arguments[i];
          }
        }
        return new AnonymousObservable(function(o) {
          var n = sources.length,
              queues = arrayInitialize(n, arrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              subscriptions[i] = new SingleAssignmentDisposable();
              subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var res = queues.map(function(x) {
                    return x.shift();
                  });
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  return o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        });
      };
      observableProto.asObservable = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(o);
        }, source);
      };
      observableProto.bufferWithCount = function(count, skip) {
        if (typeof skip !== 'number') {
          skip = count;
        }
        return this.windowWithCount(count, skip).selectMany(function(x) {
          return x.toArray();
        }).where(function(x) {
          return x.length > 0;
        });
      };
      observableProto.dematerialize = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(function(x) {
            return x.accept(o);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      observableProto.distinctUntilChanged = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hasCurrentKey = false,
              currentKey;
          return source.subscribe(function(value) {
            var key = value;
            if (keySelector) {
              key = tryCatch(keySelector)(value);
              if (key === errorObj) {
                return o.onError(key.e);
              }
            }
            if (hasCurrentKey) {
              var comparerEquals = tryCatch(comparer)(currentKey, key);
              if (comparerEquals === errorObj) {
                return o.onError(comparerEquals.e);
              }
            }
            if (!hasCurrentKey || !comparerEquals) {
              hasCurrentKey = true;
              currentKey = key;
              o.onNext(value);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var TapObservable = (function(__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
          this.source = source;
          this.t = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop, onCompleted || noop) : observerOrOnNext;
          __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.t));
        };
        function InnerObserver(o, t) {
          this.o = o;
          this.t = t;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var res = tryCatch(this.t.onNext).call(this.t, x);
          if (res === errorObj) {
            this.o.onError(res.e);
          }
          this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onError).call(this.t, err);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onCompleted).call(this.t);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TapObservable;
      }(ObservableBase));
      observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
      };
      observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext);
      };
      observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError);
      };
      observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted);
      };
      observableProto['finally'] = observableProto.ensure = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var subscription;
          try {
            subscription = source.subscribe(observer);
          } catch (e) {
            action();
            throw e;
          }
          return disposableCreate(function() {
            try {
              subscription.dispose();
            } catch (e) {
              throw e;
            } finally {
              action();
            }
          });
        }, this);
      };
      observableProto.finallyAction = function(action) {
        return this.ensure(action);
      };
      var IgnoreElementsObservable = (function(__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true;
          }
          return false;
        };
        return IgnoreElementsObservable;
      }(ObservableBase));
      observableProto.ignoreElements = function() {
        return new IgnoreElementsObservable(this);
      };
      observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(function(value) {
            observer.onNext(notificationCreateOnNext(value));
          }, function(e) {
            observer.onNext(notificationCreateOnError(e));
            observer.onCompleted();
          }, function() {
            observer.onNext(notificationCreateOnCompleted());
            observer.onCompleted();
          });
        }, source);
      };
      observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
      };
      observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
      };
      observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
      };
      var ScanObservable = (function(__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
          this.source = source;
          this.accumulator = accumulator;
          this.hasSeed = hasSeed;
          this.seed = seed;
          __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function(observer) {
          return this.source.subscribe(new ScanObserver(observer, this));
        };
        return ScanObservable;
      }(ObservableBase));
      function ScanObserver(observer, parent) {
        this.observer = observer;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      ScanObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return;
        }
        !this.hasValue && (this.hasValue = true);
        try {
          if (this.hasAccumulation) {
            this.accumulation = this.accumulator(this.accumulation, x);
          } else {
            this.accumulation = this.hasSeed ? this.accumulator(this.seed, x) : x;
            this.hasAccumulation = true;
          }
        } catch (e) {
          return this.observer.onError(e);
        }
        this.observer.onNext(this.accumulation);
      };
      ScanObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
        }
      };
      ScanObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          !this.hasValue && this.hasSeed && this.observer.onNext(this.seed);
          this.observer.onCompleted();
        }
      };
      ScanObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      ScanObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
          return true;
        }
        return false;
      };
      observableProto.scan = function() {
        var hasSeed = false,
            seed,
            accumulator,
            source = this;
        if (arguments.length === 2) {
          hasSeed = true;
          seed = arguments[0];
          accumulator = arguments[1];
        } else {
          accumulator = arguments[0];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
      };
      observableProto.skipLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && o.onNext(q.shift());
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.startWith = function() {
        var values,
            scheduler,
            start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
          scheduler = arguments[0];
          start = 1;
        } else {
          scheduler = immediateScheduler;
        }
        for (var args = [],
            i = start,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return enumerableOf([observableFromArray(args, scheduler), this]).concat();
      };
      observableProto.takeLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onNext(q);
            o.onCompleted();
          });
        }, source);
      };
      observableProto.windowWithCount = function(count, skip) {
        var source = this;
        +count || (count = 0);
        Math.abs(count) === Infinity && (count = 0);
        if (count <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        skip == null && (skip = count);
        +skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              refCountDisposable = new RefCountDisposable(m),
              n = 0,
              q = [];
          function createWindow() {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          createWindow();
          m.setDisposable(source.subscribe(function(x) {
            for (var i = 0,
                len = q.length; i < len; i++) {
              q[i].onNext(x);
            }
            var c = n - count + 1;
            c >= 0 && c % skip === 0 && q.shift().onCompleted();
            ++n % skip === 0 && createWindow();
          }, function(e) {
            while (q.length > 0) {
              q.shift().onError(e);
            }
            observer.onError(e);
          }, function() {
            while (q.length > 0) {
              q.shift().onCompleted();
            }
            observer.onCompleted();
          }));
          return refCountDisposable;
        }, source);
      };
      function concatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).concatAll();
      }
      observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.concatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          });
        }
        return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
          return selector;
        });
      };
      observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNextFunc(x, index++);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onErrorFunc(err);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompletedFunc();
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, this).concatAll();
      };
      observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
          var found = false;
          return source.subscribe(function(x) {
            found = true;
            observer.onNext(x);
          }, function(e) {
            observer.onError(e);
          }, function() {
            !found && observer.onNext(defaultValue);
            observer.onCompleted();
          });
        }, source);
      };
      function arrayIndexOfComparer(array, item, comparer) {
        for (var i = 0,
            len = array.length; i < len; i++) {
          if (comparer(array[i], item)) {
            return i;
          }
        }
        return -1;
      }
      function HashSet(comparer) {
        this.comparer = comparer;
        this.set = [];
      }
      HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue;
      };
      observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hashSet = new HashSet(comparer);
          return source.subscribe(function(x) {
            var key = x;
            if (keySelector) {
              try {
                key = keySelector(x);
              } catch (e) {
                o.onError(e);
                return;
              }
            }
            hashSet.push(key) && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var MapObservable = (function(__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
          this.source = source;
          this.selector = bindCallback(selector, thisArg, 3);
          __super__.call(this);
        }
        function innerMap(selector, self) {
          return function(x, i, o) {
            return selector.call(this, self.selector(x, i, o), i, o);
          };
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
          return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
          this.o = o;
          this.selector = selector;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var result = tryCatch(this.selector)(x, this.i++, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return MapObservable;
      }(ObservableBase));
      observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function() {
          return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
      };
      observableProto.pluck = function() {
        var args = arguments,
            len = arguments.length;
        if (len === 0) {
          throw new Error('List of properties cannot be empty.');
        }
        return this.map(function(x) {
          var currentProp = x;
          for (var i = 0; i < len; i++) {
            var p = currentProp[args[i]];
            if (typeof p !== 'undefined') {
              currentProp = p;
            } else {
              return undefined;
            }
          }
          return currentProp;
        });
      };
      observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNext.call(thisArg, x, index++);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onError.call(thisArg, err);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompleted.call(thisArg);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, source).mergeAll();
      };
      function flatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).mergeAll();
      }
      observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.flatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          }, thisArg);
        }
        return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
          return selector;
        });
      };
      observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
        return this.select(selector, thisArg).switchLatest();
      };
      var SkipObservable = (function(__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
          this.source = source;
          this.skipCount = count;
          __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
          this.c = c;
          this.r = c;
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          if (this.r <= 0) {
            this.o.onNext(x);
          } else {
            this.r--;
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return SkipObservable;
      }(ObservableBase));
      observableProto.skip = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
      };
      observableProto.skipWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = false;
          return source.subscribe(function(x) {
            if (!running) {
              try {
                running = !callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return;
              }
            }
            running && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.take = function(count, scheduler) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
          return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var remaining = count;
          return source.subscribe(function(x) {
            if (remaining-- > 0) {
              o.onNext(x);
              remaining <= 0 && o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = true;
          return source.subscribe(function(x) {
            if (running) {
              try {
                running = callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return;
              }
              if (running) {
                o.onNext(x);
              } else {
                o.onCompleted();
              }
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      var FilterObservable = (function(__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
          this.source = source;
          this.predicate = bindCallback(predicate, thisArg, 3);
          __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
          return function(x, i, o) {
            return self.predicate(x, i, o) && predicate.call(this, x, i, o);
          };
        }
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
          return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
          this.o = o;
          this.predicate = predicate;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
          if (shouldYield === errorObj) {
            return this.o.onError(shouldYield.e);
          }
          shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return FilterObservable;
      }(ObservableBase));
      observableProto.filter = observableProto.where = function(predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
      };
      observableProto.transduce = function(transducer) {
        var source = this;
        function transformForObserver(o) {
          return {
            '@@transducer/init': function() {
              return o;
            },
            '@@transducer/step': function(obs, input) {
              return obs.onNext(input);
            },
            '@@transducer/result': function(obs) {
              return obs.onCompleted();
            }
          };
        }
        return new AnonymousObservable(function(o) {
          var xform = transducer(transformForObserver(o));
          return source.subscribe(function(v) {
            try {
              xform['@@transducer/step'](o, v);
            } catch (e) {
              o.onError(e);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            xform['@@transducer/result'](o);
          });
        }, source);
      };
      var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              subscribe = state[1];
          var sub = tryCatch(subscribe)(ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function AnonymousObservable(subscribe, parent) {
          this.source = parent;
          function s(observer) {
            var ado = new AutoDetachObserver(observer),
                state = [ado, subscribe];
            if (currentThreadScheduler.scheduleRequired()) {
              currentThreadScheduler.scheduleWithState(state, setDisposable);
            } else {
              setDisposable(null, state);
            }
            return ado;
          }
          __super__.call(this, s);
        }
        return AnonymousObservable;
      }(Observable));
      var AutoDetachObserver = (function(__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
          __super__.call(this);
          this.observer = observer;
          this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
          var result = tryCatch(this.observer.onNext).call(this.observer, value);
          if (result === errorObj) {
            this.dispose();
            thrower(result.e);
          }
        };
        AutoDetachObserverPrototype.error = function(err) {
          var result = tryCatch(this.observer.onError).call(this.observer, err);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function() {
          var result = tryCatch(this.observer.onCompleted).call(this.observer);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
          this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function() {
          return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.m.dispose();
        };
        return AutoDetachObserver;
      }(AbstractObserver));
      var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      };
      InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
          var idx = this.subject.observers.indexOf(this.observer);
          this.subject.observers.splice(idx, 1);
          this.observer = null;
        }
      };
      var Subject = Rx.Subject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
            return disposableEmpty;
          }
          observer.onCompleted();
          return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
          __super__.call(this, subscribe);
          this.isDisposed = false, this.isStopped = false, this.observers = [];
          this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
          hasObservers: function() {
            return this.observers.length > 0;
          },
          onCompleted: function() {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onCompleted();
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.error = error;
              this.hasError = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (!this.isStopped) {
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onNext(value);
              }
            }
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
          }
        });
        Subject.create = function(observer, observable) {
          return new AnonymousSubject(observer, observable);
        };
        return Subject;
      }(Observable));
      var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
          } else if (this.hasValue) {
            observer.onNext(this.value);
            observer.onCompleted();
          } else {
            observer.onCompleted();
          }
          return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
          __super__.call(this, subscribe);
          this.isDisposed = false;
          this.isStopped = false;
          this.hasValue = false;
          this.observers = [];
          this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
          hasObservers: function() {
            checkDisposed(this);
            return this.observers.length > 0;
          },
          onCompleted: function() {
            var i,
                len;
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              var os = cloneArray(this.observers),
                  len = os.length;
              if (this.hasValue) {
                for (i = 0; i < len; i++) {
                  var o = os[i];
                  o.onNext(this.value);
                  o.onCompleted();
                }
              } else {
                for (i = 0; i < len; i++) {
                  os[i].onCompleted();
                }
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.hasError = true;
              this.error = error;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (this.isStopped) {
              return;
            }
            this.value = value;
            this.hasValue = true;
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
            this.exception = null;
            this.value = null;
          }
        });
        return AsyncSubject;
      }(Observable));
      var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
          return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
          this.observer = observer;
          this.observable = observable;
          __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
          onCompleted: function() {
            this.observer.onCompleted();
          },
          onError: function(error) {
            this.observer.onError(error);
          },
          onNext: function(value) {
            this.observer.onNext(value);
          }
        });
        return AnonymousSubject;
      }(Observable));
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function() {
          return Rx;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = Rx).Rx = Rx;
        } else {
          freeExports.Rx = Rx;
        }
      } else {
        root.Rx = Rx;
      }
      var rEndingLine = captureLine();
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/schedulers/ImmediateScheduler", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Disposable = Rx.Disposable;
  function ImmediateScheduler() {}
  ImmediateScheduler.prototype.schedule = function schedule(action) {
    action();
    return Disposable.empty;
  };
  ImmediateScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
    action(this, state);
    return Disposable.empty;
  };
  module.exports = ImmediateScheduler;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/ModelRoot", ["npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/hasOwn", "npm:falcor@0.1.13/lib/schedulers/ImmediateScheduler"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var hasOwn = require("npm:falcor@0.1.13/lib/support/hasOwn");
  var ImmediateScheduler = require("npm:falcor@0.1.13/lib/schedulers/ImmediateScheduler");
  function ModelRoot(o) {
    var options = o || {};
    this.syncRefCount = 0;
    this.expired = options.expired || [];
    this.unsafeMode = options.unsafeMode || false;
    this.collectionScheduler = options.collectionScheduler || new ImmediateScheduler();
    this.cache = {};
    if (isFunction(options.comparator)) {
      this.comparator = options.comparator;
    }
    if (isFunction(options.errorSelector)) {
      this.errorSelector = options.errorSelector;
    }
    if (isFunction(options.onChange)) {
      this.onChange = options.onChange;
    }
  }
  ModelRoot.prototype.errorSelector = function errorSelector(x, y) {
    return y;
  };
  ModelRoot.prototype.comparator = function comparator(a, b) {
    if (hasOwn(a, "value") && hasOwn(b, "value")) {
      return a.value === b.value;
    }
    return a === b;
  };
  module.exports = ModelRoot;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/ModelDataSourceAdapter", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function ModelDataSourceAdapter(model) {
    this._model = model._materialize().boxValues().treatErrorsAsValues();
  }
  ModelDataSourceAdapter.prototype.get = function get(pathSets) {
    return this._model.get.apply(this._model, pathSets)._toJSONG();
  };
  ModelDataSourceAdapter.prototype.set = function set(jsongResponse) {
    return this._model.set(jsongResponse)._toJSONG();
  };
  ModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {
    var params = [path, args, suffixes].concat(paths);
    return this._model.call.apply(this._model, params)._toJSONG();
  };
  module.exports = ModelDataSourceAdapter;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/errors/InvalidSourceError", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var NAME = "InvalidSourceError";
  function InvalidSourceError(error) {
    this.message = "An exception was thrown when making a request.";
    this.stack = (new Error()).stack;
    this.innerError = error;
  }
  InvalidSourceError.prototype = new Error();
  InvalidSourceError.prototype.name = NAME;
  InvalidSourceError.name = NAME;
  InvalidSourceError.is = function(e) {
    return e && e.name === NAME;
  };
  module.exports = InvalidSourceError;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/iterateKeySet", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  module.exports = function iterateKeySet(keySet, note) {
    if (note.isArray === undefined) {
      initializeNote(keySet, note);
    }
    if (note.isArray) {
      var nextValue;
      do {
        if (note.loaded && note.rangeOffset > note.to) {
          ++note.arrayOffset;
          note.loaded = false;
        }
        var idx = note.arrayOffset,
            length = keySet.length;
        if (idx >= length) {
          note.done = true;
          break;
        }
        var el = keySet[note.arrayOffset];
        var type = typeof el;
        if (type === 'object') {
          if (!note.loaded) {
            initializeRange(el, note);
          }
          if (note.empty) {
            continue;
          }
          nextValue = note.rangeOffset++;
        } else {
          ++note.arrayOffset;
          nextValue = el;
        }
      } while (nextValue === undefined);
      return nextValue;
    } else if (note.isObject) {
      if (!note.loaded) {
        initializeRange(keySet, note);
      }
      if (note.rangeOffset > note.to) {
        note.done = true;
        return undefined;
      }
      return note.rangeOffset++;
    } else {
      note.done = true;
      return keySet;
    }
  };
  function initializeRange(key, memo) {
    var from = memo.from = key.from || 0;
    var to = memo.to = key.to || (typeof key.length === 'number' && memo.from + key.length - 1 || 0);
    memo.rangeOffset = memo.from;
    memo.loaded = true;
    if (from > to) {
      memo.empty = true;
    }
  }
  function initializeNote(key, note) {
    note.done = false;
    var isObject = note.isObject = !!(key && typeof key === 'object');
    note.isArray = isObject && isArray(key);
    note.arrayOffset = 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/toTree", ["npm:falcor-path-utils@0.3.4/lib/iterateKeySet"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4/lib/iterateKeySet");
  var isArray = Array.isArray;
  module.exports = function toTree(paths) {
    return paths.reduce(function(acc, path) {
      innerToTree(acc, path, 0);
      return acc;
    }, {});
  };
  function innerToTree(seed, path, depth) {
    var keySet = path[depth];
    var iteratorNote = {};
    var key;
    var nextDepth = depth + 1;
    key = iterateKeySet(keySet, iteratorNote);
    do {
      var next = seed[key];
      if (!next) {
        if (nextDepth === path.length) {
          seed[key] = null;
        } else {
          next = seed[key] = {};
        }
      }
      if (nextDepth < path.length) {
        innerToTree(next, path, nextDepth);
      }
      if (!iteratorNote.done) {
        key = iterateKeySet(keySet, iteratorNote);
      }
    } while (!iteratorNote.done);
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/toTreeWithUnion", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/hasIntersection", ["npm:falcor-path-utils@0.3.4/lib/iterateKeySet"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4/lib/iterateKeySet");
  module.exports = function hasIntersection(tree, path, depth) {
    var current = tree;
    var intersects = true;
    for (; intersects && depth < path.length; ++depth) {
      var key = path[depth];
      var keyType = typeof key;
      if (key && keyType === 'object') {
        var note = {};
        var innerKey = iterateKeySet(key, note);
        var nextDepth = depth + 1;
        do {
          var next = current[innerKey];
          intersects = next !== undefined;
          if (intersects) {
            intersects = hasIntersection(next, path, nextDepth);
          }
          innerKey = iterateKeySet(key, note);
        } while (intersects && !note.done);
        break;
      }
      current = current[key];
      intersects = current !== undefined;
    }
    return intersects;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/pathsComplementFromTree", ["npm:falcor-path-utils@0.3.4/lib/hasIntersection"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasIntersection = require("npm:falcor-path-utils@0.3.4/lib/hasIntersection");
  module.exports = function pathsComplementFromTree(paths, tree) {
    var out = [];
    var outLength = -1;
    for (var i = 0,
        len = paths.length; i < len; ++i) {
      if (!hasIntersection(tree, paths[i], 0)) {
        out[++outLength] = paths[i];
      }
    }
    return out;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/pathsComplementFromLengthTree", ["npm:falcor-path-utils@0.3.4/lib/hasIntersection"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasIntersection = require("npm:falcor-path-utils@0.3.4/lib/hasIntersection");
  module.exports = function pathsComplementFromLengthTree(paths, tree) {
    var out = [];
    var outLength = -1;
    for (var i = 0,
        len = paths.length; i < len; ++i) {
      var path = paths[i];
      if (!hasIntersection(tree[path.length], path, 0)) {
        out[++outLength] = path;
      }
    }
    return out;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/toPaths", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var typeOfObject = "object";
  module.exports = function toPaths(lengths) {
    var pathmap;
    var allPaths = [];
    var allPathsLength = 0;
    for (var length in lengths) {
      if (isNumber(length) && isObject(pathmap = lengths[length])) {
        var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;
        var pathsIndex = -1;
        var pathsCount = paths.length;
        while (++pathsIndex < pathsCount) {
          allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);
        }
      }
    }
    return allPaths;
  };
  function isObject(value) {
    return value !== null && typeof value === typeOfObject;
  }
  function collapsePathMap(pathmap, depth, length) {
    var key;
    var code = getHashCode(String(depth));
    var subs = Object.create(null);
    var codes = [];
    var codesIndex = -1;
    var codesCount = 0;
    var pathsets = [];
    var pathsetsCount = 0;
    var subPath,
        subCode,
        subKeys,
        subKeysIndex,
        subKeysCount,
        subSets,
        subSetsIndex,
        subSetsCount,
        pathset,
        pathsetIndex,
        pathsetCount,
        firstSubKey,
        pathsetClone;
    subKeys = [];
    subKeysIndex = -1;
    if (depth < length - 1) {
      subKeysCount = getSortedKeys(pathmap, subKeys);
      while (++subKeysIndex < subKeysCount) {
        key = subKeys[subKeysIndex];
        subPath = collapsePathMap(pathmap[key], depth + 1, length);
        subCode = subPath.code;
        if (subs[subCode]) {
          subPath = subs[subCode];
        } else {
          codes[codesCount++] = subCode;
          subPath = subs[subCode] = {
            keys: [],
            sets: subPath.sets
          };
        }
        code = getHashCode(code + key + subCode);
        isNumber(key) && subPath.keys.push(parseInt(key, 10)) || subPath.keys.push(key);
      }
      while (++codesIndex < codesCount) {
        key = codes[codesIndex];
        subPath = subs[key];
        subKeys = subPath.keys;
        subKeysCount = subKeys.length;
        if (subKeysCount > 0) {
          subSets = subPath.sets;
          subSetsIndex = -1;
          subSetsCount = subSets.length;
          firstSubKey = subKeys[0];
          while (++subSetsIndex < subSetsCount) {
            pathset = subSets[subSetsIndex];
            pathsetIndex = -1;
            pathsetCount = pathset.length;
            pathsetClone = new Array(pathsetCount + 1);
            pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;
            while (++pathsetIndex < pathsetCount) {
              pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];
            }
            pathsets[pathsetsCount++] = pathsetClone;
          }
        }
      }
    } else {
      subKeysCount = getSortedKeys(pathmap, subKeys);
      if (subKeysCount > 1) {
        pathsets[pathsetsCount++] = [subKeys];
      } else {
        pathsets[pathsetsCount++] = subKeys;
      }
      while (++subKeysIndex < subKeysCount) {
        code = getHashCode(code + subKeys[subKeysIndex]);
      }
    }
    return {
      code: code,
      sets: pathsets
    };
  }
  function collapsePathSetIndexes(pathset) {
    var keysetIndex = -1;
    var keysetCount = pathset.length;
    while (++keysetIndex < keysetCount) {
      var keyset = pathset[keysetIndex];
      if (isArray(keyset)) {
        pathset[keysetIndex] = collapseIndex(keyset);
      }
    }
    return pathset;
  }
  function collapseIndex(keyset) {
    var keyIndex = -1;
    var keyCount = keyset.length - 1;
    var isSparseRange = keyCount > 0;
    while (++keyIndex <= keyCount) {
      var key = keyset[keyIndex];
      if (!isNumber(key)) {
        isSparseRange = false;
        break;
      }
      keyset[keyIndex] = parseInt(key, 10);
    }
    if (isSparseRange === true) {
      keyset.sort(sortListAscending);
      var from = keyset[0];
      var to = keyset[keyCount];
      if (to - from <= keyCount) {
        return {
          from: from,
          to: to
        };
      }
    }
    return keyset;
  }
  function sortListAscending(a, b) {
    return a - b;
  }
  function getSortedKeys(map, keys, sort) {
    var len = 0;
    for (var key in map) {
      keys[len++] = key;
    }
    if (len > 1) {
      keys.sort(sort);
    }
    return len;
  }
  function getHashCode(key) {
    var code = 5381;
    var index = -1;
    var count = key.length;
    while (++index < count) {
      code = (code << 5) + code + key.charCodeAt(index);
    }
    return String(code);
  }
  function isNumber(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/collapse", ["npm:falcor-path-utils@0.3.4/lib/toPaths", "npm:falcor-path-utils@0.3.4/lib/toTree"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toPaths = require("npm:falcor-path-utils@0.3.4/lib/toPaths");
  var toTree = require("npm:falcor-path-utils@0.3.4/lib/toTree");
  module.exports = function collapse(paths) {
    var collapseMap = paths.reduce(function(acc, path) {
      var len = path.length;
      if (!acc[len]) {
        acc[len] = [];
      }
      acc[len].push(path);
      return acc;
    }, {});
    Object.keys(collapseMap).forEach(function(collapseKey) {
      collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);
    });
    return toPaths(collapseMap);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4/lib/index", ["npm:falcor-path-utils@0.3.4/lib/iterateKeySet", "npm:falcor-path-utils@0.3.4/lib/toTree", "npm:falcor-path-utils@0.3.4/lib/toTreeWithUnion", "npm:falcor-path-utils@0.3.4/lib/pathsComplementFromTree", "npm:falcor-path-utils@0.3.4/lib/pathsComplementFromLengthTree", "npm:falcor-path-utils@0.3.4/lib/hasIntersection", "npm:falcor-path-utils@0.3.4/lib/toPaths", "npm:falcor-path-utils@0.3.4/lib/collapse"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    iterateKeySet: require("npm:falcor-path-utils@0.3.4/lib/iterateKeySet"),
    toTree: require("npm:falcor-path-utils@0.3.4/lib/toTree"),
    toTreeWithUnion: require("npm:falcor-path-utils@0.3.4/lib/toTreeWithUnion"),
    pathsComplementFromTree: require("npm:falcor-path-utils@0.3.4/lib/pathsComplementFromTree"),
    pathsComplementFromLengthTree: require("npm:falcor-path-utils@0.3.4/lib/pathsComplementFromLengthTree"),
    hasIntersection: require("npm:falcor-path-utils@0.3.4/lib/hasIntersection"),
    toPaths: require("npm:falcor-path-utils@0.3.4/lib/toPaths"),
    collapse: require("npm:falcor-path-utils@0.3.4/lib/collapse")
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-utils@0.3.4", ["npm:falcor-path-utils@0.3.4/lib/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor-path-utils@0.3.4/lib/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/Request", ["npm:rx@2.5.3/dist/rx", "npm:falcor@0.1.13/lib/errors/InvalidSourceError", "npm:falcor-path-utils@0.3.4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Observer = Rx.Observer;
  var Observable = Rx.Observable;
  var Disposable = Rx.Disposable;
  var SerialDisposable = Rx.SerialDisposable;
  var CompositeDisposable = Rx.CompositeDisposable;
  var InvalidSourceError = require("npm:falcor@0.1.13/lib/errors/InvalidSourceError");
  var falcorPathUtils = require("npm:falcor-path-utils@0.3.4");
  var iterateKeySet = falcorPathUtils.iterateKeySet;
  function Request() {
    this.length = 0;
    this.pending = false;
    this.pathmaps = [];
    Observable.call(this, this._subscribe);
  }
  Request.create = function create(queue, model, index) {
    var request = new this();
    request.queue = queue;
    request.model = model;
    request.index = index;
    return request;
  };
  Request.prototype = Object.create(Observable.prototype);
  Request.prototype.constructor = Request;
  Request.prototype.insertPath = function insertPathIntoRequest(path, union, parentArg, indexArg, countArg) {
    var index = indexArg || 0;
    var count = countArg || path.length - 1;
    var parent = parentArg || this.pathmaps[count + 1] || (this.pathmaps[count + 1] = Object.create(null));
    if (parent === void 0 || parent === null) {
      return false;
    }
    var key,
        node;
    var keySet = path[index];
    var iteratorNote = {};
    key = iterateKeySet(keySet, iteratorNote);
    do {
      node = parent[key];
      if (index < count) {
        if (node == null) {
          if (union) {
            return false;
          }
          node = parent[key] = Object.create(null);
        }
        if (this.insertPath(path, union, node, index + 1, count) === false) {
          return false;
        }
      } else {
        parent[key] = (node || 0) + 1;
        this.length += 1;
      }
      if (!iteratorNote.done) {
        key = iterateKeySet(keySet, iteratorNote);
      }
    } while (!iteratorNote.done);
    return true;
  };
  Request.prototype.removePath = function removePathFromRequest(path, parentArg, indexArg, countArg) {
    var index = indexArg || 0;
    var count = countArg || path.length - 1;
    var parent = parentArg || this.pathmaps[count + 1];
    if (parent === void 0 || parent === null) {
      return true;
    }
    var key,
        node,
        deleted = 0;
    var keySet = path[index];
    var iteratorNote = {};
    key = iterateKeySet(keySet, iteratorNote);
    do {
      node = parent[key];
      if (node === void 0 || node === null) {
        continue;
      } else if (index < count) {
        deleted += this.removePath(path, node, index + 1, count);
        var emptyNodeKey = void 0;
        for (emptyNodeKey in node) {
          break;
        }
        if (emptyNodeKey === void 0) {
          delete parent[key];
        }
      } else {
        node = parent[key] = (node || 1) - 1;
        if (node === 0) {
          delete parent[key];
        }
        deleted += 1;
        this.length -= 1;
      }
      if (!iteratorNote.done) {
        key = iterateKeySet(keySet, iteratorNote);
      }
    } while (!iteratorNote.done);
    return deleted;
  };
  Request.prototype.getSourceObserver = function getSourceObserver(observer) {
    var request = this;
    return Observer.create(function onNext(envelope) {
      envelope.jsonGraph = envelope.jsonGraph || envelope.jsong || envelope.values || envelope.value;
      envelope.index = request.index;
      observer.onNext(envelope);
    }, function onError(e) {
      observer.onError(e);
    }, function onCompleted() {
      observer.onCompleted();
    });
  };
  Request.prototype._subscribe = function _subscribe(observer) {
    var request = this;
    var queue = this.queue;
    request.pending = true;
    var isDisposed = false;
    var sourceSubscription = new SerialDisposable();
    var queueDisposable = Disposable.create(function() {
      if (!isDisposed) {
        isDisposed = true;
        if (queue) {
          queue._remove(request);
        }
      }
    });
    var disposables = new CompositeDisposable(sourceSubscription, queueDisposable);
    try {
      sourceSubscription.setDisposable(this.model._source[this.method](this.getSourceArgs()).subscribe(this.getSourceObserver(observer)));
    } catch (e) {
      throw new InvalidSourceError(e);
    }
    return disposables;
  };
  module.exports = Request;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/array-map", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function arrayMap(array, selector) {
    var i = -1;
    var n = array.length;
    var array2 = new Array(n);
    while (++i < n) {
      array2[i] = selector(array[i], i, array);
    }
    return array2;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/prefix", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = String.fromCharCode(30);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/key", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "key";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/ref", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "ref";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/context", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "context";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/version", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "version";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/ref-index", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "ref-index";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/refs-length", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "refs-length";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/types/ref", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "ref";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/values/expires-never", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = 1;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/head", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "head";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/tail", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "tail";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/next", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "next";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/prev", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "prev";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/lru/promote", ["npm:falcor@0.1.13/lib/values/expires-never", "npm:falcor@0.1.13/lib/internal/head", "npm:falcor@0.1.13/lib/internal/tail", "npm:falcor@0.1.13/lib/internal/next", "npm:falcor@0.1.13/lib/internal/prev", "npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $expiresNever = require("npm:falcor@0.1.13/lib/values/expires-never");
  var __head = require("npm:falcor@0.1.13/lib/internal/head");
  var __tail = require("npm:falcor@0.1.13/lib/internal/tail");
  var __next = require("npm:falcor@0.1.13/lib/internal/next");
  var __prev = require("npm:falcor@0.1.13/lib/internal/prev");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function lruPromote(root, node) {
    if (isObject(node) && (node.$expires !== $expiresNever)) {
      var head = root[__head],
          tail = root[__tail],
          next = node[__next],
          prev = node[__prev];
      if (node !== head) {
        if (next != null && typeof next === "object") {
          next[__prev] = prev;
        }
        if (prev != null && typeof prev === "object") {
          prev[__next] = next;
        }
        next = head;
        if (head != null && typeof head === "object") {
          head[__prev] = node;
        }
        root[__head] = root[__next] = head = node;
        head[__next] = next;
        head[__prev] = void 0;
      }
      if (tail == null || node === tail) {
        root[__tail] = root[__prev] = tail = prev || node;
      }
    }
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/now", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Date.now;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/values/expires-now", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = 0;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isAlreadyExpired", ["npm:falcor@0.1.13/lib/support/now", "npm:falcor@0.1.13/lib/values/expires-now", "npm:falcor@0.1.13/lib/values/expires-never"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var now = require("npm:falcor@0.1.13/lib/support/now");
  var $now = require("npm:falcor@0.1.13/lib/values/expires-now");
  var $never = require("npm:falcor@0.1.13/lib/values/expires-never");
  module.exports = function isAlreadyExpired(node) {
    var exp = node.$expires;
    return (exp != null) && (exp !== $never) && (exp !== $now) && (exp < now());
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isPrimitive", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var objTypeof = "object";
  module.exports = function isPrimitive(value) {
    return value == null || typeof value !== objTypeof;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/lru/splice", ["npm:falcor@0.1.13/lib/internal/head", "npm:falcor@0.1.13/lib/internal/tail", "npm:falcor@0.1.13/lib/internal/next", "npm:falcor@0.1.13/lib/internal/prev"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __head = require("npm:falcor@0.1.13/lib/internal/head");
  var __tail = require("npm:falcor@0.1.13/lib/internal/tail");
  var __next = require("npm:falcor@0.1.13/lib/internal/next");
  var __prev = require("npm:falcor@0.1.13/lib/internal/prev");
  module.exports = function lruSplice(root, node) {
    var head = root[__head],
        tail = root[__tail],
        next = node[__next],
        prev = node[__prev];
    if (next != null && typeof next === "object") {
      next[__prev] = prev;
    }
    if (prev != null && typeof prev === "object") {
      prev[__next] = next;
    }
    if (node === head) {
      root[__head] = root[__next] = next;
    }
    if (node === tail) {
      root[__tail] = root[__prev] = prev;
    }
    node[__next] = node[__prev] = void 0;
    head = tail = next = prev = void 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/invalidated", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "invalidated";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/expireNode", ["npm:falcor@0.1.13/lib/lru/splice", "npm:falcor@0.1.13/lib/internal/invalidated"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var splice = require("npm:falcor@0.1.13/lib/lru/splice");
  var __invalidated = require("npm:falcor@0.1.13/lib/internal/invalidated");
  module.exports = function expireNode(node, expired, lru) {
    if (!node[__invalidated]) {
      node[__invalidated] = true;
      expired.push(node);
      splice(lru, node);
    }
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/incrementVersion", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var version = 1;
  module.exports = function incrementVersion() {
    return version++;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/parent", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/internal/prefix") + "parent";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/types/error", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "error";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/getSize", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function getSize(node) {
    return isObject(node) && node.$size || 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/getTimestamp", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function getTimestamp(node) {
    return isObject(node) && node.$timestamp || undefined;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isExpired", ["npm:falcor@0.1.13/lib/support/now", "npm:falcor@0.1.13/lib/values/expires-now", "npm:falcor@0.1.13/lib/values/expires-never"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var now = require("npm:falcor@0.1.13/lib/support/now");
  var $now = require("npm:falcor@0.1.13/lib/values/expires-now");
  var $never = require("npm:falcor@0.1.13/lib/values/expires-never");
  module.exports = function isExpired(node) {
    var exp = node.$expires;
    return (exp != null) && (exp !== $never) && (exp === $now || exp < now());
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/TokenTypes", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = {
    token: 'token',
    dotSeparator: '.',
    commaSeparator: ',',
    openingBracket: '[',
    closingBracket: ']',
    openingBrace: '{',
    closingBrace: '}',
    escape: '\\',
    space: ' ',
    colon: ':',
    quote: 'quote',
    unknown: 'unknown'
  };
  module.exports = TokenTypes;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/tokenizer/index", ["npm:falcor-path-syntax@0.2.1/src/TokenTypes"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var DOT_SEPARATOR = '.';
  var COMMA_SEPARATOR = ',';
  var OPENING_BRACKET = '[';
  var CLOSING_BRACKET = ']';
  var OPENING_BRACE = '{';
  var CLOSING_BRACE = '}';
  var COLON = ':';
  var ESCAPE = '\\';
  var DOUBLE_OUOTES = '"';
  var SINGE_OUOTES = "'";
  var SPACE = " ";
  var SPECIAL_CHARACTERS = '\\\'"[]., ';
  var EXT_SPECIAL_CHARACTERS = '\\{}\'"[]., :';
  var Tokenizer = module.exports = function(string, ext) {
    this._string = string;
    this._idx = -1;
    this._extended = ext;
    this.parseString = '';
  };
  Tokenizer.prototype = {
    next: function() {
      var nextToken = this._nextToken ? this._nextToken : getNext(this._string, this._idx, this._extended);
      this._idx = nextToken.idx;
      this._nextToken = false;
      this.parseString += nextToken.token.token;
      return nextToken.token;
    },
    peek: function() {
      var nextToken = this._nextToken ? this._nextToken : getNext(this._string, this._idx, this._extended);
      this._nextToken = nextToken;
      return nextToken.token;
    }
  };
  Tokenizer.toNumber = function toNumber(x) {
    if (!isNaN(+x)) {
      return +x;
    }
    return NaN;
  };
  function toOutput(token, type, done) {
    return {
      token: token,
      done: done,
      type: type
    };
  }
  function getNext(string, idx, ext) {
    var output = false;
    var token = '';
    var specialChars = ext ? EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;
    do {
      done = idx + 1 >= string.length;
      if (done) {
        break;
      }
      var character = string[idx + 1];
      if (character !== undefined && specialChars.indexOf(character) === -1) {
        token += character;
        ++idx;
        continue;
      } else if (token.length) {
        break;
      }
      ++idx;
      var type;
      switch (character) {
        case DOT_SEPARATOR:
          type = TokenTypes.dotSeparator;
          break;
        case COMMA_SEPARATOR:
          type = TokenTypes.commaSeparator;
          break;
        case OPENING_BRACKET:
          type = TokenTypes.openingBracket;
          break;
        case CLOSING_BRACKET:
          type = TokenTypes.closingBracket;
          break;
        case OPENING_BRACE:
          type = TokenTypes.openingBrace;
          break;
        case CLOSING_BRACE:
          type = TokenTypes.closingBrace;
          break;
        case SPACE:
          type = TokenTypes.space;
          break;
        case DOUBLE_OUOTES:
        case SINGE_OUOTES:
          type = TokenTypes.quote;
          break;
        case ESCAPE:
          type = TokenTypes.escape;
          break;
        case COLON:
          type = TokenTypes.colon;
          break;
        default:
          type = TokenTypes.unknown;
          break;
      }
      output = toOutput(character, type, false);
      break;
    } while (!done);
    if (!output && token.length) {
      output = toOutput(token, TokenTypes.token, false);
    }
    if (!output) {
      output = {done: true};
    }
    return {
      token: output,
      idx: idx
    };
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/exceptions/index", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    indexer: {
      nested: 'Indexers cannot be nested.',
      needQuotes: 'unquoted indexers must be numeric.',
      empty: 'cannot have empty indexers.',
      leadingDot: 'Indexers cannot have leading dots.',
      leadingComma: 'Indexers cannot have leading comma.',
      requiresComma: 'Indexers require commas between indexer args.',
      routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'
    },
    range: {
      precedingNaN: 'ranges must be preceded by numbers.',
      suceedingNaN: 'ranges must be suceeded by numbers.'
    },
    routed: {invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'},
    quote: {
      empty: 'cannot have empty quoted keys.',
      illegalEscape: 'Invalid escape character.  Only quotes are escapable.'
    },
    unexpectedToken: 'Unexpected token.',
    invalidIdentifier: 'Invalid Identifier.',
    invalidPath: 'Please provide a valid path.',
    throwError: function(err, tokenizer, token) {
      if (token) {
        throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;
      }
      throw err + ' -- ' + tokenizer.parseString;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/parse-tree/range", ["npm:falcor-path-syntax@0.2.1/src/tokenizer/index", "npm:falcor-path-syntax@0.2.1/src/TokenTypes", "npm:falcor-path-syntax@0.2.1/src/exceptions/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Tokenizer = require("npm:falcor-path-syntax@0.2.1/src/tokenizer/index");
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var E = require("npm:falcor-path-syntax@0.2.1/src/exceptions/index");
  module.exports = function range(tokenizer, openingToken, state, out) {
    var token = tokenizer.peek();
    var dotCount = 1;
    var done = false;
    var inclusive = true;
    var idx = state.indexer.length - 1;
    var from = Tokenizer.toNumber(state.indexer[idx]);
    var to;
    if (isNaN(from)) {
      E.throwError(E.range.precedingNaN, tokenizer);
    }
    while (!done && !token.done) {
      switch (token.type) {
        case TokenTypes.dotSeparator:
          if (dotCount === 3) {
            E.throwError(E.unexpectedToken, tokenizer);
          }
          ++dotCount;
          if (dotCount === 3) {
            inclusive = false;
          }
          break;
        case TokenTypes.token:
          to = Tokenizer.toNumber(tokenizer.next().token);
          if (isNaN(to)) {
            E.throwError(E.range.suceedingNaN, tokenizer);
          }
          done = true;
          break;
        default:
          done = true;
          break;
      }
      if (!done) {
        tokenizer.next();
        token = tokenizer.peek();
      } else {
        break;
      }
    }
    state.indexer[idx] = {
      from: from,
      to: inclusive ? to : to - 1
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/parse-tree/quote", ["npm:falcor-path-syntax@0.2.1/src/TokenTypes", "npm:falcor-path-syntax@0.2.1/src/exceptions/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var E = require("npm:falcor-path-syntax@0.2.1/src/exceptions/index");
  var quoteE = E.quote;
  module.exports = function quote(tokenizer, openingToken, state, out) {
    var token = tokenizer.next();
    var innerToken = '';
    var openingQuote = openingToken.token;
    var escaping = false;
    var done = false;
    while (!token.done) {
      switch (token.type) {
        case TokenTypes.token:
        case TokenTypes.space:
        case TokenTypes.dotSeparator:
        case TokenTypes.commaSeparator:
        case TokenTypes.openingBracket:
        case TokenTypes.closingBracket:
        case TokenTypes.openingBrace:
        case TokenTypes.closingBrace:
          if (escaping) {
            E.throwError(quoteE.illegalEscape, tokenizer);
          }
          innerToken += token.token;
          break;
        case TokenTypes.quote:
          if (escaping) {
            innerToken += token.token;
            escaping = false;
          } else if (token.token !== openingQuote) {
            innerToken += token.token;
          } else {
            done = true;
          }
          break;
        case TokenTypes.escape:
          escaping = true;
          break;
        default:
          E.throwError(E.unexpectedToken, tokenizer);
      }
      if (done) {
        break;
      }
      token = tokenizer.next();
    }
    if (innerToken.length === 0) {
      E.throwError(quoteE.empty, tokenizer);
    }
    state.indexer[state.indexer.length] = innerToken;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/RoutedTokens", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    integers: 'integers',
    ranges: 'ranges',
    keys: 'keys'
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/parse-tree/routed", ["npm:falcor-path-syntax@0.2.1/src/TokenTypes", "npm:falcor-path-syntax@0.2.1/src/RoutedTokens", "npm:falcor-path-syntax@0.2.1/src/exceptions/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var RoutedTokens = require("npm:falcor-path-syntax@0.2.1/src/RoutedTokens");
  var E = require("npm:falcor-path-syntax@0.2.1/src/exceptions/index");
  var routedE = E.routed;
  module.exports = function routed(tokenizer, openingToken, state, out) {
    var routeToken = tokenizer.next();
    var named = false;
    var name = '';
    switch (routeToken.token) {
      case RoutedTokens.integers:
      case RoutedTokens.ranges:
      case RoutedTokens.keys:
        break;
      default:
        E.throwError(routedE.invalid, tokenizer);
        break;
    }
    var next = tokenizer.next();
    if (next.type === TokenTypes.colon) {
      named = true;
      next = tokenizer.next();
      if (next.type !== TokenTypes.token) {
        E.throwError(routedE.invalid, tokenizer);
      }
      name = next.token;
      next = tokenizer.next();
    }
    if (next.type === TokenTypes.closingBrace) {
      var outputToken = {
        type: routeToken.token,
        named: named,
        name: name
      };
      state.indexer[state.indexer.length] = outputToken;
    } else {
      E.throwError(routedE.invalid, tokenizer);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/parse-tree/indexer", ["npm:falcor-path-syntax@0.2.1/src/TokenTypes", "npm:falcor-path-syntax@0.2.1/src/exceptions/index", "npm:falcor-path-syntax@0.2.1/src/parse-tree/range", "npm:falcor-path-syntax@0.2.1/src/parse-tree/quote", "npm:falcor-path-syntax@0.2.1/src/parse-tree/routed"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var E = require("npm:falcor-path-syntax@0.2.1/src/exceptions/index");
  var idxE = E.indexer;
  var range = require("npm:falcor-path-syntax@0.2.1/src/parse-tree/range");
  var quote = require("npm:falcor-path-syntax@0.2.1/src/parse-tree/quote");
  var routed = require("npm:falcor-path-syntax@0.2.1/src/parse-tree/routed");
  module.exports = function indexer(tokenizer, openingToken, state, out) {
    var token = tokenizer.next();
    var done = false;
    var allowedMaxLength = 1;
    var routedIndexer = false;
    state.indexer = [];
    while (!token.done) {
      switch (token.type) {
        case TokenTypes.token:
        case TokenTypes.quote:
          if (state.indexer.length === allowedMaxLength) {
            E.throwError(idxE.requiresComma, tokenizer);
          }
          break;
      }
      switch (token.type) {
        case TokenTypes.openingBrace:
          routedIndexer = true;
          routed(tokenizer, token, state, out);
          break;
        case TokenTypes.token:
          var t = +token.token;
          if (isNaN(t)) {
            E.throwError(idxE.needQuotes, tokenizer);
          }
          state.indexer[state.indexer.length] = t;
          break;
        case TokenTypes.dotSeparator:
          if (!state.indexer.length) {
            E.throwError(idxE.leadingDot, tokenizer);
          }
          range(tokenizer, token, state, out);
          break;
        case TokenTypes.space:
          break;
        case TokenTypes.closingBracket:
          done = true;
          break;
        case TokenTypes.quote:
          quote(tokenizer, token, state, out);
          break;
        case TokenTypes.openingBracket:
          E.throwError(idxE.nested, tokenizer);
          break;
        case TokenTypes.commaSeparator:
          ++allowedMaxLength;
          break;
        default:
          E.throwError(E.unexpectedToken, tokenizer);
          break;
      }
      if (done) {
        break;
      }
      token = tokenizer.next();
    }
    if (state.indexer.length === 0) {
      E.throwError(idxE.empty, tokenizer);
    }
    if (state.indexer.length > 1 && routedIndexer) {
      E.throwError(idxE.routedTokens, tokenizer);
    }
    if (state.indexer.length === 1) {
      state.indexer = state.indexer[0];
    }
    out[out.length] = state.indexer;
    state.indexer = undefined;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/parse-tree/head", ["npm:falcor-path-syntax@0.2.1/src/TokenTypes", "npm:falcor-path-syntax@0.2.1/src/exceptions/index", "npm:falcor-path-syntax@0.2.1/src/parse-tree/indexer"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TokenTypes = require("npm:falcor-path-syntax@0.2.1/src/TokenTypes");
  var E = require("npm:falcor-path-syntax@0.2.1/src/exceptions/index");
  var indexer = require("npm:falcor-path-syntax@0.2.1/src/parse-tree/indexer");
  module.exports = function head(tokenizer) {
    var token = tokenizer.next();
    var state = {};
    var out = [];
    while (!token.done) {
      switch (token.type) {
        case TokenTypes.token:
          var first = +token.token[0];
          if (!isNaN(first)) {
            E.throwError(E.invalidIdentifier, tokenizer);
          }
          out[out.length] = token.token;
          break;
        case TokenTypes.dotSeparator:
          if (out.length === 0) {
            E.throwError(E.unexpectedToken, tokenizer);
          }
          break;
        case TokenTypes.space:
          break;
        case TokenTypes.openingBracket:
          indexer(tokenizer, token, state, out);
          break;
        default:
          E.throwError(E.unexpectedToken, tokenizer);
          break;
      }
      token = tokenizer.next();
    }
    if (out.length === 0) {
      E.throwError(E.invalidPath, tokenizer);
    }
    return out;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1/src/index", ["npm:falcor-path-syntax@0.2.1/src/tokenizer/index", "npm:falcor-path-syntax@0.2.1/src/parse-tree/head", "npm:falcor-path-syntax@0.2.1/src/RoutedTokens"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Tokenizer = require("npm:falcor-path-syntax@0.2.1/src/tokenizer/index");
  var head = require("npm:falcor-path-syntax@0.2.1/src/parse-tree/head");
  var RoutedTokens = require("npm:falcor-path-syntax@0.2.1/src/RoutedTokens");
  var parser = function parser(string, extendedRules) {
    return head(new Tokenizer(string, extendedRules));
  };
  module.exports = parser;
  parser.fromPathsOrPathValues = function(paths, ext) {
    if (!paths) {
      return [];
    }
    var out = [];
    for (i = 0, len = paths.length; i < len; i++) {
      if (typeof paths[i] === 'string') {
        out[i] = parser(paths[i], ext);
      } else if (typeof paths[i].path === 'string') {
        out[i] = {
          path: parser(paths[i].path, ext),
          value: paths[i].value
        };
      } else {
        out[i] = paths[i];
      }
    }
    return out;
  };
  parser.fromPath = function(path, ext) {
    if (!path) {
      return [];
    }
    if (typeof path === 'string') {
      return parser(path, ext);
    }
    return path;
  };
  parser.RoutedTokens = RoutedTokens;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-path-syntax@0.2.1", ["npm:falcor-path-syntax@0.2.1/src/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor-path-syntax@0.2.1/src/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-json-graph@1.1.5/src/index", ["npm:falcor-path-syntax@0.2.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  function sentinel(type, value, props) {
    var copy = Object.create(null);
    if (props != null) {
      for (var key in props) {
        copy[key] = props[key];
      }
      copy["$type"] = type;
      copy.value = value;
      return copy;
    } else {
      return {
        $type: type,
        value: value
      };
    }
  }
  module.exports = {
    ref: function ref(path, props) {
      return sentinel("ref", pathSyntax.fromPath(path), props);
    },
    atom: function atom(value, props) {
      return sentinel("atom", value, props);
    },
    undefined: function() {
      return sentinel("atom");
    },
    error: function error(errorValue, props) {
      return sentinel("error", errorValue, props);
    },
    pathValue: function pathValue(path, value) {
      return {
        path: pathSyntax.fromPath(path),
        value: value
      };
    },
    pathInvalidation: function pathInvalidation(path) {
      return {
        path: pathSyntax.fromPath(path),
        invalidated: true
      };
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor-json-graph@1.1.5", ["npm:falcor-json-graph@1.1.5/src/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor-json-graph@1.1.5/src/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/internal/model-created", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "$modelCreated";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/clone", ["npm:falcor@0.1.13/lib/internal/prefix", "npm:falcor@0.1.13/lib/support/hasOwn", "npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  var hasOwn = require("npm:falcor@0.1.13/lib/support/hasOwn");
  var isArray = Array.isArray;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function clone(value) {
    var dest = value;
    if (isObject(dest)) {
      dest = isArray(value) ? [] : {};
      var src = value;
      for (var key in src) {
        if (key[0] === prefix || !hasOwn(src, key)) {
          continue;
        }
        dest[key] = src[key];
      }
    }
    return dest;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/getExpires", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function getSize(node) {
    return isObject(node) && node.$expires || undefined;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/wrapNode", ["npm:falcor-json-graph@1.1.5", "npm:falcor@0.1.13/lib/support/now", "npm:falcor@0.1.13/lib/values/expires-now", "npm:falcor@0.1.13/lib/internal/model-created", "npm:falcor@0.1.13/lib/support/clone", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/getExpires"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var jsong = require("npm:falcor-json-graph@1.1.5");
  var $atom = jsong.atom;
  var now = require("npm:falcor@0.1.13/lib/support/now");
  var expiresNow = require("npm:falcor@0.1.13/lib/values/expires-now");
  var __modelCreated = require("npm:falcor@0.1.13/lib/internal/model-created");
  var atomSize = 50;
  var clone = require("npm:falcor@0.1.13/lib/support/clone");
  var isArray = Array.isArray;
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var getExpires = require("npm:falcor@0.1.13/lib/support/getExpires");
  module.exports = function wrapNode(nodeArg, typeArg, value) {
    var size = 0;
    var node = nodeArg;
    var type = typeArg;
    if (type) {
      node = clone(node);
      size = getSize(node);
      node.$type = type;
    } else {
      node = $atom(value);
      type = node.$type;
      node[__modelCreated] = true;
    }
    if (value == null) {
      size = atomSize + 1;
    } else if (size == null || size <= 0) {
      switch (typeof value) {
        case "object":
          if (isArray(value)) {
            size = atomSize + value.length;
          } else {
            size = atomSize + 1;
          }
          break;
        case "string":
          size = atomSize + value.length;
          break;
        default:
          size = atomSize + 1;
          break;
      }
    }
    var expires = getExpires(node);
    if (typeof expires === "number" && expires < expiresNow) {
      node.$expires = now() + (expires * -1);
    }
    node.$size = size;
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/insertNode", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/version"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  module.exports = function insertNode(node, parent, key, version) {
    node[__key] = key;
    node[__parent] = parent;
    node[__version] = version;
    parent[key] = node;
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/transferBackReferences", ["npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/refs-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  module.exports = function transferBackReferences(fromNode, destNode) {
    var fromNodeRefsLength = fromNode[__refsLength] || 0,
        destNodeRefsLength = destNode[__refsLength] || 0,
        i = -1;
    while (++i < fromNodeRefsLength) {
      var ref = fromNode[__ref + i];
      if (ref !== void 0) {
        ref[__context] = destNode;
        destNode[__ref + (destNodeRefsLength + i)] = ref;
        fromNode[__ref + i] = void 0;
      }
    }
    destNode[__refsLength] = fromNodeRefsLength + destNodeRefsLength;
    fromNode[__refsLength] = void 0;
    return destNode;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/unlinkBackReferences", ["npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  module.exports = function unlinkBackReferences(node) {
    var i = -1,
        n = node[__refsLength] || 0;
    while (++i < n) {
      var ref = node[__ref + i];
      if (ref != null) {
        ref[__context] = ref[__refIndex] = node[__ref + i] = void 0;
      }
    }
    node[__refsLength] = void 0;
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/unlinkForwardReference", ["npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  module.exports = function unlinkForwardReference(reference) {
    var destination = reference[__context];
    if (destination) {
      var i = (reference[__refIndex] || 0) - 1,
          n = (destination[__refsLength] || 0) - 1;
      while (++i <= n) {
        destination[__ref + i] = destination[__ref + (i + 1)];
      }
      destination[__refsLength] = n;
      reference[__refIndex] = reference[__context] = destination = void 0;
    }
    return reference;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/removeNode", ["npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/lru/splice", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/unlinkBackReferences", "npm:falcor@0.1.13/lib/support/unlinkForwardReference"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var splice = require("npm:falcor@0.1.13/lib/lru/splice");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var unlinkBackReferences = require("npm:falcor@0.1.13/lib/support/unlinkBackReferences");
  var unlinkForwardReference = require("npm:falcor@0.1.13/lib/support/unlinkForwardReference");
  module.exports = function removeNode(node, parent, key, lru) {
    if (isObject(node)) {
      var type = node.$type;
      if (Boolean(type)) {
        if (type === $ref) {
          unlinkForwardReference(node);
        }
        splice(lru, node);
      }
      unlinkBackReferences(node);
      parent[key] = node[__parent] = void 0;
      return true;
    }
    return false;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/removeNodeAndDescendants", ["npm:falcor@0.1.13/lib/support/hasOwn", "npm:falcor@0.1.13/lib/internal/prefix", "npm:falcor@0.1.13/lib/support/removeNode"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwn = require("npm:falcor@0.1.13/lib/support/hasOwn");
  var prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  var removeNode = require("npm:falcor@0.1.13/lib/support/removeNode");
  module.exports = function removeNodeAndDescendants(node, parent, key, lru) {
    if (removeNode(node, parent, key, lru)) {
      if (node.$type == null) {
        for (var key2 in node) {
          if (key2[0] !== prefix && key2[0] !== "$" && hasOwn(node, key2)) {
            removeNodeAndDescendants(node[key2], node, key2, lru);
          }
        }
      }
      return true;
    }
    return false;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/replaceNode", ["npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/transferBackReferences", "npm:falcor@0.1.13/lib/support/removeNodeAndDescendants"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var transferBackReferences = require("npm:falcor@0.1.13/lib/support/transferBackReferences");
  var removeNodeAndDescendants = require("npm:falcor@0.1.13/lib/support/removeNodeAndDescendants");
  module.exports = function replaceNode(node, replacement, parent, key, lru) {
    if (node === replacement) {
      return node;
    } else if (isObject(node)) {
      transferBackReferences(node, replacement);
      removeNodeAndDescendants(node, parent, key, lru);
    }
    parent[key] = replacement;
    return replacement;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/updateBackReferenceVersions", ["npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/refs-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  module.exports = function updateBackReferenceVersions(nodeArg, version) {
    var stack = [nodeArg];
    var count = 0;
    do {
      var node = stack[count--];
      if (node && node[__version] !== version) {
        node[__version] = version;
        stack[count++] = node[__parent];
        var i = -1;
        var n = node[__refsLength] || 0;
        while (++i < n) {
          stack[count++] = node[__ref + i];
        }
      }
    } while (count > -1);
    return nodeArg;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/updateNodeAncestors", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/support/removeNode", "npm:falcor@0.1.13/lib/support/updateBackReferenceVersions"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var removeNode = require("npm:falcor@0.1.13/lib/support/removeNode");
  var updateBackReferenceVersions = require("npm:falcor@0.1.13/lib/support/updateBackReferenceVersions");
  module.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {
    var child = nodeArg;
    do {
      var node = child[__parent];
      var size = child.$size = (child.$size || 0) - offset;
      if (size <= 0 && node != null) {
        removeNode(child, node, child[__key], lru);
      } else if (child[__version] !== version) {
        updateBackReferenceVersions(child, version);
      }
      child = node;
    } while (child);
    return nodeArg;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/mergeJSONGraphNode", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/types/error", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/getTimestamp", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/wrapNode", "npm:falcor@0.1.13/lib/support/insertNode", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor@0.1.13/lib/support/replaceNode", "npm:falcor@0.1.13/lib/support/updateNodeAncestors"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var getTimestamp = require("npm:falcor@0.1.13/lib/support/getTimestamp");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var wrapNode = require("npm:falcor@0.1.13/lib/support/wrapNode");
  var insertNode = require("npm:falcor@0.1.13/lib/support/insertNode");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var replaceNode = require("npm:falcor@0.1.13/lib/support/replaceNode");
  var updateNodeAncestors = require("npm:falcor@0.1.13/lib/support/updateNodeAncestors");
  module.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var sizeOffset;
    var cType,
        mType,
        cIsObject,
        mIsObject,
        cTimestamp,
        mTimestamp;
    if (node === message) {
      if (message === null) {
        node = wrapNode(message, undefined, message);
        parent = updateNodeAncestors(parent, -node.$size, lru, version);
        node = insertNode(node, parent, key);
        promote(lru, node);
        return node;
      } else if (message === undefined) {
        return message;
      } else {
        cIsObject = isObject(node);
        if (cIsObject) {
          cType = node.$type;
          if (cType == null) {
            if (node[__parent] == null) {
              node[__key] = key;
              node[__parent] = parent;
            }
            return node;
          }
        }
      }
    } else {
      cIsObject = isObject(node);
      if (cIsObject) {
        cType = node.$type;
      }
    }
    if (cType !== $ref) {
      mIsObject = isObject(message);
      if (mIsObject) {
        mType = message.$type;
      }
      if (cIsObject && !cType) {
        if (message == null || (mIsObject && !mType)) {
          return node;
        }
      }
    } else {
      if (message == null) {
        if (isExpired(node)) {
          expireNode(node, expired, lru);
          return void 0;
        }
        return node;
      }
      mIsObject = isObject(message);
      if (mIsObject) {
        mType = message.$type;
        if (mType === $ref) {
          if (node === message) {
            if (node[__parent] != null) {
              return node;
            }
          } else {
            cTimestamp = node.$timestamp;
            mTimestamp = message.$timestamp;
            if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {
              return void 0;
            }
          }
        }
      }
    }
    if (cType && mIsObject && !mType) {
      return insertNode(replaceNode(node, message, parent, key, lru), parent, key);
    } else if (mType || !mIsObject) {
      if (mType && node === message) {
        if (node[__parent] == null) {
          node = wrapNode(node, cType, node.value);
          parent = updateNodeAncestors(parent, -node.$size, lru, version);
          node = insertNode(node, parent, key, version);
        }
      } else {
        var isDistinct = true;
        if (cType || !cIsObject) {
          isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;
          if ((cType || mType) && isFunction(comparator)) {
            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));
          }
        }
        if (isDistinct) {
          message = wrapNode(message, mType, mType ? message.value : message);
          if (mType === $error && isFunction(errorSelector)) {
            message = errorSelector(requestedPath.slice(0, requestedPath.index), message);
          }
          sizeOffset = getSize(node) - getSize(message);
          node = replaceNode(node, message, parent, key, lru);
          parent = updateNodeAncestors(parent, sizeOffset, lru, version);
          node = insertNode(node, parent, key, version);
        }
      }
      if (isExpired(node)) {
        expireNode(node, expired, lru);
      } else {
        promote(lru, node);
      }
    } else if (node == null) {
      node = insertNode(message, parent, key);
    }
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/set/setJSONGraphs", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/isAlreadyExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor-path-utils@0.3.4", "npm:falcor@0.1.13/lib/support/incrementVersion", "npm:falcor@0.1.13/lib/support/mergeJSONGraphNode"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isAlreadyExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4").iterateKeySet;
  var incrementVersion = require("npm:falcor@0.1.13/lib/support/incrementVersion");
  var mergeJSONGraphNode = require("npm:falcor@0.1.13/lib/support/mergeJSONGraphNode");
  module.exports = function setJSONGraphs(model, jsonGraphEnvelopes, x, errorSelector, comparator) {
    var modelRoot = model._root;
    var lru = modelRoot;
    var expired = modelRoot.expired;
    var version = incrementVersion();
    var cache = modelRoot.cache;
    var initialVersion = cache[__version];
    var requestedPath = [];
    var optimizedPath = [];
    var requestedPaths = [];
    var optimizedPaths = [];
    var jsonGraphEnvelopeIndex = -1;
    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;
    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {
      var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];
      var paths = jsonGraphEnvelope.paths;
      var jsonGraph = jsonGraphEnvelope.jsonGraph;
      var pathIndex = -1;
      var pathCount = paths.length;
      while (++pathIndex < pathCount) {
        var path = paths[pathIndex];
        optimizedPath.index = 0;
        setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      }
    }
    var newVersion = cache[__version];
    var rootChangeHandler = modelRoot.onChange;
    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
      rootChangeHandler();
    }
    return [requestedPaths, optimizedPaths];
  };
  function setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var note = {};
    var branch = depth < path.length - 1;
    var keySet = path[depth];
    var key = iterateKeySet(keySet, note);
    var optimizedIndex = optimizedPath.index;
    do {
      var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      requestedPath[depth] = key;
      requestedPath.index = depth;
      optimizedPath[optimizedPath.index++] = key;
      var nextNode = results[0];
      var nextParent = results[1];
      if (nextNode) {
        if (branch) {
          setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
        } else {
          promote(lru, nextNode);
          requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));
          optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));
        }
      }
      key = iterateKeySet(keySet, note);
      if (note.done) {
        break;
      }
      optimizedPath.index = optimizedIndex;
    } while (true);
  }
  function setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var reference = node.value;
    optimizedPath.splice(0, optimizedPath.length);
    optimizedPath.push.apply(optimizedPath, reference);
    if (isExpired(node)) {
      optimizedPath.index = reference.length;
      expireNode(node, expired, lru);
      return [undefined, root, message, messageRoot];
    }
    promote(lru, node);
    var index = 0;
    var container = node;
    var count = reference.length - 1;
    var parent = node = root;
    var messageParent = message = messageRoot;
    do {
      var key = reference[index];
      var branch = index < count;
      var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      node = results[0];
      if (isPrimitive(node)) {
        optimizedPath.index = index;
        return results;
      }
      parent = results[1];
      message = results[2];
      messageParent = results[3];
    } while (index++ < count);
    optimizedPath.index = index;
    if (container[__context] !== node) {
      var backRefs = node[__refsLength] || 0;
      node[__refsLength] = backRefs + 1;
      node[__ref + backRefs] = container;
      container[__context] = node;
      container[__refIndex] = backRefs;
    }
    return [node, parent, message, messageParent];
  }
  function setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var type = node.$type;
    while (type === $ref) {
      var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      node = results[0];
      if (isPrimitive(node)) {
        return results;
      }
      parent = results[1];
      message = results[2];
      messageParent = results[3];
      type = node.$type;
    }
    if (type !== void 0) {
      return [node, parent, message, messageParent];
    }
    if (key == null) {
      if (branch) {
        throw new Error("`null` is not allowed in branch key positions.");
      } else if (node) {
        key = node[__key];
      }
    } else {
      parent = node;
      messageParent = message;
      node = parent[key];
      message = messageParent && messageParent[key];
    }
    node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
    return [node, parent, message, messageParent];
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/hardlink", ["npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  function createHardlink(from, to) {
    var backRefs = to[__refsLength] || 0;
    to[__ref + backRefs] = from;
    to[__refsLength] = backRefs + 1;
    from[__refIndex] = backRefs;
    from[__context] = to;
  }
  function removeHardlink(cacheObject) {
    var context = cacheObject[__context];
    if (context) {
      var idx = cacheObject[__refIndex];
      var len = context[__refsLength];
      while (idx < len) {
        context[__ref + idx] = context[__ref + idx + 1];
        ++idx;
      }
      context[__refsLength] = len - 1;
      cacheObject[__context] = void 0;
      cacheObject[__refIndex] = void 0;
    }
  }
  module.exports = {
    create: createHardlink,
    remove: removeHardlink
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/lru", ["npm:falcor@0.1.13/lib/internal/head", "npm:falcor@0.1.13/lib/internal/tail", "npm:falcor@0.1.13/lib/internal/next", "npm:falcor@0.1.13/lib/internal/prev", "npm:falcor@0.1.13/lib/internal/invalidated"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __head = require("npm:falcor@0.1.13/lib/internal/head");
  var __tail = require("npm:falcor@0.1.13/lib/internal/tail");
  var __next = require("npm:falcor@0.1.13/lib/internal/next");
  var __prev = require("npm:falcor@0.1.13/lib/internal/prev");
  var __invalidated = require("npm:falcor@0.1.13/lib/internal/invalidated");
  function lruPromote(model, object) {
    var root = model._root;
    var head = root[__head];
    if (head === object) {
      return;
    }
    var prev = object[__prev];
    var next = object[__next];
    if (next) {
      next[__prev] = prev;
    }
    if (prev) {
      prev[__next] = next;
    }
    object[__prev] = void 0;
    root[__head] = object;
    object[__next] = head;
    head[__prev] = object;
  }
  function lruSplice(model, object) {
    var root = model._root;
    var prev = object[__prev];
    var next = object[__next];
    if (next) {
      next[__prev] = prev;
    }
    if (prev) {
      prev[__next] = next;
    }
    object[__prev] = void 0;
    if (object === root[__head]) {
      root[__head] = void 0;
    }
    if (object === root[__tail]) {
      root[__tail] = void 0;
    }
    object[__invalidated] = true;
    root.expired.push(object);
  }
  module.exports = {
    promote: lruPromote,
    splice: lruSplice
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/clone", ["npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  module.exports = function clone(node) {
    var outValue,
        i,
        len;
    var keys = Object.keys(node);
    outValue = {};
    for (i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      if (k[0] === prefix) {
        continue;
      }
      outValue[k] = node[k];
    }
    return outValue;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/types/atom", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "atom";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/onValue", ["npm:falcor@0.1.13/lib/get/util/lru", "npm:falcor@0.1.13/lib/get/util/clone", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/types/atom", "npm:falcor@0.1.13/lib/types/error", "npm:falcor@0.1.13/lib/internal/model-created"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lru = require("npm:falcor@0.1.13/lib/get/util/lru");
  var clone = require("npm:falcor@0.1.13/lib/get/util/clone");
  var promote = lru.promote;
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var $atom = require("npm:falcor@0.1.13/lib/types/atom");
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var $modelCreated = require("npm:falcor@0.1.13/lib/internal/model-created");
  module.exports = function onValue(model, node, seed, depth, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {
    if (!seed) {
      return;
    }
    var i,
        len,
        k,
        key,
        curr,
        prev,
        prevK;
    var materialized = false,
        valueNode;
    if (node) {
      promote(model, node);
    }
    if (!node || node.value === undefined) {
      materialized = model._materialized;
    }
    if (materialized) {
      valueNode = {$type: $atom};
    } else if (model._boxed) {
      valueNode = clone(node);
    } else if (node.$type === $ref || node.$type === $error) {
      if (isJSONG) {
        valueNode = clone(node);
      } else {
        valueNode = node.value;
      }
    } else if (isJSONG) {
      var isObject = node.value && typeof node.value === "object";
      var isUserCreatedNode = !node[$modelCreated];
      if (isObject || isUserCreatedNode) {
        valueNode = clone(node);
      } else {
        valueNode = node.value;
      }
    } else {
      valueNode = node.value;
    }
    if (outerResults) {
      outerResults.hasValue = true;
    }
    if (isJSONG) {
      curr = seed.jsonGraph;
      if (!curr) {
        curr = seed.jsonGraph = {};
        seed.paths = [];
      }
      for (i = 0, len = optimizedLength - 1; i < len; i++) {
        key = optimizedPath[i];
        if (!curr[key]) {
          curr[key] = {};
        }
        curr = curr[key];
      }
      key = optimizedPath[i];
      curr[key] = materialized ? {$type: $atom} : valueNode;
      if (requestedPath) {
        seed.paths.push(requestedPath.slice(0, depth));
      }
    } else if (depth === 0) {
      seed.json = valueNode;
    } else {
      curr = seed.json;
      if (!curr) {
        curr = seed.json = {};
      }
      for (i = 0; i < depth - 1; i++) {
        k = requestedPath[i];
        if (!curr[k]) {
          curr[k] = {};
        }
        prev = curr;
        prevK = k;
        curr = curr[k];
      }
      k = requestedPath[i];
      if (k !== null) {
        curr[k] = valueNode;
      } else {
        prev[prevK] = valueNode;
      }
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/isExpired", ["npm:falcor@0.1.13/lib/support/now"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var now = require("npm:falcor@0.1.13/lib/support/now");
  module.exports = function isExpired(node) {
    var $expires = node.$expires === void 0 && -1 || node.$expires;
    return $expires !== -1 && $expires !== 1 && ($expires === 0 || $expires < now());
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/followReference", ["npm:falcor@0.1.13/lib/get/util/hardlink", "npm:falcor@0.1.13/lib/get/onValue", "npm:falcor@0.1.13/lib/get/util/isExpired", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/get/util/lru"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hardLink = require("npm:falcor@0.1.13/lib/get/util/hardlink");
  var createHardlink = hardLink.create;
  var onValue = require("npm:falcor@0.1.13/lib/get/onValue");
  var isExpired = require("npm:falcor@0.1.13/lib/get/util/isExpired");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var promote = require("npm:falcor@0.1.13/lib/get/util/lru").promote;
  function followReference(model, root, nodeArg, referenceContainerArg, referenceArg, seed, isJSONG) {
    var node = nodeArg;
    var reference = referenceArg;
    var referenceContainer = referenceContainerArg;
    var depth = 0;
    var k,
        next;
    while (true) {
      if (depth === 0 && referenceContainer[__context]) {
        depth = reference.length;
        next = referenceContainer[__context];
      } else {
        k = reference[depth++];
        next = node[k];
      }
      if (next) {
        var type = next.$type;
        var value = type && next.value || next;
        if (depth < reference.length) {
          if (type) {
            node = next;
            break;
          }
          node = next;
          continue;
        } else {
          node = next;
          if (type && isExpired(next)) {
            break;
          }
          if (!referenceContainer[__context]) {
            createHardlink(referenceContainer, next);
          }
          if (type === $ref) {
            if (isJSONG) {
              onValue(model, next, seed, null, null, null, reference, reference.length, isJSONG);
            } else {
              promote(model, next);
            }
            depth = 0;
            reference = value;
            referenceContainer = next;
            node = root;
            continue;
          }
          break;
        }
      } else {
        node = void 0;
      }
      break;
    }
    if (depth < reference.length && node !== void 0) {
      var ref = [];
      for (var i = 0; i < depth; i++) {
        ref[i] = reference[i];
      }
      reference = ref;
    }
    return [node, reference];
  }
  module.exports = followReference;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getValueSync", ["npm:falcor@0.1.13/lib/get/followReference", "npm:falcor@0.1.13/lib/get/util/clone", "npm:falcor@0.1.13/lib/get/util/isExpired", "npm:falcor@0.1.13/lib/get/util/lru", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/types/atom", "npm:falcor@0.1.13/lib/types/error"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var followReference = require("npm:falcor@0.1.13/lib/get/followReference");
  var clone = require("npm:falcor@0.1.13/lib/get/util/clone");
  var isExpired = require("npm:falcor@0.1.13/lib/get/util/isExpired");
  var promote = require("npm:falcor@0.1.13/lib/get/util/lru").promote;
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var $atom = require("npm:falcor@0.1.13/lib/types/atom");
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  module.exports = function getValueSync(model, simplePath, noClone) {
    var root = model._root.cache;
    var len = simplePath.length;
    var optimizedPath = [];
    var shorted = false,
        shouldShort = false;
    var depth = 0;
    var key,
        i,
        next = root,
        curr = root,
        out = root,
        type,
        ref,
        refNode;
    var found = true;
    while (next && depth < len) {
      key = simplePath[depth++];
      if (key !== null) {
        next = curr[key];
        optimizedPath[optimizedPath.length] = key;
      }
      if (!next) {
        out = void 0;
        shorted = true;
        found = false;
        break;
      }
      type = next.$type;
      if (depth < len) {
        if (type === $ref) {
          ref = followReference(model, root, root, next, next.value);
          refNode = ref[0];
          if (!refNode) {
            out = void 0;
            next = void 0;
            break;
          }
          type = refNode.$type;
          next = refNode;
          optimizedPath = ref[1].slice(0);
        }
        if (type) {
          break;
        }
      } else {
        out = next;
      }
      curr = next;
    }
    if (depth < len) {
      for (i = depth; i < len; ++i) {
        if (simplePath[depth] !== null) {
          shouldShort = true;
          break;
        }
      }
      if (shouldShort) {
        shorted = true;
        out = void 0;
      } else {
        out = next;
      }
      for (i = depth; i < len; ++i) {
        optimizedPath[optimizedPath.length] = simplePath[i];
      }
    }
    if (out && type) {
      if (isExpired(out)) {
        out = void 0;
      } else {
        promote(model, out);
      }
    }
    if (out && type === $error && !model._treatErrorsAsValues) {
      throw {
        path: depth === len ? simplePath : simplePath.slice(0, depth),
        value: out.value
      };
    } else if (out && model._boxed) {
      out = Boolean(type) && !noClone ? clone(out) : out;
    } else if (!out && model._materialized) {
      out = {$type: $atom};
    } else if (out) {
      out = out.value;
    }
    return {
      value: out,
      shorted: shorted,
      optimizedPath: optimizedPath,
      found: found
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/errors/InvalidModelError", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var NAME = "InvalidModelError";
  var MESSAGE = "The boundPath of the model is not valid since a value or error was found before the path end.";
  function InvalidModelError(boundPath, shortedPath) {
    this.message = MESSAGE;
    this.stack = (new Error()).stack;
    this.boundPath = boundPath;
    this.shortedPath = shortedPath;
  }
  InvalidModelError.prototype = new Error();
  InvalidModelError.prototype.name = NAME;
  InvalidModelError.name = NAME;
  InvalidModelError.message = MESSAGE;
  module.exports = InvalidModelError;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getBoundValue", ["npm:falcor@0.1.13/lib/get/getValueSync", "npm:falcor@0.1.13/lib/errors/InvalidModelError"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getValueSync = require("npm:falcor@0.1.13/lib/get/getValueSync");
  var InvalidModelError = require("npm:falcor@0.1.13/lib/errors/InvalidModelError");
  module.exports = function getBoundValue(model, pathArg) {
    var path = pathArg;
    var boundPath = pathArg;
    var boxed,
        materialized,
        treatErrorsAsValues,
        value,
        shorted,
        found;
    boxed = model._boxed;
    materialized = model._materialized;
    treatErrorsAsValues = model._treatErrorsAsValues;
    model._boxed = true;
    model._materialized = true;
    model._treatErrorsAsValues = true;
    value = getValueSync(model, path.concat(null), true);
    model._boxed = boxed;
    model._materialized = materialized;
    model._treatErrorsAsValues = treatErrorsAsValues;
    path = value.optimizedPath;
    shorted = value.shorted;
    found = value.found;
    value = value.value;
    while (path.length && path[path.length - 1] === null) {
      path.pop();
    }
    if (found && shorted) {
      throw new InvalidModelError(boundPath, path);
    }
    return {
      path: path,
      value: value,
      shorted: shorted,
      found: found
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/getType", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function getType(node, anyType) {
    var type = isObject(node) && node.$type || void 0;
    if (anyType && type) {
      return "branch";
    }
    return type;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/mergeValueOrInsertBranch", ["npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/types/error", "npm:falcor@0.1.13/lib/support/getType", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/getTimestamp", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/wrapNode", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor@0.1.13/lib/support/insertNode", "npm:falcor@0.1.13/lib/support/replaceNode", "npm:falcor@0.1.13/lib/support/updateNodeAncestors", "npm:falcor@0.1.13/lib/support/updateBackReferenceVersions"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var getType = require("npm:falcor@0.1.13/lib/support/getType");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var getTimestamp = require("npm:falcor@0.1.13/lib/support/getTimestamp");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var wrapNode = require("npm:falcor@0.1.13/lib/support/wrapNode");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var insertNode = require("npm:falcor@0.1.13/lib/support/insertNode");
  var replaceNode = require("npm:falcor@0.1.13/lib/support/replaceNode");
  var updateNodeAncestors = require("npm:falcor@0.1.13/lib/support/updateNodeAncestors");
  var updateBackReferenceVersions = require("npm:falcor@0.1.13/lib/support/updateBackReferenceVersions");
  module.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var type = getType(node, reference);
    if (branch || reference) {
      if (type && isExpired(node)) {
        type = "expired";
        expireNode(node, expired, lru);
      }
      if ((type && type !== $ref) || isPrimitive(node)) {
        node = replaceNode(node, {}, parent, key, lru);
        node = insertNode(node, parent, key, version);
        node = updateBackReferenceVersions(node, version);
      }
    } else {
      var message = value;
      var mType = getType(message);
      var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;
      if ((type || mType) && isFunction(comparator)) {
        isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));
      }
      if (isDistinct) {
        message = wrapNode(message, mType, mType ? message.value : message);
        if (mType === $error && isFunction(errorSelector)) {
          message = errorSelector(requestedPath.slice(0, requestedPath.index), message);
        }
        var sizeOffset = getSize(node) - getSize(message);
        node = replaceNode(node, message, parent, key, lru);
        parent = updateNodeAncestors(parent, sizeOffset, lru, version);
        node = insertNode(node, parent, key, version);
      }
    }
    return node;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/set/setPathValues", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor-path-utils@0.3.4", "npm:falcor@0.1.13/lib/support/incrementVersion", "npm:falcor@0.1.13/lib/support/mergeValueOrInsertBranch"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4").iterateKeySet;
  var incrementVersion = require("npm:falcor@0.1.13/lib/support/incrementVersion");
  var mergeValueOrInsertBranch = require("npm:falcor@0.1.13/lib/support/mergeValueOrInsertBranch");
  module.exports = function setPathValues(model, pathValues, x, errorSelector, comparator) {
    var modelRoot = model._root;
    var lru = modelRoot;
    var expired = modelRoot.expired;
    var version = incrementVersion();
    var bound = model._path;
    var cache = modelRoot.cache;
    var node = bound.length ? getBoundValue(model, bound).value : cache;
    var parent = node[__parent] || cache;
    var initialVersion = cache[__version];
    var requestedPath = [];
    var requestedPaths = [];
    var optimizedPaths = [];
    var optimizedIndex = bound.length;
    var pathValueIndex = -1;
    var pathValueCount = pathValues.length;
    while (++pathValueIndex < pathValueCount) {
      var pathValue = pathValues[pathValueIndex];
      var path = pathValue.path;
      var value = pathValue.value;
      var optimizedPath = bound.slice(0);
      optimizedPath.index = optimizedIndex;
      setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
    }
    var newVersion = cache[__version];
    var rootChangeHandler = modelRoot.onChange;
    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
      rootChangeHandler();
    }
    return [requestedPaths, optimizedPaths];
  };
  function setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var note = {};
    var branch = depth < path.length - 1;
    var keySet = path[depth];
    var key = iterateKeySet(keySet, note);
    var optimizedIndex = optimizedPath.index;
    do {
      var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      requestedPath[depth] = key;
      requestedPath.index = depth;
      optimizedPath[optimizedPath.index++] = key;
      var nextNode = results[0];
      var nextParent = results[1];
      if (nextNode) {
        if (branch) {
          setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
        } else {
          promote(lru, nextNode);
          requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));
          optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));
        }
      }
      key = iterateKeySet(keySet, note);
      if (note.done) {
        break;
      }
      optimizedPath.index = optimizedIndex;
    } while (true);
  }
  function setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var reference = node.value;
    optimizedPath.splice(0, optimizedPath.length);
    optimizedPath.push.apply(optimizedPath, reference);
    if (isExpired(node)) {
      optimizedPath.index = reference.length;
      expireNode(node, expired, lru);
      return [undefined, root];
    }
    promote(lru, node);
    var container = node;
    var parent = root;
    node = node[__context];
    if (node != null) {
      parent = node[__parent] || root;
      optimizedPath.index = reference.length;
    } else {
      var index = 0;
      var count = reference.length - 1;
      parent = node = root;
      do {
        var key = reference[index];
        var branch = index < count;
        var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
        node = results[0];
        if (isPrimitive(node)) {
          optimizedPath.index = index;
          return results;
        }
        parent = results[1];
      } while (index++ < count);
      optimizedPath.index = index;
      if (container[__context] !== node) {
        var backRefs = node[__refsLength] || 0;
        node[__refsLength] = backRefs + 1;
        node[__ref + backRefs] = container;
        container[__context] = node;
        container[__refIndex] = backRefs;
      }
    }
    return [node, parent];
  }
  function setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var type = node.$type;
    while (type === $ref) {
      var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      node = results[0];
      if (isPrimitive(node)) {
        return results;
      }
      parent = results[1];
      type = node.$type;
    }
    if (type !== void 0) {
      return [node, parent];
    }
    if (key == null) {
      if (branch) {
        throw new Error("`null` is not allowed in branch key positions.");
      } else if (node) {
        key = node[__key];
      }
    } else {
      parent = node;
      node = parent[key];
    }
    node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
    return [node, parent];
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/SetRequest", ["npm:rx@2.5.3/dist/rx", "npm:falcor@0.1.13/lib/request/Request", "npm:falcor@0.1.13/lib/support/array-map", "npm:falcor@0.1.13/lib/set/setJSONGraphs", "npm:falcor@0.1.13/lib/set/setPathValues"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Observer = Rx.Observer;
  var Request = require("npm:falcor@0.1.13/lib/request/Request");
  var arrayMap = require("npm:falcor@0.1.13/lib/support/array-map");
  var setJSONGraphs = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  var setPathValues = require("npm:falcor@0.1.13/lib/set/setPathValues");
  var emptyArray = new Array(0);
  function SetRequest() {
    Request.call(this);
  }
  SetRequest.create = function create(model, jsonGraphEnvelope) {
    var request = new SetRequest();
    request.model = model;
    request.jsonGraphEnvelope = jsonGraphEnvelope;
    return request;
  };
  SetRequest.prototype = Object.create(Request.prototype);
  SetRequest.prototype.constructor = SetRequest;
  SetRequest.prototype.method = "set";
  SetRequest.prototype.insertPath = function() {
    return false;
  };
  SetRequest.prototype.removePath = function() {
    return 0;
  };
  SetRequest.prototype.getSourceArgs = function getSourceArgs() {
    return this.jsonGraphEnvelope;
  };
  SetRequest.prototype.getSourceObserver = function getSourceObserver(observer) {
    var model = this.model;
    var bound = model._path;
    var paths = this.jsonGraphEnvelope.paths;
    var modelRoot = model._root;
    var errorSelector = modelRoot.errorSelector;
    var comparator = modelRoot.comparator;
    return Request.prototype.getSourceObserver.call(this, Observer.create(function onNext(jsonGraphEnvelope) {
      model._path = emptyArray;
      var successfulPaths = setJSONGraphs(model, [{
        paths: paths,
        jsonGraph: jsonGraphEnvelope.jsonGraph
      }], null, errorSelector, comparator);
      jsonGraphEnvelope.paths = successfulPaths[1];
      model._path = bound;
      observer.onNext(jsonGraphEnvelope);
    }, function onError(error) {
      model._path = emptyArray;
      setPathValues(model, arrayMap(paths, function(path) {
        return {
          path: path,
          value: error
        };
      }), null, errorSelector, comparator);
      model._path = bound;
      observer.onError(error);
    }, function onCompleted() {
      observer.onCompleted();
    }));
  };
  module.exports = SetRequest;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/RequestQueue", ["npm:falcor@0.1.13/lib/request/SetRequest", "npm:falcor@0.1.13/lib/internal/prefix", "npm:falcor@0.1.13/lib/support/getType", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor-path-utils@0.3.4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SetRequest = require("npm:falcor@0.1.13/lib/request/SetRequest");
  var prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  var getType = require("npm:falcor@0.1.13/lib/support/getType");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var falcorPathUtils = require("npm:falcor-path-utils@0.3.4");
  function RequestQueue(model, scheduler) {
    this.total = 0;
    this.model = model;
    this.requests = [];
    this.scheduler = scheduler;
  }
  RequestQueue.prototype.set = function setRequest(jsonGraphEnvelope) {
    jsonGraphEnvelope.paths = falcorPathUtils.collapse(jsonGraphEnvelope.paths);
    return SetRequest.create(this.model, jsonGraphEnvelope);
  };
  RequestQueue.prototype._remove = function removeRequest(request) {
    var requests = this.requests;
    var index = requests.indexOf(request);
    if (index !== -1) {
      requests.splice(index, 1);
    }
  };
  RequestQueue.prototype.distributePaths = function distributePathsAcrossRequests(paths, requests, RequestType) {
    var model = this.model;
    var pathsIndex = -1;
    var pathsCount = paths.length;
    var requestIndex = -1;
    var requestCount = requests.length;
    var participatingRequests = [];
    var pendingRequest;
    var request;
    insertPath: while (++pathsIndex < pathsCount) {
      var path = paths[pathsIndex];
      requestIndex = -1;
      while (++requestIndex < requestCount) {
        request = requests[requestIndex];
        if (request.insertPath(path, request.pending)) {
          participatingRequests[requestIndex] = request;
          continue insertPath;
        }
      }
      if (!pendingRequest) {
        pendingRequest = RequestType.create(this, model, this.total++);
        requests[requestIndex] = pendingRequest;
        participatingRequests[requestCount++] = pendingRequest;
      }
      pendingRequest.insertPath(path, false);
    }
    var pathRequests = [];
    var pathRequestsIndex = -1;
    requestIndex = -1;
    while (++requestIndex < requestCount) {
      request = participatingRequests[requestIndex];
      if (request != null) {
        pathRequests[++pathRequestsIndex] = request;
      }
    }
    return pathRequests;
  };
  RequestQueue.prototype.mergeJSONGraphs = function mergeJSONGraphs(aggregate, response) {
    var depth = 0;
    var contexts = [];
    var messages = [];
    var keystack = [];
    var latestIndex = aggregate.index;
    var responseIndex = response.index;
    aggregate.index = Math.max(latestIndex, responseIndex);
    contexts[-1] = aggregate.jsonGraph || {};
    messages[-1] = response.jsonGraph || {};
    recursing: while (depth > -1) {
      var context = contexts[depth - 1];
      var message = messages[depth - 1];
      var keys = keystack[depth - 1] || (keystack[depth - 1] = Object.keys(message));
      while (keys.length > 0) {
        var key = keys.pop();
        if (key[0] === prefix) {
          continue;
        }
        if (context.hasOwnProperty(key)) {
          var node = context[key];
          var nodeType = getType(node);
          var messageNode = message[key];
          var messageType = getType(messageNode);
          if (isObject(node) && isObject(messageNode) && !nodeType && !messageType) {
            contexts[depth] = node;
            messages[depth] = messageNode;
            depth += 1;
            continue recursing;
          } else if (responseIndex > latestIndex) {
            context[key] = messageNode;
          }
        } else {
          context[key] = message[key];
        }
      }
      depth -= 1;
    }
    return aggregate;
  };
  module.exports = RequestQueue;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/RequestTypes", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {GetRequest: "GET"};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/array-slice", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function arraySlice(array, indexArg, endArg) {
    var index = indexArg || 0;
    var i = -1;
    var n = array.length - index;
    if (n < 0) {
      n = 0;
    }
    if (endArg > 0 && n > endArg) {
      n = endArg;
    }
    var array2 = new Array(n);
    while (++i < n) {
      array2[i] = array[i + index];
    }
    return array2;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/complement", ["npm:falcor-path-utils@0.3.4", "npm:falcor@0.1.13/lib/support/array-slice"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasIntersection = require("npm:falcor-path-utils@0.3.4").hasIntersection;
  var arraySlice = require("npm:falcor@0.1.13/lib/support/array-slice");
  module.exports = function complement(requested, optimized, tree) {
    var optimizedComplement = [];
    var requestedComplement = [];
    var requestedIntersection = [];
    var intersectionLength = -1,
        complementLength = -1;
    var intersectionFound = false;
    for (var i = 0,
        len = optimized.length; i < len; ++i) {
      var path = optimized[i];
      var subTree = tree[path.length];
      if (!subTree || !hasIntersection(subTree, path, 0)) {
        if (intersectionFound) {
          optimizedComplement[++complementLength] = path;
          requestedComplement[complementLength] = requested[i];
        }
      } else {
        if (!intersectionFound && i > 0) {
          requestedComplement = arraySlice(requested, 0, i);
          optimizedComplement = arraySlice(optimized, 0, i);
        }
        requestedIntersection[++intersectionLength] = requested[i];
        intersectionFound = true;
      }
    }
    if (!intersectionFound) {
      return null;
    }
    return [requestedIntersection, optimizedComplement, requestedComplement];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/flushGetRequest", ["npm:falcor-path-utils@0.3.4"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var pathUtils = require("npm:falcor-path-utils@0.3.4");
  var toTree = pathUtils.toTree;
  var toPaths = pathUtils.toPaths;
  module.exports = function flushGetRequest(request, listOfPaths, callback) {
    if (request._count === 0) {
      request.requestQueue.removeRequest(request);
      return;
    }
    request.sent = true;
    request.scheduled = false;
    var pathMap = request._pathMap;
    var listKeys = Object.keys(listOfPaths);
    var listIdx = 0,
        listLen = listKeys.length;
    for (; listIdx < listLen; ++listIdx) {
      var paths = listOfPaths[listIdx];
      for (var j = 0,
          pathLen = paths.length; j < pathLen; ++j) {
        var pathSet = paths[j];
        var len = pathSet.length;
        if (!pathMap[len]) {
          pathMap[len] = [pathSet];
        } else {
          var pathSetsByLength = pathMap[len];
          pathSetsByLength[pathSetsByLength.length] = pathSet;
        }
      }
    }
    var pathMapKeys = Object.keys(pathMap);
    var pathMapIdx = 0,
        pathMapLen = pathMapKeys.length;
    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {
      var pathMapKey = pathMapKeys[pathMapIdx];
      pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);
    }
    var collapsedPaths = request._collasped = toPaths(pathMap);
    var jsonGraphData;
    request.requestQueue.model._source.get(collapsedPaths).subscribe(function(data) {
      jsonGraphData = data;
    }, function(err) {
      callback(err, jsonGraphData);
    }, function() {
      callback(null, jsonGraphData);
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/GetRequestV2", ["npm:falcor@0.1.13/lib/request/complement", "npm:falcor@0.1.13/lib/request/flushGetRequest", "npm:falcor@0.1.13/lib/request/RequestTypes", "npm:falcor@0.1.13/lib/set/setJSONGraphs", "npm:falcor@0.1.13/lib/set/setPathValues", "npm:falcor@0.1.13/lib/types/error"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var complement = require("npm:falcor@0.1.13/lib/request/complement");
  var flushGetRequest = require("npm:falcor@0.1.13/lib/request/flushGetRequest");
  var REQUEST_ID = 0;
  var GetRequestType = require("npm:falcor@0.1.13/lib/request/RequestTypes").GetRequest;
  var setJSONGraphs = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  var setPathValues = require("npm:falcor@0.1.13/lib/set/setPathValues");
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var emptyArray = [];
  var GetRequestV2 = function(scheduler, requestQueue) {
    this.sent = false;
    this.scheduled = false;
    this.requestQueue = requestQueue;
    this.id = ++REQUEST_ID;
    this.type = GetRequestType;
    this._scheduler = scheduler;
    this._pathMap = {};
    this._optimizedPaths = [];
    this._requestedPaths = [];
    this._callbacks = [];
    this._count = 0;
    this._disposable = null;
    this._collapsed = null;
    this._disposed = false;
  };
  GetRequestV2.prototype = {
    batch: function(requestedPaths, optimizedPaths, callback) {
      var self = this;
      var oPaths = self._optimizedPaths;
      var rPaths = self._requestedPaths;
      var callbacks = self._callbacks;
      var idx = oPaths.length;
      oPaths[idx] = optimizedPaths;
      rPaths[idx] = requestedPaths;
      callbacks[idx] = callback;
      ++self._count;
      if (!self.scheduled) {
        self.scheduled = true;
        self._disposable = self._scheduler.schedule(function() {
          flushGetRequest(self, oPaths, function(err, data) {
            self.requestQueue.removeRequest(self);
            self._disposed = true;
            if (self._count) {
              self._merge(rPaths, err, data);
              for (var i = 0,
                  len = callbacks.length; i < len; ++i) {
                var fn = callbacks[i];
                if (fn) {
                  fn(err, data);
                }
              }
            }
          });
        });
      }
      return createDisposable(self, idx);
    },
    add: function(requested, optimized, callback) {
      var self = this;
      var complementTuple = complement(requested, optimized, self._pathMap);
      var optimizedComplement;
      var requestedComplement;
      if (complementTuple) {
        requestedComplement = complementTuple[2];
        optimizedComplement = complementTuple[1];
      } else {
        requestedComplement = requested;
        optimizedComplement = optimized;
      }
      var inserted = false;
      var disposable = false;
      if (optimizedComplement.length < optimized.length) {
        inserted = true;
        var idx = self._callbacks.length;
        self._callbacks[idx] = callback;
        self._requestedPaths[idx] = complementTuple[0];
        self._optimizedPaths[idx] = [];
        ++self._count;
        disposable = createDisposable(self, idx);
      }
      return [inserted, requestedComplement, optimizedComplement, disposable];
    },
    _merge: function(requested, err, data) {
      var self = this;
      var model = self.requestQueue.model;
      var modelRoot = model._root;
      var errorSelector = modelRoot.errorSelector;
      var comparator = modelRoot.comparator;
      var boundPath = model._path;
      model._path = emptyArray;
      var nextPaths = flattenRequestedPaths(requested);
      if (err) {
        var error = err;
        if (error instanceof Error) {
          error = {message: error.message};
        }
        if (!error.$type) {
          error = {
            $type: $error,
            value: error
          };
        }
        var pathValues = nextPaths.map(function(x) {
          return {
            path: x,
            value: error
          };
        });
        setPathValues(model, pathValues, null, errorSelector, comparator);
      } else {
        setJSONGraphs(model, [{
          paths: nextPaths,
          jsonGraph: data.jsonGraph
        }], null, errorSelector, comparator);
      }
      model._path = boundPath;
    }
  };
  function createDisposable(request, idx) {
    var disposed = false;
    return function() {
      if (disposed || request._disposed) {
        return;
      }
      disposed = true;
      request._callbacks[idx] = null;
      request._optimizedPaths[idx] = [];
      request._requestedPaths[idx] = [];
      var count = --request._count;
      if (count === 0 && !request.sent) {
        request._disposable.dispose();
        request.requestQueue.removeRequest(request);
      }
    };
  }
  function flattenRequestedPaths(requested) {
    var out = [];
    var outLen = -1;
    for (var i = 0,
        len = requested.length; i < len; ++i) {
      var paths = requested[i];
      for (var j = 0,
          innerLen = paths.length; j < innerLen; ++j) {
        out[++outLen] = paths[j];
      }
    }
    return out;
  }
  module.exports = GetRequestV2;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/RequestQueueV2", ["npm:falcor@0.1.13/lib/request/RequestTypes", "npm:falcor@0.1.13/lib/request/GetRequestV2", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var RequestTypes = require("npm:falcor@0.1.13/lib/request/RequestTypes");
    var GetRequest = require("npm:falcor@0.1.13/lib/request/GetRequestV2");
    function RequestQueueV2(model, scheduler) {
      this.model = model;
      this.scheduler = scheduler;
      this.requests = this._requests = [];
    }
    RequestQueueV2.prototype = {
      setScheduler: function(scheduler) {
        this.scheduler = scheduler;
      },
      get: function(requestedPaths, optimizedPaths, cb) {
        var self = this;
        var disposables = [];
        var count = 0;
        var requests = self._requests;
        var i,
            len;
        var oRemainingPaths = optimizedPaths;
        var rRemainingPaths = requestedPaths;
        var disposed = false;
        var request;
        for (i = 0, len = requests.length; i < len; ++i) {
          request = requests[i];
          if (request.type !== RequestTypes.GetRequest) {
            continue;
          }
          if (request.sent) {
            var results = request.add(rRemainingPaths, oRemainingPaths, refCountCallback);
            if (results[0]) {
              rRemainingPaths = results[1];
              oRemainingPaths = results[2];
              disposables[disposables.length] = results[3];
              ++count;
            }
          } else {
            request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);
            oRemainingPaths = [];
            rRemainingPaths = [];
            ++count;
          }
          if (!oRemainingPaths.length) {
            break;
          }
        }
        if (oRemainingPaths.length) {
          request = new GetRequest(self.scheduler, self);
          requests[requests.length] = request;
          ++count;
          var disposable = request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);
          disposables[disposables.length] = disposable;
        }
        function refCountCallback() {
          if (disposed) {
            return;
          }
          --count;
          if (count === 0) {
            cb();
          }
        }
        return function() {
          if (disposed || count === 0) {
            return;
          }
          disposed = true;
          var length = disposables.length;
          for (var idx = 0; idx < length; ++idx) {
            disposables[idx]();
          }
        };
      },
      removeRequest: function(request) {
        var requests = this._requests;
        var i = requests.length;
        while (--i >= 0) {
          if (requests[i].id === request.id) {
            requests.splice(i, 1);
            break;
          }
        }
      }
    };
    module.exports = RequestQueueV2;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/request/RequestQueueRx", ["npm:falcor@0.1.13/lib/request/RequestQueue", "npm:falcor@0.1.13/lib/request/RequestQueueV2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var RequestQueue = require("npm:falcor@0.1.13/lib/request/RequestQueue");
  var RequestQueueV2 = require("npm:falcor@0.1.13/lib/request/RequestQueueV2");
  function RequestQueueRx(model, scheduler) {
    this.model = model;
    this.scheduler = scheduler;
    this.requests = this._requests = [];
  }
  RequestQueueRx.prototype.get = RequestQueueV2.prototype.get;
  RequestQueueRx.prototype.removeRequest = RequestQueueV2.prototype.removeRequest;
  RequestQueueRx.prototype.set = RequestQueue.prototype.set;
  RequestQueueRx.prototype.call = RequestQueue.prototype.call;
  module.exports = RequestQueueRx;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@2.5.3/dist/rx.aggregates", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        CompositeDisposable = Rx.CompositeDisposable,
        AnonymousObservable = Rx.AnonymousObservable,
        disposableEmpty = Rx.Disposable.empty,
        isEqual = Rx.internals.isEqual,
        helpers = Rx.helpers,
        not = helpers.not,
        defaultComparer = helpers.defaultComparer,
        identity = helpers.identity,
        defaultSubComparer = helpers.defaultSubComparer,
        isFunction = helpers.isFunction,
        isPromise = helpers.isPromise,
        isArrayLike = helpers.isArrayLike,
        isIterable = helpers.isIterable,
        inherits = Rx.internals.inherits,
        observableFromPromise = Observable.fromPromise,
        observableFrom = Observable.from,
        bindCallback = Rx.internals.bindCallback,
        EmptyError = Rx.EmptyError,
        ObservableBase = Rx.ObservableBase,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function extremaBy(source, keySelector, comparer) {
      return new AnonymousObservable(function(o) {
        var hasValue = false,
            lastKey = null,
            list = [];
        return source.subscribe(function(x) {
          var comparison,
              key;
          try {
            key = keySelector(x);
          } catch (ex) {
            o.onError(ex);
            return;
          }
          comparison = 0;
          if (!hasValue) {
            hasValue = true;
            lastKey = key;
          } else {
            try {
              comparison = comparer(key, lastKey);
            } catch (ex1) {
              o.onError(ex1);
              return;
            }
          }
          if (comparison > 0) {
            lastKey = key;
            list = [];
          }
          if (comparison >= 0) {
            list.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(list);
          o.onCompleted();
        });
      }, source);
    }
    function firstOnly(x) {
      if (x.length === 0) {
        throw new EmptyError();
      }
      return x[0];
    }
    observableProto.aggregate = function() {
      var hasSeed = false,
          accumulator,
          seed,
          source = this;
      if (arguments.length === 2) {
        hasSeed = true;
        seed = arguments[0];
        accumulator = arguments[1];
      } else {
        accumulator = arguments[0];
      }
      return new AnonymousObservable(function(o) {
        var hasAccumulation,
            accumulation,
            hasValue;
        return source.subscribe(function(x) {
          !hasValue && (hasValue = true);
          try {
            if (hasAccumulation) {
              accumulation = accumulator(accumulation, x);
            } else {
              accumulation = hasSeed ? accumulator(seed, x) : x;
              hasAccumulation = true;
            }
          } catch (e) {
            return o.onError(e);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          hasValue && o.onNext(accumulation);
          !hasValue && hasSeed && o.onNext(seed);
          !hasValue && !hasSeed && o.onError(new EmptyError());
          o.onCompleted();
        });
      }, source);
    };
    var ReduceObservable = (function(__super__) {
      inherits(ReduceObservable, __super__);
      function ReduceObservable(source, acc, hasSeed, seed) {
        this.source = source;
        this.acc = acc;
        this.hasSeed = hasSeed;
        this.seed = seed;
        __super__.call(this);
      }
      ReduceObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new InnerObserver(observer, this));
      };
      function InnerObserver(o, parent) {
        this.o = o;
        this.acc = parent.acc;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.result = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return;
        }
        !this.hasValue && (this.hasValue = true);
        if (this.hasAccumulation) {
          this.result = tryCatch(this.acc)(this.result, x);
        } else {
          this.result = this.hasSeed ? tryCatch(this.acc)(this.seed, x) : x;
          this.hasAccumulation = true;
        }
        if (this.result === errorObj) {
          this.o.onError(this.result.e);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasValue && this.o.onNext(this.result);
          !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
          !this.hasValue && !this.hasSeed && this.o.onError(new EmptyError());
          this.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      return ReduceObservable;
    }(ObservableBase));
    observableProto.reduce = function(accumulator) {
      var hasSeed = false;
      if (arguments.length === 2) {
        hasSeed = true;
        var seed = arguments[1];
      }
      return new ReduceObservable(this, accumulator, hasSeed, seed);
    };
    observableProto.some = function(predicate, thisArg) {
      var source = this;
      return predicate ? source.filter(predicate, thisArg).some() : new AnonymousObservable(function(observer) {
        return source.subscribe(function() {
          observer.onNext(true);
          observer.onCompleted();
        }, function(e) {
          observer.onError(e);
        }, function() {
          observer.onNext(false);
          observer.onCompleted();
        });
      }, source);
    };
    observableProto.any = function() {
      return this.some.apply(this, arguments);
    };
    observableProto.isEmpty = function() {
      return this.any().map(not);
    };
    observableProto.every = function(predicate, thisArg) {
      return this.filter(function(v) {
        return !predicate(v);
      }, thisArg).some().map(not);
    };
    observableProto.all = function() {
      return this.every.apply(this, arguments);
    };
    observableProto.includes = function(searchElement, fromIndex) {
      var source = this;
      function comparer(a, b) {
        return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
      }
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(false);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i++ >= n && comparer(x, searchElement)) {
            o.onNext(true);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(false);
          o.onCompleted();
        });
      }, this);
    };
    observableProto.contains = function(searchElement, fromIndex) {
      observableProto.includes(searchElement, fromIndex);
    };
    observableProto.count = function(predicate, thisArg) {
      return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
        return count + 1;
      }, 0);
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(-1);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i >= n && x === searchElement) {
            o.onNext(i);
            o.onCompleted();
          }
          i++;
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(-1);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.sum = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
        return prev + curr;
      }, 0);
    };
    observableProto.minBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, function(x, y) {
        return comparer(x, y) * -1;
      });
    };
    observableProto.min = function(comparer) {
      return this.minBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.maxBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, comparer);
    };
    observableProto.max = function(comparer) {
      return this.maxBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.average = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).average() : this.reduce(function(prev, cur) {
        return {
          sum: prev.sum + cur,
          count: prev.count + 1
        };
      }, {
        sum: 0,
        count: 0
      }).map(function(s) {
        if (s.count === 0) {
          throw new EmptyError();
        }
        return s.sum / s.count;
      });
    };
    observableProto.sequenceEqual = function(second, comparer) {
      var first = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var donel = false,
            doner = false,
            ql = [],
            qr = [];
        var subscription1 = first.subscribe(function(x) {
          var equal,
              v;
          if (qr.length > 0) {
            v = qr.shift();
            try {
              equal = comparer(v, x);
            } catch (e) {
              o.onError(e);
              return;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (doner) {
            o.onNext(false);
            o.onCompleted();
          } else {
            ql.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          donel = true;
          if (ql.length === 0) {
            if (qr.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (doner) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
        isPromise(second) && (second = observableFromPromise(second));
        var subscription2 = second.subscribe(function(x) {
          var equal;
          if (ql.length > 0) {
            var v = ql.shift();
            try {
              equal = comparer(v, x);
            } catch (exception) {
              o.onError(exception);
              return;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (donel) {
            o.onNext(false);
            o.onCompleted();
          } else {
            qr.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          doner = true;
          if (qr.length === 0) {
            if (ql.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (donel) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        return new CompositeDisposable(subscription1, subscription2);
      }, first);
    };
    function elementAtOrDefault(source, index, hasDefault, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError();
      }
      return new AnonymousObservable(function(o) {
        var i = index;
        return source.subscribe(function(x) {
          if (i-- === 0) {
            o.onNext(x);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new ArgumentOutOfRangeError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.elementAt = function(index) {
      return elementAtOrDefault(this, index, false);
    };
    observableProto.elementAtOrDefault = function(index, defaultValue) {
      return elementAtOrDefault(this, index, true, defaultValue);
    };
    function singleOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          if (seenValue) {
            o.onError(new Error('Sequence contains more than one element'));
          } else {
            value = x;
            seenValue = true;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.single = function(predicate, thisArg) {
      return predicate && isFunction(predicate) ? this.where(predicate, thisArg).single() : singleOrDefaultAsync(this, false);
    };
    observableProto.singleOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate && isFunction(predicate) ? this.filter(predicate, thisArg).singleOrDefault(null, defaultValue) : singleOrDefaultAsync(this, true, defaultValue);
    };
    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        return source.subscribe(function(x) {
          o.onNext(x);
          o.onCompleted();
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.first = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).first() : firstOrDefaultAsync(this, false);
    };
    observableProto.firstOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate).firstOrDefault(null, defaultValue) : firstOrDefaultAsync(this, true, defaultValue);
    };
    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          value = x;
          seenValue = true;
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.last = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).last() : lastOrDefaultAsync(this, false);
    };
    observableProto.lastOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate, thisArg).lastOrDefault(null, defaultValue) : lastOrDefaultAsync(this, true, defaultValue);
    };
    function findValue(source, predicate, thisArg, yieldIndex) {
      var callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0;
        return source.subscribe(function(x) {
          var shouldRun;
          try {
            shouldRun = callback(x, i, source);
          } catch (e) {
            o.onError(e);
            return;
          }
          if (shouldRun) {
            o.onNext(yieldIndex ? i : x);
            o.onCompleted();
          } else {
            i++;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(yieldIndex ? -1 : undefined);
          o.onCompleted();
        });
      }, source);
    }
    observableProto.find = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, false);
    };
    observableProto.findIndex = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, true);
    };
    observableProto.toSet = function() {
      if (typeof root.Set === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var s = new root.Set();
        return source.subscribe(function(x) {
          s.add(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(s);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.toMap = function(keySelector, elementSelector) {
      if (typeof root.Map === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var m = new root.Map();
        return source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            o.onError(e);
            return;
          }
          var element = x;
          if (elementSelector) {
            try {
              element = elementSelector(x);
            } catch (e) {
              o.onError(e);
              return;
            }
          }
          m.set(key, element);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(m);
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/noop", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function noop() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/ModelResponse", ["npm:falcor@0.1.13/lib/index", "npm:rx@2.5.3/dist/rx", "npm:rx@2.5.3/dist/rx.aggregates", "npm:falcor@0.1.13/lib/support/array-slice", "npm:falcor@0.1.13/lib/support/noop"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var falcor = require("npm:falcor@0.1.13/lib/index");
  var Rx = require("npm:rx@2.5.3/dist/rx") && require("npm:rx@2.5.3/dist/rx.aggregates");
  var Observable = Rx.Observable;
  var arraySlice = require("npm:falcor@0.1.13/lib/support/array-slice");
  var noop = require("npm:falcor@0.1.13/lib/support/noop");
  var jsongMixin = {outputFormat: {value: "AsJSONG"}};
  var progressiveMixin = {isProgressive: {value: true}};
  function ModelResponse(subscribe) {
    this._subscribe = subscribe;
  }
  ModelResponse.create = function create(model, args) {
    var response = new ModelResponse(subscribeToResponse);
    response.args = args;
    response.type = this;
    response.model = model;
    return response;
  };
  ModelResponse.prototype = Object.create(Observable.prototype);
  ModelResponse.prototype.constructor = ModelResponse;
  ModelResponse.prototype._mixin = function mixin() {
    var self = this;
    var mixins = arraySlice(arguments);
    return new self.constructor(function(observer) {
      return self.subscribe(mixins.reduce(function(proto, mixin2) {
        return Object.create(proto, mixin2);
      }, observer));
    });
  };
  ModelResponse.prototype._toJSONG = function toJSONG() {
    return this._mixin(jsongMixin);
  };
  ModelResponse.prototype.progressively = function progressively() {
    return this._mixin(progressiveMixin);
  };
  ModelResponse.prototype.subscribe = function subscribe(a, b, c) {
    var observer = a;
    if (!observer || typeof observer !== "object") {
      observer = {
        onNext: a || noop,
        onError: b || noop,
        onCompleted: c || noop
      };
    }
    var subscription = this._subscribe(observer);
    switch (typeof subscription) {
      case "function":
        return {dispose: subscription};
      case "object":
        return subscription || {dispose: noop};
      default:
        return {dispose: noop};
    }
  };
  ModelResponse.prototype.then = function then(onNext, onError) {
    var self = this;
    return new falcor.Promise(function(resolve, reject) {
      var value,
          rejected = false;
      self.toArray().subscribe(function(values) {
        if (values.length <= 1) {
          value = values[0];
        } else {
          value = values;
        }
      }, function(errors) {
        rejected = true;
        reject(errors);
      }, function() {
        if (rejected === false) {
          resolve(value);
        }
      });
    }).then(onNext, onError);
  };
  function subscribeToResponse(observer) {
    var model = this.model;
    var response = new this.type();
    response.model = model;
    response.args = this.args;
    response.outputFormat = observer.outputFormat || "AsPathMap";
    response.isProgressive = observer.isProgressive || false;
    response.subscribeCount = 0;
    response.subscribeLimit = observer.retryLimit || 10;
    return (response.initialize().invokeSourceRequest(model).ensureCollect(model).subscribe(observer));
  }
  module.exports = ModelResponse;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/SHORTED", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = 1;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getCachePosition", ["npm:falcor@0.1.13/lib/get/SHORTED"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SHORTED = require("npm:falcor@0.1.13/lib/get/SHORTED");
  module.exports = function getCachePosition(model, path) {
    var currentCachePosition = model._root.cache;
    var depth = -1;
    var maxDepth = path.length;
    while (++depth < maxDepth && currentCachePosition && !currentCachePosition.$type) {
      currentCachePosition = currentCachePosition[path[depth]];
    }
    if (depth !== maxDepth && currentCachePosition) {
      return SHORTED;
    }
    return currentCachePosition;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/errors/BoundJSONGraphModelError", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function BoundJSONGraphModelError() {
    this.message = BoundJSONGraphModelError.message;
    this.stack = (new Error()).stack;
  }
  BoundJSONGraphModelError.prototype = new Error();
  BoundJSONGraphModelError.prototype.name = "BoundJSONGraphModelError";
  BoundJSONGraphModelError.message = "It is not legal to use the JSON Graph " + "format from a bound Model. JSON Graph format" + " can only be used from a root model.";
  module.exports = BoundJSONGraphModelError;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/get", ["npm:falcor@0.1.13/lib/get/getCachePosition", "npm:falcor@0.1.13/lib/errors/InvalidModelError", "npm:falcor@0.1.13/lib/errors/BoundJSONGraphModelError", "npm:falcor@0.1.13/lib/get/SHORTED"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getCachePosition = require("npm:falcor@0.1.13/lib/get/getCachePosition");
  var InvalidModelError = require("npm:falcor@0.1.13/lib/errors/InvalidModelError");
  var BoundJSONGraphModelError = require("npm:falcor@0.1.13/lib/errors/BoundJSONGraphModelError");
  var SHORTED = require("npm:falcor@0.1.13/lib/get/SHORTED");
  module.exports = function get(walk, isJSONG) {
    return function innerGet(model, paths, seed) {
      var valueNode = seed[0];
      var results = {
        values: seed,
        optimizedPaths: []
      };
      var cache = model._root.cache;
      var boundPath = model._path;
      var currentCachePosition = cache;
      var optimizedPath,
          optimizedLength = boundPath.length;
      var i,
          len;
      var requestedPath = [];
      if (optimizedLength) {
        if (isJSONG) {
          return {criticalError: new BoundJSONGraphModelError()};
        }
        currentCachePosition = getCachePosition(model, boundPath);
        if (currentCachePosition === SHORTED) {
          return {criticalError: new InvalidModelError(boundPath, boundPath)};
        }
        optimizedPath = [];
        for (i = 0; i < optimizedLength; ++i) {
          optimizedPath[i] = boundPath[i];
        }
      } else {
        optimizedPath = [];
        optimizedLength = 0;
      }
      for (i = 0, len = paths.length; i < len; i++) {
        walk(model, cache, currentCachePosition, paths[i], 0, valueNode, results, requestedPath, optimizedPath, optimizedLength, isJSONG);
      }
      return results;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/onError", ["npm:falcor@0.1.13/lib/get/util/lru", "npm:falcor@0.1.13/lib/get/util/clone"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lru = require("npm:falcor@0.1.13/lib/get/util/lru");
  var clone = require("npm:falcor@0.1.13/lib/get/util/clone");
  var promote = lru.promote;
  module.exports = function onError(model, node, depth, requestedPath, outerResults) {
    var value = node.value;
    if (!outerResults.errors) {
      outerResults.errors = [];
    }
    if (model._boxed) {
      value = clone(node);
    }
    outerResults.errors.push({
      path: requestedPath.slice(0, depth + 1),
      value: value
    });
    promote(model, node);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/support", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function fastCopy(arr, iArg) {
    var a = [],
        len,
        j,
        i;
    for (j = 0, i = iArg || 0, len = arr.length; i < len; j++, i++) {
      a[j] = arr[i];
    }
    return a;
  }
  function fastCatSkipNulls(arr1, arr2) {
    var a = [],
        i,
        len,
        j;
    for (i = 0, len = arr1.length; i < len; i++) {
      a[i] = arr1[i];
    }
    for (j = 0, len = arr2.length; j < len; j++) {
      if (arr2[j] !== null) {
        a[i++] = arr2[j];
      }
    }
    return a;
  }
  function fastCat(arr1, arr2) {
    var a = [],
        i,
        len,
        j;
    for (i = 0, len = arr1.length; i < len; i++) {
      a[i] = arr1[i];
    }
    for (j = 0, len = arr2.length; j < len; j++) {
      a[i++] = arr2[j];
    }
    return a;
  }
  module.exports = {
    fastCat: fastCat,
    fastCatSkipNulls: fastCatSkipNulls,
    fastCopy: fastCopy
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/onMissing", ["npm:falcor@0.1.13/lib/get/util/support"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var support = require("npm:falcor@0.1.13/lib/get/util/support");
  var fastCopy = support.fastCopy;
  module.exports = function onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength) {
    var pathSlice;
    if (!outerResults.requestedMissingPaths) {
      outerResults.requestedMissingPaths = [];
      outerResults.optimizedMissingPaths = [];
    }
    if (depth < path.length) {
      pathSlice = fastCopy(path, depth);
    } else {
      pathSlice = [];
    }
    concatAndInsertMissing(model, pathSlice, depth, requestedPath, optimizedPath, optimizedLength, outerResults);
  };
  function concatAndInsertMissing(model, remainingPath, depth, requestedPath, optimizedPath, optimizedLength, results) {
    results.requestedMissingPaths.push(requestedPath.slice(0, depth).concat(remainingPath));
    results.optimizedMissingPaths.push(optimizedPath.slice(0, optimizedLength).concat(remainingPath));
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/util/isMaterialzed", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isMaterialized(model) {
    return model._materialized && !model._source;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/onValueType", ["npm:falcor@0.1.13/lib/get/util/isExpired", "npm:falcor@0.1.13/lib/get/util/hardlink", "npm:falcor@0.1.13/lib/get/util/lru", "npm:falcor@0.1.13/lib/types/error", "npm:falcor@0.1.13/lib/get/onError", "npm:falcor@0.1.13/lib/get/onValue", "npm:falcor@0.1.13/lib/get/onMissing", "npm:falcor@0.1.13/lib/get/util/isMaterialzed", "npm:falcor@0.1.13/lib/internal/invalidated"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isExpired = require("npm:falcor@0.1.13/lib/get/util/isExpired");
  var hardLink = require("npm:falcor@0.1.13/lib/get/util/hardlink");
  var lru = require("npm:falcor@0.1.13/lib/get/util/lru");
  var removeHardlink = hardLink.remove;
  var splice = lru.splice;
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var onError = require("npm:falcor@0.1.13/lib/get/onError");
  var onValue = require("npm:falcor@0.1.13/lib/get/onValue");
  var onMissing = require("npm:falcor@0.1.13/lib/get/onMissing");
  var isMaterialized = require("npm:falcor@0.1.13/lib/get/util/isMaterialzed");
  var __invalidated = require("npm:falcor@0.1.13/lib/internal/invalidated");
  module.exports = function onValueType(model, node, path, depth, seed, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {
    var currType = node && node.$type;
    var requiresMaterializedToReport = node && node.value === undefined;
    if (!node || !currType) {
      if (isMaterialized(model)) {
        onValue(model, node, seed, depth, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference);
      } else {
        onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength);
      }
      return;
    } else if (isExpired(node)) {
      if (!node[__invalidated]) {
        splice(model, node);
        removeHardlink(node);
      }
      onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength);
    } else if (currType === $error) {
      if (fromReference) {
        requestedPath[depth] = null;
      }
      if (isJSONG || model._treatErrorsAsValues) {
        onValue(model, node, seed, depth, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference);
      } else {
        onError(model, node, depth, requestedPath, outerResults);
      }
    } else {
      if (fromReference) {
        requestedPath[depth] = null;
      }
      if (!requiresMaterializedToReport || requiresMaterializedToReport && isMaterialized(model)) {
        onValue(model, node, seed, depth, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference);
      }
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/walkPath", ["npm:falcor@0.1.13/lib/get/followReference", "npm:falcor@0.1.13/lib/get/onValueType", "npm:falcor@0.1.13/lib/get/util/isExpired", "npm:falcor-path-utils@0.3.4", "npm:falcor@0.1.13/lib/types/ref"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var followReference = require("npm:falcor@0.1.13/lib/get/followReference");
  var onValueType = require("npm:falcor@0.1.13/lib/get/onValueType");
  var isExpired = require("npm:falcor@0.1.13/lib/get/util/isExpired");
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4").iterateKeySet;
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  module.exports = function walkPath(model, root, curr, path, depth, seed, outerResults, requestedPath, optimizedPathArg, optimizedLength, isJSONG, fromReferenceArg) {
    var fromReference = fromReferenceArg;
    var optimizedPath = optimizedPathArg;
    if ((!curr || curr && curr.$type) || depth === path.length) {
      onValueType(model, curr, path, depth, seed, outerResults, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference);
      return;
    }
    var keySet,
        i;
    keySet = path[depth];
    var isKeySet = typeof keySet === "object";
    var nextDepth = depth + 1;
    var iteratorNote = false;
    var key = keySet;
    if (isKeySet) {
      iteratorNote = {};
      key = iterateKeySet(keySet, iteratorNote);
    }
    if (key === undefined && iteratorNote.done) {
      return;
    }
    var optimizedLengthPlus1 = optimizedLength + 1;
    do {
      fromReference = false;
      var next;
      if (key === null) {
        next = curr;
      } else {
        next = curr[key];
        optimizedPath[optimizedLength] = key;
        requestedPath[depth] = key;
      }
      var nextOptimizedPath = optimizedPath;
      var nextOptimizedLength = optimizedLengthPlus1;
      if (next) {
        var nType = next.$type;
        var value = nType && next.value || next;
        if (nextDepth < path.length && nType && nType === $ref && !isExpired(next)) {
          if (isJSONG) {
            onValueType(model, next, path, nextDepth, seed, outerResults, null, optimizedPath, nextOptimizedLength, isJSONG, fromReference);
          }
          var ref = followReference(model, root, root, next, value, seed, isJSONG);
          fromReference = true;
          next = ref[0];
          var refPath = ref[1];
          nextOptimizedPath = [];
          nextOptimizedLength = refPath.length;
          for (i = 0; i < nextOptimizedLength; ++i) {
            nextOptimizedPath[i] = refPath[i];
          }
        }
      }
      walkPath(model, root, next, path, nextDepth, seed, outerResults, requestedPath, nextOptimizedPath, nextOptimizedLength, isJSONG, fromReference);
      if (iteratorNote && !iteratorNote.done) {
        key = iterateKeySet(keySet, iteratorNote);
      }
    } while (iteratorNote && !iteratorNote.done);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/index", ["npm:falcor@0.1.13/lib/get/get", "npm:falcor@0.1.13/lib/get/walkPath", "npm:falcor@0.1.13/lib/get/getValueSync", "npm:falcor@0.1.13/lib/get/getBoundValue"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var get = require("npm:falcor@0.1.13/lib/get/get");
  var walkPath = require("npm:falcor@0.1.13/lib/get/walkPath");
  var getWithPathsAsPathMap = get(walkPath, false);
  var getWithPathsAsJSONGraph = get(walkPath, true);
  module.exports = {
    getValueSync: require("npm:falcor@0.1.13/lib/get/getValueSync"),
    getBoundValue: require("npm:falcor@0.1.13/lib/get/getBoundValue"),
    getWithPathsAsPathMap: getWithPathsAsPathMap,
    getWithPathsAsJSONGraph: getWithPathsAsJSONGraph
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/checkCacheAndReport", ["npm:falcor@0.1.13/lib/get/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var gets = require("npm:falcor@0.1.13/lib/get/index");
  var getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;
  var getWithPathsAsPathMap = gets.getWithPathsAsPathMap;
  module.exports = function checkCacheAndReport(model, requestedPaths, observer, progressive, isJSONG, seed, errors) {
    var results;
    if (isJSONG) {
      results = getWithPathsAsJSONGraph(model, requestedPaths, seed);
    } else {
      results = getWithPathsAsPathMap(model, requestedPaths, seed);
    }
    if (results.criticalError) {
      observer.onError(results.criticalError);
      return null;
    }
    var hasValues = results.hasValue;
    var completed = !results.requestedMissingPaths || !model._source;
    if (results.errors) {
      var errs = results.errors;
      var errorsLength = errors.length;
      for (var i = 0,
          len = errs.length; i < len; ++i, ++errorsLength) {
        errors[errorsLength] = errs[i];
      }
    }
    if (hasValues && (progressive || completed)) {
      try {
        ++model._root.syncRefCount;
        observer.onNext(seed[0]);
      } catch (e) {
        throw e;
      } finally {
        --model._root.syncRefCount;
      }
    }
    if (completed) {
      if (errors.length) {
        observer.onError(errors);
      } else {
        observer.onCompleted();
      }
      return null;
    }
    return results;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/errors/MaxRetryExceededError", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var NAME = "MaxRetryExceededError";
  function MaxRetryExceededError() {
    this.message = "The allowed number of retries have been exceeded.";
    this.stack = (new Error()).stack;
  }
  MaxRetryExceededError.prototype = new Error();
  MaxRetryExceededError.prototype.name = NAME;
  MaxRetryExceededError.name = NAME;
  MaxRetryExceededError.is = function(e) {
    return e && e.name === NAME;
  };
  module.exports = MaxRetryExceededError;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/lru/collect", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/head", "npm:falcor@0.1.13/lib/internal/tail", "npm:falcor@0.1.13/lib/internal/next", "npm:falcor@0.1.13/lib/internal/prev", "npm:falcor@0.1.13/lib/support/removeNode", "npm:falcor@0.1.13/lib/support/updateNodeAncestors"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __head = require("npm:falcor@0.1.13/lib/internal/head");
  var __tail = require("npm:falcor@0.1.13/lib/internal/tail");
  var __next = require("npm:falcor@0.1.13/lib/internal/next");
  var __prev = require("npm:falcor@0.1.13/lib/internal/prev");
  var removeNode = require("npm:falcor@0.1.13/lib/support/removeNode");
  var updateNodeAncestors = require("npm:falcor@0.1.13/lib/support/updateNodeAncestors");
  module.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {
    var total = totalArg;
    var ratio = ratioArg;
    if (typeof ratio !== "number") {
      ratio = 0.75;
    }
    var shouldUpdate = typeof version === "number";
    var targetSize = max * ratio;
    var parent,
        node,
        size;
    node = expired.pop();
    while (node) {
      size = node.$size || 0;
      total -= size;
      if (shouldUpdate === true) {
        updateNodeAncestors(node, size, lru, version);
      } else if (parent = node[__parent]) {
        removeNode(node, parent, node[__key], lru);
      }
      node = expired.pop();
    }
    if (total >= max) {
      var prev = lru[__tail];
      node = prev;
      while ((total >= targetSize) && node) {
        prev = prev[__prev];
        size = node.$size || 0;
        total -= size;
        if (shouldUpdate === true) {
          updateNodeAncestors(node, size, lru, version);
        }
        node = prev;
      }
      lru[__tail] = lru[__prev] = node;
      if (node == null) {
        lru[__head] = lru[__next] = void 0;
      } else {
        node[__next] = void 0;
      }
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/AssignableDisposable", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var AssignableDisposable = function AssignableDisposable(disosableCallback) {
    this.disposed = false;
    this.currentDisposable = disosableCallback;
  };
  AssignableDisposable.prototype = {dispose: function dispose() {
      if (this.disposed || !this.currentDisposable) {
        return;
      }
      this.disposed = true;
      var currentDisposable = this.currentDisposable;
      if (currentDisposable.dispose) {
        currentDisposable.dispose();
      } else {
        currentDisposable();
      }
    }};
  module.exports = AssignableDisposable;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/getRequestCycle", ["npm:falcor@0.1.13/lib/response/get/checkCacheAndReport", "npm:falcor@0.1.13/lib/errors/MaxRetryExceededError", "npm:falcor@0.1.13/lib/get/util/support", "npm:falcor@0.1.13/lib/lru/collect", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/response/get/AssignableDisposable"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var checkCacheAndReport = require("npm:falcor@0.1.13/lib/response/get/checkCacheAndReport");
  var MaxRetryExceededError = require("npm:falcor@0.1.13/lib/errors/MaxRetryExceededError");
  var fastCat = require("npm:falcor@0.1.13/lib/get/util/support").fastCat;
  var collectLru = require("npm:falcor@0.1.13/lib/lru/collect");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var AssignableDisposable = require("npm:falcor@0.1.13/lib/response/get/AssignableDisposable");
  module.exports = function getRequestCycle(getResponse, model, results, observer, seed, errors, count) {
    if (count === 10) {
      throw new MaxRetryExceededError();
    }
    var requestQueue = model._request;
    var requestedMissingPaths = results.requestedMissingPaths;
    var optimizedMissingPaths = results.optimizedMissingPaths;
    var disposable = new AssignableDisposable();
    var boundRequestedMissingPaths = [];
    var boundPath = model._path;
    if (boundPath.length) {
      for (var i = 0,
          len = requestedMissingPaths.length; i < len; ++i) {
        boundRequestedMissingPaths[i] = fastCat(boundPath, requestedMissingPaths[i]);
      }
    } else {
      boundRequestedMissingPaths = requestedMissingPaths;
    }
    var currentRequestDisposable = requestQueue.get(boundRequestedMissingPaths, optimizedMissingPaths, function() {
      var nextResults = checkCacheAndReport(model, requestedMissingPaths, observer, getResponse.isProgressive, getResponse.isJSONGraph, seed, errors);
      if (nextResults) {
        disposable.currentDisposable = getRequestCycle(getResponse, model, nextResults, observer, seed, errors, count + 1);
      } else {
        var modelRoot = model._root;
        var modelCache = modelRoot.cache;
        collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio);
      }
    });
    disposable.currentDisposable = currentRequestDisposable;
    return disposable;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/GetResponse", ["npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor@0.1.13/lib/response/get/checkCacheAndReport", "npm:falcor@0.1.13/lib/response/get/getRequestCycle", "npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var checkCacheAndReport = require("npm:falcor@0.1.13/lib/response/get/checkCacheAndReport");
  var getRequestCycle = require("npm:falcor@0.1.13/lib/response/get/getRequestCycle");
  var empty = {dispose: function() {}};
  var Observable = require("npm:rx@2.5.3/dist/rx").Observable;
  var GetResponse = module.exports = function GetResponse(model, paths, isJSONGraph, isProgressive) {
    this.model = model;
    this.currentRemainingPaths = paths;
    this.isJSONGraph = isJSONGraph || false;
    this.isProgressive = isProgressive || false;
  };
  GetResponse.prototype = Object.create(Observable.prototype);
  GetResponse.prototype.subscribe = ModelResponse.prototype.subscribe;
  GetResponse.prototype.then = ModelResponse.prototype.then;
  GetResponse.prototype._toJSONG = function _toJSONGraph() {
    return new GetResponse(this.model, this.currentRemainingPaths, true, this.isProgressive);
  };
  GetResponse.prototype.progressively = function progressively() {
    return new GetResponse(this.model, this.currentRemainingPaths, this.isJSONGraph, true);
  };
  GetResponse.prototype._subscribe = function _subscribe(observer) {
    var seed = [{}];
    var errors = [];
    var isJSONG = observer.isJSONG = this.isJSONGraph;
    var isProgressive = this.isProgressive;
    var results = checkCacheAndReport(this.model, this.currentRemainingPaths, observer, isProgressive, isJSONG, seed, errors);
    if (!results) {
      return empty;
    }
    return getRequestCycle(this, this.model, results, observer, seed, errors, 1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/array-clone", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function arrayClone(array) {
    if (!array) {
      return array;
    }
    var i = -1;
    var n = array.length;
    var array2 = [];
    while (++i < n) {
      array2[i] = array[i];
    }
    return array2;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isPathValue", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function isPathValue(pathValue) {
    return isObject(pathValue) && (isArray(pathValue.path) || (typeof pathValue.path === "string"));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isJSONEnvelope", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function isJSONEnvelope(envelope) {
    return isObject(envelope) && ("json" in envelope);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope", ["npm:falcor@0.1.13/lib/support/isObject"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  module.exports = function isJSONGraphEnvelope(envelope) {
    return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/IdempotentResponse", ["npm:rx@2.5.3/dist/rx", "npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/lru/collect", "npm:falcor@0.1.13/lib/support/array-clone", "npm:falcor@0.1.13/lib/support/isPathValue", "npm:falcor@0.1.13/lib/support/isJSONEnvelope", "npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Observable = Rx.Observable;
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var collectLru = require("npm:falcor@0.1.13/lib/lru/collect");
  var arrayClone = require("npm:falcor@0.1.13/lib/support/array-clone");
  var isArray = Array.isArray;
  var isPathValue = require("npm:falcor@0.1.13/lib/support/isPathValue");
  var isJSONEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONEnvelope");
  var isJSONGraphEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope");
  function IdempotentResponse(subscribe) {
    Observable.call(this, subscribe);
  }
  IdempotentResponse.create = ModelResponse.create;
  IdempotentResponse.prototype = Object.create(Observable.prototype);
  IdempotentResponse.prototype.constructor = IdempotentResponse;
  IdempotentResponse.prototype.subscribeCount = 0;
  IdempotentResponse.prototype.subscribeLimit = 10;
  IdempotentResponse.prototype.initialize = function initializeResponse() {
    var model = this.model;
    var outputFormat = this.outputFormat || "AsPathMap";
    var isProgressive = this.isProgressive;
    var values = [{}];
    var groups = [];
    var args = this.args;
    var group,
        groupType;
    var argIndex = -1;
    var argCount = args.length;
    while (++argIndex < argCount) {
      var arg = args[argIndex];
      var argType;
      if (isArray(arg) || typeof arg === "string") {
        arg = pathSyntax.fromPath(arg);
        argType = "PathValues";
      } else if (isPathValue(arg)) {
        arg.path = pathSyntax.fromPath(arg.path);
        argType = "PathValues";
      } else if (isJSONGraphEnvelope(arg)) {
        argType = "JSONGs";
      } else if (isJSONEnvelope(arg)) {
        argType = "PathMaps";
      }
      if (groupType !== argType) {
        groupType = argType;
        group = {
          inputType: argType,
          arguments: []
        };
        groups.push(group);
        group.values = values;
      }
      group.arguments.push(arg);
    }
    this.boundPath = arrayClone(model._path);
    this.groups = groups;
    this.outputFormat = outputFormat;
    this.isProgressive = isProgressive;
    this.isCompleted = false;
    this.isMaster = model._source == null;
    this.values = values;
    return this;
  };
  IdempotentResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {
    return this;
  };
  IdempotentResponse.prototype.ensureCollect = function ensureCollect(model) {
    var ensured = this.finally(function ensureCollect() {
      var modelRoot = model._root;
      var modelCache = modelRoot.cache;
      modelRoot.collectionScheduler.schedule(function collectThisPass() {
        collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio);
      });
    });
    return new this.constructor(function(observer) {
      return ensured.subscribe(observer);
    });
  };
  module.exports = IdempotentResponse;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/array-flat-map", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function arrayFlatMap(array, selector) {
    var index = -1;
    var i = -1;
    var n = array.length;
    var array2 = new Array(n);
    while (++i < n) {
      var array3 = selector(array[i], i, array);
      var j = -1;
      var k = array3.length;
      while (++j < k) {
        array2[++index] = array3[j];
      }
    }
    return array2;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/SetResponse", ["npm:rx@2.5.3/dist/rx", "npm:falcor@0.1.13/lib/response/get/GetResponse", "npm:falcor@0.1.13/lib/response/IdempotentResponse", "npm:falcor@0.1.13/lib/errors/InvalidSourceError", "npm:falcor@0.1.13/lib/support/array-flat-map"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Observable = Rx.Observable;
  var Disposable = Rx.Disposable;
  var GetResponse = require("npm:falcor@0.1.13/lib/response/get/GetResponse");
  var IdempotentResponse = require("npm:falcor@0.1.13/lib/response/IdempotentResponse");
  var InvalidSourceError = require("npm:falcor@0.1.13/lib/errors/InvalidSourceError");
  var arrayFlatMap = require("npm:falcor@0.1.13/lib/support/array-flat-map");
  var emptyArray = new Array(0);
  function SetResponse(subscribe) {
    IdempotentResponse.call(this, subscribe || subscribeToSetResponse);
  }
  SetResponse.create = IdempotentResponse.create;
  SetResponse.prototype = Object.create(IdempotentResponse.prototype);
  SetResponse.prototype.method = "set";
  SetResponse.prototype.constructor = SetResponse;
  SetResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {
    var source = this;
    var caught = this.catch(function setJSONGraph(results) {
      var requestObs;
      if (results && results.invokeSourceRequest === true) {
        var envelope = {};
        var boundPath = model._path;
        var optimizedPaths = results.optimizedPaths;
        model._path = emptyArray;
        model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);
        model._path = boundPath;
        requestObs = model._request.set(envelope).do(function setResponseEnvelope(envelope2) {
          source.isCompleted = optimizedPaths.length === envelope2.paths.length;
        }, function setResponseError() {
          source.isCompleted = true;
        }).materialize().flatMap(function(notification) {
          if (notification.kind === "C") {
            return Observable.empty();
          }
          if (notification.kind === "E") {
            var ex = notification.exception;
            if (InvalidSourceError.is(ex)) {
              return Observable.throw(notification.exception);
            }
          }
          return caught;
        });
      } else {
        requestObs = Observable.throw(results);
      }
      return requestObs;
    });
    return new this.constructor(function(observer) {
      return caught.subscribe(observer);
    });
  };
  function subscribeToSetResponse(observer) {
    if (this.isCompleted) {
      return subscribeToFollowupGet.call(this, observer);
    }
    return subscribeToLocalSet.call(this, observer);
  }
  function subscribeToLocalSet(observer) {
    if (this.subscribeCount++ > this.subscribeLimit) {
      observer.onError("Loop kill switch thrown.");
      return Disposable.empty;
    }
    var requestedPaths = [];
    var optimizedPaths = [];
    var model = this.model;
    var isMaster = this.isMaster;
    var modelRoot = model._root;
    var outputFormat = this.outputFormat;
    var errorSelector = modelRoot.errorSelector;
    var method = this.method;
    var groups = this.groups;
    var groupIndex = -1;
    var groupCount = groups.length;
    while (++groupIndex < groupCount) {
      var group = groups[groupIndex];
      var inputType = group.inputType;
      var methodArgs = group.arguments;
      if (methodArgs.length > 0) {
        var operationName = "_" + method + inputType + outputFormat;
        var operationFunc = model[operationName];
        var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);
        optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);
        if (inputType === "PathValues") {
          requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));
        } else if (inputType === "JSONGs") {
          requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));
        } else {
          requestedPaths.push.apply(requestedPaths, successfulPaths[0]);
        }
      }
    }
    this.requestedPaths = requestedPaths;
    if (isMaster) {
      this.isCompleted = true;
      return subscribeToFollowupGet.call(this, observer);
    } else {
      observer.onError({
        method: method,
        optimizedPaths: optimizedPaths,
        invokeSourceRequest: true
      });
    }
  }
  function subscribeToFollowupGet(observer) {
    var response = new GetResponse(this.model, this.requestedPaths);
    if (this.outputFormat === "AsJSONG") {
      response = response._toJSONG();
    }
    if (this.isProgressive) {
      response = response.progressively();
    }
    return response.subscribe(observer);
  }
  function pluckPath(pathValue) {
    return pathValue.path;
  }
  function pluckEnvelopePaths(jsonGraphEnvelope) {
    return jsonGraphEnvelope.paths;
  }
  module.exports = SetResponse;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/CallResponse", ["npm:rx@2.5.3/dist/rx", "npm:rx@2.5.3/dist/rx.aggregates", "npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor@0.1.13/lib/errors/InvalidSourceError", "npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/types/ref"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx") && require("npm:rx@2.5.3/dist/rx.aggregates");
  var Observable = Rx.Observable;
  var CompositeDisposable = Rx.CompositeDisposable;
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var InvalidSourceError = require("npm:falcor@0.1.13/lib/errors/InvalidSourceError");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  function CallResponse(subscribe) {
    Observable.call(this, subscribe || subscribeToResponse);
  }
  CallResponse.create = ModelResponse.create;
  CallResponse.prototype = Object.create(Observable.prototype);
  CallResponse.prototype.constructor = CallResponse;
  CallResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {
    return this;
  };
  CallResponse.prototype.ensureCollect = function ensureCollect(model) {
    return this;
  };
  CallResponse.prototype.initialize = function initializeResponse() {
    return this;
  };
  function toObservable(x) {
    return Rx.Observable.defer(function() {
      return x;
    });
  }
  function subscribeToResponse(observer) {
    var args = this.args;
    var model = this.model;
    var callPath = pathSyntax.fromPath(args[0]);
    var callArgs = args[1] || [];
    var suffixes = (args[2] || []).map(pathSyntax.fromPath);
    var extraPaths = (args[3] || []).map(pathSyntax.fromPath);
    var rootModel = model._clone({_path: []});
    var localRoot = rootModel.withoutDataSource();
    var boundPath = model._path;
    var boundCallPath = boundPath.concat(callPath);
    var boundThisPath = boundCallPath.slice(0, -1);
    var setCallValuesObs = toObservable(model.withoutDataSource().get(callPath)).map(function(data) {
      var curr = data.json;
      var depth = -1;
      var length = callPath.length;
      while (curr && ++depth < length) {
        curr = curr[callPath[depth]];
      }
      var boundModel = rootModel._derefSync(boundThisPath).boxValues();
      return {
        model: boundModel,
        localFn: curr
      };
    }).flatMap(getLocalCallObs).defaultIfEmpty(getRemoteCallObs(model._source)).mergeAll().flatMap(setCallEnvelope);
    var disposables = new CompositeDisposable();
    disposables.add(setCallValuesObs.subscribe(function(envelope) {
      var paths = envelope.paths;
      var invalidated = envelope.invalidated;
      var innerObs = model.get.apply(model, paths);
      if (observer.outputFormat === "AsJSONG") {
        innerObs = toObservable(innerObs._toJSONG()).doAction(function(envelope2) {
          envelope2.invalidated = invalidated;
        });
      }
      disposables.add(innerObs.subscribe(observer));
    }, function(e) {
      observer.onError(e);
    }));
    return disposables;
    function getLocalCallObs(tuple) {
      var localFn = tuple && tuple.localFn;
      if (typeof localFn === "function") {
        var localFnModel = tuple.model;
        var localThisPath = localFnModel._path;
        var remoteGetValues = localFn.apply(localFnModel, callArgs).reduce(aggregateFnResults, {
          values: [],
          references: [],
          invalidations: [],
          localThisPath: localThisPath
        }).flatMap(setLocalValues).flatMap(getRemoteValues);
        return Observable.return(remoteGetValues);
      }
      return Observable.empty();
      function aggregateFnResults(results, pathValue) {
        if (Boolean(pathValue.invalidated)) {
          results.invalidations.push(results.localThisPath.concat(pathValue.path));
        } else {
          var path = pathValue.path;
          var value = pathValue.value;
          if (Boolean(value) && typeof value === "object" && value.$type === $ref) {
            results.references.push({
              path: prependThisPath(path),
              value: pathValue.value
            });
          } else {
            results.values.push({
              path: prependThisPath(path),
              value: pathValue.value
            });
          }
        }
        return results;
      }
      function setLocalValues(results) {
        var values = results.values.concat(results.references);
        if (values.length > 0) {
          return toObservable(localRoot.set.apply(localRoot, values)._toJSONG()).map(function(envelope) {
            return {
              results: results,
              envelope: envelope
            };
          });
        } else {
          return Observable.return({
            results: results,
            envelope: {
              jsonGraph: {},
              paths: []
            }
          });
        }
      }
      function getRemoteValues(tuple2) {
        var envelope = tuple2.envelope;
        var results = tuple2.results;
        var values = results.values;
        var references = results.references;
        var invalidations = results.invalidations;
        var rootValues = values.map(pluckPath).map(prependThisPath);
        var rootSuffixes = references.reduce(prependRefToSuffixes, []);
        var rootExtraPaths = extraPaths.map(prependThisPath);
        var rootPaths = rootSuffixes.concat(rootExtraPaths);
        var envelopeObs;
        if (rootPaths.length > 0) {
          envelopeObs = toObservable(rootModel.get.apply(rootModel, rootValues.concat(rootPaths))._toJSONG());
        } else {
          envelopeObs = Observable.return(envelope);
        }
        return envelopeObs.doAction(function(envelope2) {
          envelope2.invalidated = invalidations;
        });
      }
      function prependRefToSuffixes(refPaths, refPathValue) {
        var refPath = refPathValue.path;
        refPaths.push.apply(refPaths, suffixes.map(function(pathSuffix) {
          return refPath.concat(pathSuffix);
        }));
        return refPaths;
      }
      function pluckPath(pathValue) {
        return pathValue.path;
      }
    }
    function getRemoteCallObs(dataSource) {
      if (dataSource && typeof dataSource === "object") {
        return Rx.Observable.defer(function() {
          var obs;
          try {
            obs = dataSource.call(boundCallPath, callArgs, suffixes, extraPaths);
          } catch (e) {
            obs = Observable.throw(new InvalidSourceError(e));
          }
          return obs;
        }).map(invalidateLocalValues);
      }
      return Observable.empty();
      function invalidateLocalValues(envelope) {
        var invalidations = envelope.invalidated;
        if (invalidations && invalidations.length) {
          rootModel.invalidate.apply(rootModel, invalidations);
        }
        return envelope;
      }
    }
    function setCallEnvelope(envelope) {
      return toObservable(localRoot.set(envelope)).reduce(function(acc) {
        return acc;
      }, null).map(function() {
        return {
          invalidated: envelope.invalidated,
          paths: envelope.paths.map(function(path) {
            return path.slice(boundPath.length);
          })
        };
      });
    }
    function prependThisPath(path) {
      return boundThisPath.concat(path);
    }
  }
  module.exports = CallResponse;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/InvalidateResponse", ["npm:rx@2.5.3/dist/rx", "npm:falcor@0.1.13/lib/response/IdempotentResponse"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Disposable = Rx.Disposable;
  var IdempotentResponse = require("npm:falcor@0.1.13/lib/response/IdempotentResponse");
  function InvalidateResponse(subscribe) {
    IdempotentResponse.call(this, subscribe || subscribeToInvalidateResponse);
  }
  InvalidateResponse.create = IdempotentResponse.create;
  InvalidateResponse.prototype = Object.create(IdempotentResponse.prototype);
  InvalidateResponse.prototype.method = "invalidate";
  InvalidateResponse.prototype.constructor = InvalidateResponse;
  function subscribeToInvalidateResponse(observer) {
    var model = this.model;
    var method = this.method;
    var groups = this.groups;
    var groupIndex = -1;
    var groupCount = groups.length;
    while (++groupIndex < groupCount) {
      var group = groups[groupIndex];
      var inputType = group.inputType;
      var methodArgs = group.arguments;
      if (methodArgs.length > 0) {
        var operationName = "_" + method + inputType + "AsJSON";
        var operationFunc = model[operationName];
        operationFunc(model, methodArgs);
      }
    }
    observer.onCompleted();
    return Disposable.empty;
  }
  module.exports = InvalidateResponse;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/schedulers/ASAPScheduler", ["npm:asap@2.0.3", "npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var asap = require("npm:asap@2.0.3");
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Disposable = Rx.Disposable;
  function ASAPScheduler() {}
  ASAPScheduler.prototype.schedule = function schedule(action) {
    asap(action);
    return Disposable.empty;
  };
  ASAPScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
    var self = this;
    asap(function() {
      action(self, state);
    });
    return Disposable.empty;
  };
  module.exports = ASAPScheduler;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/schedulers/TimeoutScheduler", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var Disposable = Rx.Disposable;
  function TimeoutScheduler(delay) {
    this.delay = delay;
  }
  TimeoutScheduler.prototype.schedule = function schedule(action) {
    var id = setTimeout(action, this.delay);
    return Disposable.create(function() {
      if (id !== void 0) {
        clearTimeout(id);
        id = void 0;
      }
    });
  };
  TimeoutScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
    var self = this;
    var id = setTimeout(function() {
      action(self, state);
    }, this.delay);
    return Disposable.create(function() {
      if (id !== void 0) {
        clearTimeout(id);
        id = void 0;
      }
    });
  };
  module.exports = TimeoutScheduler;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/set/setPathMaps", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/prefix", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/hasOwn", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor@0.1.13/lib/support/incrementVersion", "npm:falcor@0.1.13/lib/support/mergeValueOrInsertBranch"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  var isArray = Array.isArray;
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var hasOwn = require("npm:falcor@0.1.13/lib/support/hasOwn");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var incrementVersion = require("npm:falcor@0.1.13/lib/support/incrementVersion");
  var mergeValueOrInsertBranch = require("npm:falcor@0.1.13/lib/support/mergeValueOrInsertBranch");
  module.exports = function setPathMaps(model, pathMapEnvelopes, x, errorSelector, comparator) {
    var modelRoot = model._root;
    var lru = modelRoot;
    var expired = modelRoot.expired;
    var version = incrementVersion();
    var bound = model._path;
    var cache = modelRoot.cache;
    var node = bound.length ? getBoundValue(model, bound).value : cache;
    var parent = node[__parent] || cache;
    var initialVersion = cache[__version];
    var requestedPath = [];
    var requestedPaths = [];
    var optimizedPaths = [];
    var optimizedIndex = bound.length;
    var pathMapIndex = -1;
    var pathMapCount = pathMapEnvelopes.length;
    while (++pathMapIndex < pathMapCount) {
      var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];
      var optimizedPath = bound.slice(0);
      optimizedPath.index = optimizedIndex;
      setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
    }
    var newVersion = cache[__version];
    var rootChangeHandler = modelRoot.onChange;
    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
      rootChangeHandler();
    }
    return [requestedPaths, optimizedPaths];
  };
  function setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var keys = getKeys(pathMap);
    if (keys && keys.length) {
      var keyIndex = 0;
      var keyCount = keys.length;
      var optimizedIndex = optimizedPath.index;
      do {
        var key = keys[keyIndex];
        var child = pathMap[key];
        var branch = isObject(child) && !child.$type;
        var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
        requestedPath[depth] = key;
        requestedPath.index = depth;
        optimizedPath[optimizedPath.index++] = key;
        var nextNode = results[0];
        var nextParent = results[1];
        if (nextNode) {
          if (branch) {
            setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
          } else {
            promote(lru, nextNode);
            requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));
            optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));
          }
        }
        if (++keyIndex >= keyCount) {
          break;
        }
        optimizedPath.index = optimizedIndex;
      } while (true);
    }
  }
  function setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var reference = node.value;
    optimizedPath.splice(0, optimizedPath.length);
    optimizedPath.push.apply(optimizedPath, reference);
    if (isExpired(node)) {
      optimizedPath.index = reference.length;
      expireNode(node, expired, lru);
      return [undefined, root];
    }
    promote(lru, node);
    var container = node;
    var parent = root;
    node = node[__context];
    if (node != null) {
      parent = node[__parent] || root;
      optimizedPath.index = reference.length;
    } else {
      var index = 0;
      var count = reference.length - 1;
      parent = node = root;
      do {
        var key = reference[index];
        var branch = index < count;
        var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
        node = results[0];
        if (isPrimitive(node)) {
          optimizedPath.index = index;
          return results;
        }
        parent = results[1];
      } while (index++ < count);
      optimizedPath.index = index;
      if (container[__context] !== node) {
        var backRefs = node[__refsLength] || 0;
        node[__refsLength] = backRefs + 1;
        node[__ref + backRefs] = container;
        container[__context] = node;
        container[__refIndex] = backRefs;
      }
    }
    return [node, parent];
  }
  function setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {
    var type = node.$type;
    while (type === $ref) {
      var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
      node = results[0];
      if (isPrimitive(node)) {
        return results;
      }
      parent = results[1];
      type = node && node.$type;
    }
    if (type !== void 0) {
      return [node, parent];
    }
    if (key == null) {
      if (branch) {
        throw new Error("`null` is not allowed in branch key positions.");
      } else if (node) {
        key = node[__key];
      }
    } else {
      parent = node;
      node = parent[key];
    }
    node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);
    return [node, parent];
  }
  function getKeys(pathMap) {
    if (isObject(pathMap) && !pathMap.$type) {
      var keys = [];
      var itr = 0;
      if (isArray(pathMap)) {
        keys[itr++] = "length";
      }
      for (var key in pathMap) {
        if (key[0] === __prefix || key[0] === "$" || !hasOwn(pathMap, key)) {
          continue;
        }
        keys[itr++] = key;
      }
      return keys;
    }
    return void 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/support/validateInput", ["npm:falcor@0.1.13/lib/support/isPathValue", "npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope", "npm:falcor@0.1.13/lib/support/isJSONEnvelope", "npm:falcor-path-syntax@0.2.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var isPathValue = require("npm:falcor@0.1.13/lib/support/isPathValue");
  var isJSONGraphEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope");
  var isJSONEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONEnvelope");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  module.exports = function validateInput(args, allowedInput, method) {
    for (var i = 0,
        len = args.length; i < len; ++i) {
      var arg = args[i];
      var valid = false;
      if (isArray(arg) && allowedInput.path) {
        valid = true;
      } else if (typeof arg === "string" && allowedInput.pathSyntax) {
        valid = true;
      } else if (isPathValue(arg) && allowedInput.pathValue) {
        arg.path = pathSyntax.fromPath(arg.path);
        valid = true;
      } else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {
        valid = true;
      } else if (isJSONEnvelope(arg) && allowedInput.json) {
        valid = true;
      } else if (typeof arg === "function" && i + 1 === len && allowedInput.selector) {
        valid = true;
      }
      if (!valid) {
        return new Error("Unrecognized argument " + (typeof arg) + " [" + String(arg) + "] " + "to Model#" + method + "");
      }
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getCache", ["npm:falcor@0.1.13/lib/internal/model-created", "npm:falcor@0.1.13/lib/get/util/clone", "npm:falcor@0.1.13/lib/internal/prefix"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $modelCreated = require("npm:falcor@0.1.13/lib/internal/model-created");
  var clone = require("npm:falcor@0.1.13/lib/get/util/clone");
  var prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  module.exports = function getCache(cache) {
    var out = {};
    _copyCache(cache, out);
    return out;
  };
  function _copyCache(node, out, fromKey) {
    Object.keys(node).filter(function(k) {
      return k[0] !== prefix && k !== "$size";
    }).forEach(function(key) {
      var cacheNext = node[key];
      var outNext = out[key];
      if (!outNext) {
        outNext = out[key] = {};
      }
      if (cacheNext.$type) {
        var isObject = cacheNext.value && typeof cacheNext.value === "object";
        var isUserCreatedcacheNext = !node[$modelCreated];
        var value;
        if (isObject || isUserCreatedcacheNext) {
          value = clone(cacheNext);
        } else {
          value = cacheNext.value;
        }
        out[key] = value;
        return;
      }
      _copyCache(cacheNext, outNext, key);
    });
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/validInput", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    path: true,
    pathSyntax: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/index", ["npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor@0.1.13/lib/response/get/validInput", "npm:falcor@0.1.13/lib/support/validateInput", "npm:falcor@0.1.13/lib/response/get/GetResponse"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var GET_VALID_INPUT = require("npm:falcor@0.1.13/lib/response/get/validInput");
  var validateInput = require("npm:falcor@0.1.13/lib/support/validateInput");
  var GetResponse = require("npm:falcor@0.1.13/lib/response/get/GetResponse");
  module.exports = function get() {
    var out = validateInput(arguments, GET_VALID_INPUT, "get");
    if (out !== true) {
      return new ModelResponse(function(o) {
        o.onError(out);
      });
    }
    var paths = pathSyntax.fromPathsOrPathValues(arguments);
    return new GetResponse(this, paths);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/response/get/getWithPaths", ["npm:falcor@0.1.13/lib/response/get/GetResponse"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var GetResponse = require("npm:falcor@0.1.13/lib/response/get/GetResponse");
  module.exports = function getWithPaths(paths) {
    return new GetResponse(this, paths);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/deref/index", ["npm:rx@2.5.3/dist/rx", "npm:falcor-path-syntax@0.2.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  module.exports = function deref(boundPathArg) {
    var model = this;
    var modelRoot = model._root;
    var pathsIndex = -1;
    var pathsCount = arguments.length - 1;
    var paths = new Array(pathsCount);
    var boundPath = pathSyntax.fromPath(boundPathArg);
    while (++pathsIndex < pathsCount) {
      paths[pathsIndex] = pathSyntax.fromPath(arguments[pathsIndex + 1]);
    }
    if (modelRoot.syncRefCount <= 0 && pathsCount === 0) {
      throw new Error("Model#deref requires at least one value path.");
    }
    return Rx.Observable.defer(function() {
      var value;
      var errorHappened = false;
      try {
        ++modelRoot.syncRefCount;
        value = model._derefSync(boundPath);
      } catch (e) {
        value = e;
        errorHappened = true;
      } finally {
        --modelRoot.syncRefCount;
        return errorHappened ? Rx.Observable.throw(value) : Rx.Observable.return(value);
      }
    }).flatMap(function(boundModel) {
      if (Boolean(boundModel)) {
        if (pathsCount > 0) {
          return boundModel.get.apply(boundModel, paths).map(function() {
            return boundModel;
          }).catch(Rx.Observable.empty());
        }
        return Rx.Observable.return(boundModel);
      } else if (pathsCount > 0) {
        return model.get.apply(model, paths.map(function(path) {
          return boundPath.concat(path);
        })).map(function() {
          return model.deref(boundPath);
        }).mergeAll();
      }
      return Rx.Observable.empty();
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getValue", ["npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor-path-syntax@0.2.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  module.exports = function getValue(path) {
    var parsedPath = pathSyntax.fromPath(path);
    var pathIdx = 0;
    var pathLen = parsedPath.length;
    while (++pathIdx < pathLen) {
      if (typeof parsedPath[pathIdx] === "object") {
        return new ModelResponse(function(o) {
          o.onError(new Error("Paths must be simple paths"));
        });
      }
    }
    var self = this;
    return new ModelResponse(function(obs) {
      return self.get(parsedPath).subscribe(function(data) {
        var curr = data.json;
        var depth = -1;
        var length = parsedPath.length;
        while (curr && ++depth < length) {
          curr = curr[parsedPath[depth]];
        }
        obs.onNext(curr);
      }, function(err) {
        obs.onError(err);
      }, function() {
        obs.onCompleted();
      });
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/set/setValue", ["npm:falcor-json-graph@1.1.5", "npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor@0.1.13/lib/support/isPathValue"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var jsong = require("npm:falcor-json-graph@1.1.5");
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var isPathValue = require("npm:falcor@0.1.13/lib/support/isPathValue");
  module.exports = function setValue(pathArg, valueArg) {
    var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);
    var pathIdx = 0;
    var path = value.path;
    var pathLen = path.length;
    while (++pathIdx < pathLen) {
      if (typeof path[pathIdx] === "object") {
        return new ModelResponse(function(o) {
          o.onError(new Error("Paths must be simple paths"));
        });
      }
    }
    var self = this;
    return new ModelResponse(function(obs) {
      return self._set(value).subscribe(function(data) {
        var curr = data.json;
        var depth = -1;
        var length = path.length;
        while (curr && ++depth < length) {
          curr = curr[path[depth]];
        }
        obs.onNext(curr);
      }, function(err) {
        obs.onError(err);
      }, function() {
        obs.onCompleted();
      });
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/sync", ["npm:falcor-path-syntax@0.2.1"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  module.exports = function getValueSync(pathArg) {
    var path = pathSyntax.fromPath(pathArg);
    if (Array.isArray(path) === false) {
      throw new Error("Model#getValueSync must be called with an Array path.");
    }
    if (this._path.length) {
      path = this._path.concat(path);
    }
    return this._syncCheck("getValueSync") && this._getValueSync(this, path).value;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/set/sync", ["npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/support/isPathValue", "npm:falcor@0.1.13/lib/set/setPathValues"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var isPathValue = require("npm:falcor@0.1.13/lib/support/isPathValue");
  var setPathValues = require("npm:falcor@0.1.13/lib/set/setPathValues");
  module.exports = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {
    var path = pathSyntax.fromPath(pathArg);
    var value = valueArg;
    var errorSelector = errorSelectorArg;
    var comparator = comparatorArg;
    if (isPathValue(path)) {
      comparator = errorSelector;
      errorSelector = value;
      value = path;
    } else {
      value = {
        path: path,
        value: value
      };
    }
    if (isPathValue(value) === false) {
      throw new Error("Model#setValueSync must be called with an Array path.");
    }
    if (typeof errorSelector !== "function") {
      errorSelector = this._root._errorSelector;
    }
    if (typeof comparator !== "function") {
      comparator = this._root._comparator;
    }
    if (this._syncCheck("setValueSync")) {
      setPathValues(this, [value]);
      return this._getValueSync(this, value.path).value;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/deref/sync", ["npm:falcor@0.1.13/lib/types/error", "npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/support/getType"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $error = require("npm:falcor@0.1.13/lib/types/error");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  var getType = require("npm:falcor@0.1.13/lib/support/getType");
  module.exports = function derefSync(boundPathArg) {
    var boundPath = pathSyntax.fromPath(boundPathArg);
    if (!Array.isArray(boundPath)) {
      throw new Error("Model#derefSync must be called with an Array path.");
    }
    var boundValue = getBoundValue(this, this._path.concat(boundPath));
    var path = boundValue.path;
    var node = boundValue.value;
    var found = boundValue.found;
    if (!found) {
      return void 0;
    }
    var type = getType(node);
    if (Boolean(node) && Boolean(type)) {
      if (type === $error) {
        if (this._boxed) {
          throw node;
        }
        throw node.value;
      } else if (node.value === void 0) {
        return void 0;
      }
    }
    return this._clone({_path: path});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/get/getVersion", ["npm:falcor@0.1.13/lib/internal/version"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  module.exports = function _getVersion(model, path) {
    var gen = model._getValueSync({
      _boxed: true,
      _root: model._root,
      _treatErrorsAsValues: model._treatErrorsAsValues
    }, path, true).value;
    var version = gen && gen[__version];
    return (version == null) ? -1 : version;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/invalidate/invalidatePathSets", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor-path-utils@0.3.4", "npm:falcor@0.1.13/lib/support/incrementVersion", "npm:falcor@0.1.13/lib/support/updateNodeAncestors", "npm:falcor@0.1.13/lib/support/removeNodeAndDescendants"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var iterateKeySet = require("npm:falcor-path-utils@0.3.4").iterateKeySet;
  var incrementVersion = require("npm:falcor@0.1.13/lib/support/incrementVersion");
  var updateNodeAncestors = require("npm:falcor@0.1.13/lib/support/updateNodeAncestors");
  var removeNodeAndDescendants = require("npm:falcor@0.1.13/lib/support/removeNodeAndDescendants");
  module.exports = function invalidatePathSets(model, paths) {
    var modelRoot = model._root;
    var lru = modelRoot;
    var expired = modelRoot.expired;
    var version = incrementVersion();
    var bound = model._path;
    var cache = modelRoot.cache;
    var node = bound.length ? getBoundValue(model, bound).value : cache;
    var parent = node[__parent] || cache;
    var initialVersion = cache[__version];
    var pathIndex = -1;
    var pathCount = paths.length;
    while (++pathIndex < pathCount) {
      var path = paths[pathIndex];
      invalidatePathSet(path, 0, cache, parent, node, version, expired, lru);
    }
    var newVersion = cache[__version];
    var rootChangeHandler = modelRoot.onChange;
    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
      rootChangeHandler();
    }
  };
  function invalidatePathSet(path, depth, root, parent, node, version, expired, lru) {
    var note = {};
    var branch = depth < path.length - 1;
    var keySet = path[depth];
    var key = iterateKeySet(keySet, note);
    do {
      var results = invalidateNode(root, parent, node, key, branch, false, version, expired, lru);
      var nextNode = results[0];
      var nextParent = results[1];
      if (nextNode) {
        if (branch) {
          invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru);
        } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {
          updateNodeAncestors(nextParent, getSize(nextNode), lru, version);
        }
      }
      key = iterateKeySet(keySet, note);
    } while (!note.done);
  }
  function invalidateReference(root, node, version, expired, lru) {
    if (isExpired(node)) {
      expireNode(node, expired, lru);
      return [undefined, root];
    }
    promote(lru, node);
    var container = node;
    var reference = node.value;
    var parent = root;
    node = node[__context];
    if (node != null) {
      parent = node[__parent] || root;
    } else {
      var index = 0;
      var count = reference.length - 1;
      parent = node = root;
      do {
        var key = reference[index];
        var branch = index < count;
        var results = invalidateNode(root, parent, node, key, branch, true, version, expired, lru);
        node = results[0];
        if (isPrimitive(node)) {
          return results;
        }
        parent = results[1];
      } while (index++ < count);
      if (container[__context] !== node) {
        var backRefs = node[__refsLength] || 0;
        node[__refsLength] = backRefs + 1;
        node[__ref + backRefs] = container;
        container[__context] = node;
        container[__refIndex] = backRefs;
      }
    }
    return [node, parent];
  }
  function invalidateNode(root, parent, node, key, branch, reference, version, expired, lru) {
    var type = node.$type;
    while (type === $ref) {
      var results = invalidateReference(root, node, version, expired, lru);
      node = results[0];
      if (isPrimitive(node)) {
        return results;
      }
      parent = results[1];
      type = node.$type;
    }
    if (type !== void 0) {
      return [node, parent];
    }
    if (key == null) {
      if (branch) {
        throw new Error("`null` is not allowed in branch key positions.");
      } else if (node) {
        key = node[__key];
      }
    } else {
      parent = node;
      node = parent[key];
    }
    return [node, parent];
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/invalidate/invalidatePathMaps", ["npm:falcor@0.1.13/lib/internal/key", "npm:falcor@0.1.13/lib/internal/ref", "npm:falcor@0.1.13/lib/internal/prefix", "npm:falcor@0.1.13/lib/internal/parent", "npm:falcor@0.1.13/lib/internal/context", "npm:falcor@0.1.13/lib/internal/version", "npm:falcor@0.1.13/lib/internal/ref-index", "npm:falcor@0.1.13/lib/internal/refs-length", "npm:falcor@0.1.13/lib/types/ref", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/lru/promote", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/hasOwn", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/isExpired", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/expireNode", "npm:falcor@0.1.13/lib/support/incrementVersion", "npm:falcor@0.1.13/lib/support/updateNodeAncestors", "npm:falcor@0.1.13/lib/support/removeNodeAndDescendants"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __key = require("npm:falcor@0.1.13/lib/internal/key");
  var __ref = require("npm:falcor@0.1.13/lib/internal/ref");
  var __prefix = require("npm:falcor@0.1.13/lib/internal/prefix");
  var __parent = require("npm:falcor@0.1.13/lib/internal/parent");
  var __context = require("npm:falcor@0.1.13/lib/internal/context");
  var __version = require("npm:falcor@0.1.13/lib/internal/version");
  var __refIndex = require("npm:falcor@0.1.13/lib/internal/ref-index");
  var __refsLength = require("npm:falcor@0.1.13/lib/internal/refs-length");
  var $ref = require("npm:falcor@0.1.13/lib/types/ref");
  var getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  var promote = require("npm:falcor@0.1.13/lib/lru/promote");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var hasOwn = require("npm:falcor@0.1.13/lib/support/hasOwn");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var isExpired = require("npm:falcor@0.1.13/lib/support/isExpired");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var expireNode = require("npm:falcor@0.1.13/lib/support/expireNode");
  var incrementVersion = require("npm:falcor@0.1.13/lib/support/incrementVersion");
  var updateNodeAncestors = require("npm:falcor@0.1.13/lib/support/updateNodeAncestors");
  var removeNodeAndDescendants = require("npm:falcor@0.1.13/lib/support/removeNodeAndDescendants");
  module.exports = function invalidatePathMaps(model, pathMapEnvelopes) {
    var modelRoot = model._root;
    var lru = modelRoot;
    var expired = modelRoot.expired;
    var version = incrementVersion();
    var comparator = modelRoot._comparator;
    var errorSelector = modelRoot._errorSelector;
    var bound = model._path;
    var cache = modelRoot.cache;
    var node = bound.length ? getBoundValue(model, bound).value : cache;
    var parent = node[__parent] || cache;
    var initialVersion = cache[__version];
    var pathMapIndex = -1;
    var pathMapCount = pathMapEnvelopes.length;
    while (++pathMapIndex < pathMapCount) {
      var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];
      invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, errorSelector);
    }
    var newVersion = cache[__version];
    var rootChangeHandler = modelRoot.onChange;
    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
      rootChangeHandler();
    }
  };
  function invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {
    if (isPrimitive(pathMap) || pathMap.$type) {
      return;
    }
    for (var key in pathMap) {
      if (key[0] !== __prefix && key[0] !== "$" && hasOwn(pathMap, key)) {
        var child = pathMap[key];
        var branch = isObject(child) && !child.$type;
        var results = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, errorSelector);
        var nextNode = results[0];
        var nextParent = results[1];
        if (nextNode) {
          if (branch) {
            invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, errorSelector);
          } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {
            updateNodeAncestors(nextParent, getSize(nextNode), lru, version);
          }
        }
      }
    }
  }
  function invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {
    if (isExpired(node)) {
      expireNode(node, expired, lru);
      return [undefined, root];
    }
    promote(lru, node);
    var container = node;
    var reference = node.value;
    var parent = root;
    node = node[__context];
    if (node != null) {
      parent = node[__parent] || root;
    } else {
      var index = 0;
      var count = reference.length - 1;
      parent = node = root;
      do {
        var key = reference[index];
        var branch = index < count;
        var results = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, errorSelector);
        node = results[0];
        if (isPrimitive(node)) {
          return results;
        }
        parent = results[1];
      } while (index++ < count);
      if (container[__context] !== node) {
        var backRefs = node[__refsLength] || 0;
        node[__refsLength] = backRefs + 1;
        node[__ref + backRefs] = container;
        container[__context] = node;
        container[__refIndex] = backRefs;
      }
    }
    return [node, parent];
  }
  function invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, errorSelector) {
    var type = node.$type;
    while (type === $ref) {
      var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);
      node = results[0];
      if (isPrimitive(node)) {
        return results;
      }
      parent = results[1];
      type = node && node.$type;
    }
    if (type !== void 0) {
      return [node, parent];
    }
    if (key == null) {
      if (branch) {
        throw new Error("`null` is not allowed in branch key positions.");
      } else if (node) {
        key = node[__key];
      }
    } else {
      parent = node;
      node = parent[key];
    }
    return [node, parent];
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/Model", ["npm:falcor@0.1.13/lib/ModelRoot", "npm:falcor@0.1.13/lib/ModelDataSourceAdapter", "npm:falcor@0.1.13/lib/request/RequestQueueRx", "npm:falcor@0.1.13/lib/response/ModelResponse", "npm:falcor@0.1.13/lib/response/SetResponse", "npm:falcor@0.1.13/lib/response/CallResponse", "npm:falcor@0.1.13/lib/response/InvalidateResponse", "npm:falcor@0.1.13/lib/schedulers/ASAPScheduler", "npm:falcor@0.1.13/lib/schedulers/TimeoutScheduler", "npm:falcor@0.1.13/lib/schedulers/ImmediateScheduler", "npm:falcor@0.1.13/lib/support/array-clone", "npm:falcor@0.1.13/lib/support/array-slice", "npm:falcor@0.1.13/lib/lru/collect", "npm:falcor-path-syntax@0.2.1", "npm:falcor@0.1.13/lib/support/getSize", "npm:falcor@0.1.13/lib/support/isObject", "npm:falcor@0.1.13/lib/support/isFunction", "npm:falcor@0.1.13/lib/support/isPrimitive", "npm:falcor@0.1.13/lib/support/isJSONEnvelope", "npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope", "npm:falcor@0.1.13/lib/set/setPathMaps", "npm:falcor@0.1.13/lib/set/setJSONGraphs", "npm:falcor-json-graph@1.1.5", "npm:falcor@0.1.13/lib/support/validateInput", "npm:falcor@0.1.13/lib/get/getCache", "npm:falcor@0.1.13/lib/get/index", "npm:falcor@0.1.13/lib/response/get/validInput", "npm:falcor@0.1.13/lib/response/get/index", "npm:falcor@0.1.13/lib/response/get/getWithPaths", "npm:falcor@0.1.13/lib/deref/index", "npm:falcor@0.1.13/lib/get/getValue", "npm:falcor@0.1.13/lib/set/setValue", "npm:falcor@0.1.13/lib/get/sync", "npm:falcor@0.1.13/lib/set/sync", "npm:falcor@0.1.13/lib/deref/sync", "npm:falcor@0.1.13/lib/get/getBoundValue", "npm:falcor@0.1.13/lib/get/getVersion", "npm:falcor@0.1.13/lib/get/getValueSync", "npm:falcor@0.1.13/lib/set/setPathValues", "npm:falcor@0.1.13/lib/invalidate/invalidatePathSets", "npm:falcor@0.1.13/lib/invalidate/invalidatePathMaps"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ModelRoot = require("npm:falcor@0.1.13/lib/ModelRoot");
  var ModelDataSourceAdapter = require("npm:falcor@0.1.13/lib/ModelDataSourceAdapter");
  var RequestQueue = require("npm:falcor@0.1.13/lib/request/RequestQueueRx");
  var ModelResponse = require("npm:falcor@0.1.13/lib/response/ModelResponse");
  var SetResponse = require("npm:falcor@0.1.13/lib/response/SetResponse");
  var CallResponse = require("npm:falcor@0.1.13/lib/response/CallResponse");
  var InvalidateResponse = require("npm:falcor@0.1.13/lib/response/InvalidateResponse");
  var ASAPScheduler = require("npm:falcor@0.1.13/lib/schedulers/ASAPScheduler");
  var TimeoutScheduler = require("npm:falcor@0.1.13/lib/schedulers/TimeoutScheduler");
  var ImmediateScheduler = require("npm:falcor@0.1.13/lib/schedulers/ImmediateScheduler");
  var arrayClone = require("npm:falcor@0.1.13/lib/support/array-clone");
  var arraySlice = require("npm:falcor@0.1.13/lib/support/array-slice");
  var collectLru = require("npm:falcor@0.1.13/lib/lru/collect");
  var pathSyntax = require("npm:falcor-path-syntax@0.2.1");
  var getSize = require("npm:falcor@0.1.13/lib/support/getSize");
  var isObject = require("npm:falcor@0.1.13/lib/support/isObject");
  var isFunction = require("npm:falcor@0.1.13/lib/support/isFunction");
  var isPrimitive = require("npm:falcor@0.1.13/lib/support/isPrimitive");
  var isJSONEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONEnvelope");
  var isJSONGraphEnvelope = require("npm:falcor@0.1.13/lib/support/isJSONGraphEnvelope");
  var setCache = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  var setJSONGraphs = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  var jsong = require("npm:falcor-json-graph@1.1.5");
  var ID = 0;
  var validateInput = require("npm:falcor@0.1.13/lib/support/validateInput");
  var noOp = function() {};
  var getCache = require("npm:falcor@0.1.13/lib/get/getCache");
  var get = require("npm:falcor@0.1.13/lib/get/index");
  var SET_VALID_INPUT = {
    pathValue: true,
    pathSyntax: true,
    json: true,
    jsonGraph: true
  };
  var GET_VALID_INPUT = require("npm:falcor@0.1.13/lib/response/get/validInput");
  module.exports = Model;
  Model.ref = jsong.ref;
  Model.atom = jsong.atom;
  Model.error = jsong.error;
  Model.pathValue = jsong.pathValue;
  function Model(o) {
    var options = o || {};
    this._root = options._root || new ModelRoot(options);
    this._path = options.path || options._path || [];
    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();
    this._source = options.source || options._source;
    this._request = options.request || options._request || new RequestQueue(this, this._scheduler);
    this._ID = ID++;
    if (typeof options.maxSize === "number") {
      this._maxSize = options.maxSize;
    } else {
      this._maxSize = options._maxSize || Model.prototype._maxSize;
    }
    if (typeof options.collectRatio === "number") {
      this._collectRatio = options.collectRatio;
    } else {
      this._collectRatio = options._collectRatio || Model.prototype._collectRatio;
    }
    if (options.boxed || options.hasOwnProperty("_boxed")) {
      this._boxed = options.boxed || options._boxed;
    }
    if (options.materialized || options.hasOwnProperty("_materialized")) {
      this._materialized = options.materialized || options._materialized;
    }
    if (typeof options.treatErrorsAsValues === "boolean") {
      this._treatErrorsAsValues = options.treatErrorsAsValues;
    } else if (options.hasOwnProperty("_treatErrorsAsValues")) {
      this._treatErrorsAsValues = options._treatErrorsAsValues;
    }
    if (options.cache) {
      this.setCache(options.cache);
    }
  }
  Model.prototype.constructor = Model;
  Model.prototype._materialized = false;
  Model.prototype._boxed = false;
  Model.prototype._progressive = false;
  Model.prototype._treatErrorsAsValues = false;
  Model.prototype._maxSize = Math.pow(2, 53) - 1;
  Model.prototype._collectRatio = 0.75;
  Model.prototype.get = require("npm:falcor@0.1.13/lib/response/get/index");
  Model.prototype._getWithPaths = require("npm:falcor@0.1.13/lib/response/get/getWithPaths");
  Model.prototype.set = function set() {
    var out = validateInput(arguments, SET_VALID_INPUT, "set");
    if (out !== true) {
      return new ModelResponse(function(o) {
        o.onError(out);
      });
    }
    return this._set.apply(this, arguments);
  };
  Model.prototype.preload = function preload() {
    var out = validateInput(arguments, GET_VALID_INPUT, "preload");
    if (out !== true) {
      return new ModelResponse(function(o) {
        o.onError(out);
      });
    }
    var args = Array.prototype.slice.call(arguments);
    var self = this;
    return new ModelResponse(function(obs) {
      return self.get.apply(self, args).subscribe(function() {}, function(err) {
        obs.onError(err);
      }, function() {
        obs.onCompleted();
      });
    });
  };
  Model.prototype._set = function _set() {
    var args;
    var argsIdx = -1;
    var argsLen = arguments.length;
    var selector = arguments[argsLen - 1];
    if (isFunction(selector)) {
      argsLen = argsLen - 1;
    } else {
      selector = void 0;
    }
    args = new Array(argsLen);
    while (++argsIdx < argsLen) {
      args[argsIdx] = arguments[argsIdx];
    }
    return SetResponse.create(this, args, selector);
  };
  Model.prototype.call = function call() {
    var args;
    var argsIdx = -1;
    var argsLen = arguments.length;
    args = new Array(argsLen);
    while (++argsIdx < argsLen) {
      var arg = arguments[argsIdx];
      args[argsIdx] = arg;
      var argType = typeof arg;
      if (argsIdx > 1 && !Array.isArray(arg) || argsIdx === 0 && !Array.isArray(arg) && argType !== "string" || argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {
        return new ModelResponse(function(o) {
          o.onError(new Error("Invalid argument"));
        });
      }
    }
    return CallResponse.create(this, args);
  };
  Model.prototype.invalidate = function invalidate() {
    var args;
    var argsIdx = -1;
    var argsLen = arguments.length;
    var selector = arguments[argsLen - 1];
    args = new Array(argsLen);
    while (++argsIdx < argsLen) {
      args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);
      if (typeof args[argsIdx] !== "object") {
        throw new Error("Invalid argument");
      }
    }
    InvalidateResponse.create(this, args, selector).subscribe(noOp, function(e) {
      throw e;
    });
  };
  Model.prototype.deref = require("npm:falcor@0.1.13/lib/deref/index");
  Model.prototype.getValue = require("npm:falcor@0.1.13/lib/get/getValue");
  Model.prototype.setValue = require("npm:falcor@0.1.13/lib/set/setValue");
  Model.prototype._getValueSync = require("npm:falcor@0.1.13/lib/get/sync");
  Model.prototype._setValueSync = require("npm:falcor@0.1.13/lib/set/sync");
  Model.prototype._derefSync = require("npm:falcor@0.1.13/lib/deref/sync");
  Model.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {
    var cache = this._root.cache;
    if (cacheOrJSONGraphEnvelope !== cache) {
      var modelRoot = this._root;
      var boundPath = this._path;
      this._path = [];
      this._root.cache = {};
      if (typeof cache !== "undefined") {
        collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);
      }
      if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {
        setJSONGraphs(this, [cacheOrJSONGraphEnvelope]);
      } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {
        setCache(this, [cacheOrJSONGraphEnvelope]);
      } else if (isObject(cacheOrJSONGraphEnvelope)) {
        setCache(this, [{json: cacheOrJSONGraphEnvelope}]);
      }
      this._path = boundPath;
    } else if (typeof cache === "undefined") {
      this._root.cache = {};
    }
    return this;
  };
  Model.prototype.getCache = function _getCache() {
    var paths = arraySlice(arguments);
    if (paths.length === 0) {
      return getCache(this._root.cache);
    }
    var result = [{}];
    var path = this._path;
    get.getWithPathsAsJSONGraph(this, paths, result);
    this._path = path;
    return result[0].jsonGraph;
  };
  Model.prototype.getVersion = function getVersion(pathArg) {
    var path = pathArg && pathSyntax.fromPath(pathArg) || [];
    if (Array.isArray(path) === false) {
      throw new Error("Model#getVersion must be called with an Array path.");
    }
    if (this._path.length) {
      path = this._path.concat(path);
    }
    return this._getVersion(this, path);
  };
  Model.prototype._syncCheck = function syncCheck(name) {
    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {
      throw new Error("Model#" + name + " may only be called within the context of a request selector.");
    }
    return true;
  };
  Model.prototype._clone = function cloneModel(opts) {
    var clone = new Model(this);
    for (var key in opts) {
      var value = opts[key];
      if (value === "delete") {
        delete clone[key];
      } else {
        clone[key] = value;
      }
    }
    clone.setCache = void 0;
    return clone;
  };
  Model.prototype.batch = function batch(schedulerOrDelayArg) {
    var schedulerOrDelay = schedulerOrDelayArg;
    if (typeof schedulerOrDelay === "number") {
      schedulerOrDelay = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));
    } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {
      schedulerOrDelay = new ASAPScheduler();
    }
    var clone = this._clone();
    clone._request = new RequestQueue(clone, schedulerOrDelay);
    return clone;
  };
  Model.prototype.unbatch = function unbatch() {
    var clone = this._clone();
    clone._request = new RequestQueue(clone, new ImmediateScheduler());
    return clone;
  };
  Model.prototype.treatErrorsAsValues = function treatErrorsAsValues() {
    return this._clone({_treatErrorsAsValues: true});
  };
  Model.prototype.asDataSource = function asDataSource() {
    return new ModelDataSourceAdapter(this);
  };
  Model.prototype._materialize = function materialize() {
    return this._clone({_materialized: true});
  };
  Model.prototype._dematerialize = function dematerialize() {
    return this._clone({_materialized: "delete"});
  };
  Model.prototype.boxValues = function boxValues() {
    return this._clone({_boxed: true});
  };
  Model.prototype.unboxValues = function unboxValues() {
    return this._clone({_boxed: "delete"});
  };
  Model.prototype.withoutDataSource = function withoutDataSource() {
    return this._clone({_source: "delete"});
  };
  Model.prototype.toJSON = function toJSON() {
    return {
      $type: "ref",
      value: this._path
    };
  };
  Model.prototype.getPath = function getPath() {
    return arrayClone(this._path);
  };
  Model.prototype._getBoundValue = require("npm:falcor@0.1.13/lib/get/getBoundValue");
  Model.prototype._getVersion = require("npm:falcor@0.1.13/lib/get/getVersion");
  Model.prototype._getValueSync = require("npm:falcor@0.1.13/lib/get/getValueSync");
  Model.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;
  Model.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;
  Model.prototype._setPathValuesAsJSON = require("npm:falcor@0.1.13/lib/set/setPathValues");
  Model.prototype._setPathValuesAsJSONG = require("npm:falcor@0.1.13/lib/set/setPathValues");
  Model.prototype._setPathValuesAsPathMap = require("npm:falcor@0.1.13/lib/set/setPathValues");
  Model.prototype._setPathValuesAsValues = require("npm:falcor@0.1.13/lib/set/setPathValues");
  Model.prototype._setPathMapsAsJSON = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  Model.prototype._setPathMapsAsJSONG = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  Model.prototype._setPathMapsAsPathMap = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  Model.prototype._setPathMapsAsValues = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  Model.prototype._setJSONGsAsJSON = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  Model.prototype._setJSONGsAsJSONG = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  Model.prototype._setJSONGsAsPathMap = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  Model.prototype._setJSONGsAsValues = require("npm:falcor@0.1.13/lib/set/setJSONGraphs");
  Model.prototype._setCache = require("npm:falcor@0.1.13/lib/set/setPathMaps");
  Model.prototype._invalidatePathValuesAsJSON = require("npm:falcor@0.1.13/lib/invalidate/invalidatePathSets");
  Model.prototype._invalidatePathMapsAsJSON = require("npm:falcor@0.1.13/lib/invalidate/invalidatePathMaps");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13/lib/index", ["npm:promise@7.0.4", "npm:falcor@0.1.13/lib/Model"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function falcor(opts) {
    return new falcor.Model(opts);
  }
  if (typeof Promise === "function") {
    falcor.Promise = Promise;
  } else {
    falcor.Promise = require("npm:promise@7.0.4");
  }
  module.exports = falcor;
  falcor.Model = require("npm:falcor@0.1.13/lib/Model");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:falcor@0.1.13", ["npm:falcor@0.1.13/lib/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:falcor@0.1.13/lib/index");
  global.define = __define;
  return module.exports;
});

//# sourceMappingURL=vendorBundle.js.map